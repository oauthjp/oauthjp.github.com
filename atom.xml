<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[OAuth.jp]]></title>
  <link href="http://oauthjp.github.io/atom.xml" rel="self"/>
  <link href="http://oauthjp.github.io/"/>
  <updated>2017-03-24T18:24:29+09:00</updated>
  <id>http://oauthjp.github.io/</id>
  <author>
    <name><![CDATA[Nov Matake]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Azure AD B2C が外部 API 向けに払い出す JWT-formatted Access Token について]]></title>
    <link href="http://oauthjp.github.io/blog/2017/03/24/azuread-b2c-jwt-accesstoken/"/>
    <updated>2017-03-24T17:08:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2017/03/24/azuread-b2c-jwt-accesstoken</id>
    <content type="html"><![CDATA[<p><a href="https://azure.microsoft.com/ja-jp/blog/azure-ad-b2c-access-tokens-now-in-public-preview/">Azure AD B2C Access Tokens now in public preview</a></p>

<p>ということで、さわって見ました。</p>

<h2>Step.1 Azure AD B2C テナントの作成</h2>

<p>まずは Azure AD B2C テナントを作成します。なんか portal.azure.com から行くと Classic Portal ベースのドキュメントに飛ばされるので、新しい方の Portal ベースのドキュメントをリンクしときますね。</p>

<p><a href="https://docs.microsoft.com/en-us/azure/active-directory-b2c/active-directory-b2c-get-started">Azure Active Directory B2C: Create an Azure AD B2C tenant</a></p>

<p>テナントを Subscription と紐づけるとかいう処理は Production Use でない限り Skip で OK です。</p>

<h2>Step.2 Web API (Resource Server) および Client の登録</h2>

<p><a href="https://azure.microsoft.com/ja-jp/blog/azure-ad-b2c-access-tokens-now-in-public-preview/">Azure AD B2C Access Tokens now in public preview</a> にしたがって、Web API と Client を登録します。</p>

<p>Web API の登録には Scope の定義もセットです。</p>

<p>Client の登録には Key (Client Secret) の作成と利用可能な API &amp; Scope の設定がセットです。</p>

<p>ちなみに、Resource Server と Client がどちらも同じメニューから作成し、横並びで表示されるのはちょっと違和感ありますね。</p>

<p>Resource Server に Redirect URI (Reply URL) の登録が必須だったり、Implicit を使えるようにするかの選択は Client 側の設定項目で Resource Server 側にそれ設定してもなんの意味もなかったりというのは、MS さんらしいというかなんというか。</p>

<p>なお、</p>

<ul>
<li>App ID URI を登録した Application は固有の scope を定義できるようになり、Resource Server になれる。</li>
<li>App ID URI を登録しない Application は Key (Client Secret) しか作成できず、Client にしかなれない。</li>
<li>Resource Server は Key (Client Secret) も作成できるので同時に Client にもなれる。</li>
</ul>


<p>というルールになっているようですが、3つめの Resource Server かつ Client というのは同じ aud を持つ Access Token と ID Token が生成されることに繋がるので、よほどの事情がない限りやめるべきです。</p>

<!-- more -->


<h2>Step.4 Policy の作成</h2>

<p>Azure AD B2C に外部 Resource Server 向けの JWT 形式の Access Token を払い出させるには、Policy ID を指定しないといけません。</p>

<p>理由は不明ですが、MS さんがそういうのだから仕方ない。</p>

<p>ということで、なんか適当に Sign-in Policies というところに Policy を登録します。</p>

<p>Policy 登録終わると「Metadata Endpoint for this policy」とかいう URL が表示され、そこにアクセスすると OpenID Connect Provider Configuration Document (JSON) が得られます。</p>

<p>OpenID Connect Discovery では Query Parameter とかサポートしてないはずですが、Policy ID (p=xxx) が Query についてるのは MS さんの悪い癖で、なんかやめられない感じなんでしょう。</p>

<p>この Policy は Resource Server ごとに指定するものでも無いようなんで、まぁデフォルトのまま放置して Policy ID だけ取得しとけば OK です。</p>

<h2>Step.3 Access Token の取得</h2>

<p>この Gist に適宜自分で作った Client ID やらなんやら指定してやれば、HTTP のやりとりなどが Console に表示されるんで、それ見ながらフロー確認してください。</p>

<p><a href="https://gist.github.com/nov/0673c8ad02e23a875f05b2be43dd040a">azure_ad_b2c_without_credentials.rb</a></p>

<p>また、もろもろの Azure AD B2C 環境セットアップがめんどくさいという方の為に、こちらに僕が作った RS &amp; Client を Client Secret 含め置いておきます。</p>

<p><a href="https://gist.github.com/nov/9e9b537b897fa2585e085ab1b83b2e3d">azure_ad_b2c.rb</a></p>

<p>動作確認用のユーザーも作っておきましたので、これが正常に動いてる間はご自由にお使いください。</p>

<p>Username: <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#x79;&#x6f;&#x75;&#64;&#x73;&#116;&#115;&#52;&#x62;&#x32;&#x63;&#x2e;&#x6f;&#110;&#x6d;&#105;&#x63;&#x72;&#x6f;&#x73;&#x6f;&#102;&#116;&#46;&#99;&#111;&#109;">&#121;&#x6f;&#117;&#64;&#x73;&#x74;&#115;&#x34;&#98;&#50;&#x63;&#46;&#x6f;&#110;&#x6d;&#105;&#x63;&#x72;&#111;&#115;&#x6f;&#x66;&#x74;&#46;&#x63;&#x6f;&#x6d;</a>
Password: ]6]yzxXYG7uruM4p</p>

<p>動かなくなったら、あきらめて自分で Azure AD B2C 環境セットアップしてください。</p>

<h2>わかったこと</h2>

<ul>
<li>Access Token の audience は Resource Server Application の Object ID。</li>
<li>Access Token の audience は Array にはできない。

<ul>
<li>複数 Resource Server にまたがった Access Token は発行できず、そのような Scope の指定の仕方した時点でエラーになります。</li>
<li>これはセキュリティ的には良いことですね。</li>
</ul>
</li>
<li>ID Token と Access Token の署名鍵は同じ。

<ul>
<li>これはお行儀悪いですね。</li>
<li>Resource Server が Client を兼ねた場合、署名鍵や audience だけではその JWT が Access Token なのか ID Token なのか区別できないケースが発生し、脆弱性につながりかねません。</li>
</ul>
</li>
<li>&ldquo;openid&rdquo; 以外の Scope を指定しないと Token Response に access_token が含まれない。

<ul>
<li><a href="https://tools.ietf.org/html/rfc6749#section-4.2.2">RFC 6749</a> に違反しており、利用しているライブラリによってはユーザーが Query 書き換えただけで Client 側で 500 エラー発生させたりできそうです。</li>
</ul>
</li>
</ul>


<p>ということで、ここで発行された Access Token を受け取った Resource Server は、</p>

<ul>
<li>署名が正しく</li>
<li>JWT の &ldquo;aud&rdquo; Claim が自身の Azure AD B2C 上の Object ID であり</li>
<li>必要な Scope が &ldquo;scp&rdquo; Claim に含まれており</li>
<li>&ldquo;azp&rdquo; Claim に含まれる Client ID が正当な Client のものであり</li>
<li>期限切れでない</li>
</ul>


<p>ことを確認する感じになりますね。</p>

<p>今日のところは以上です。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GitHub Business Plan 登場、GitHub.com ドメインで SCIM と SAML をサポート。]]></title>
    <link href="http://oauthjp.github.io/blog/2017/03/07/github-support-saml-and-scim/"/>
    <updated>2017-03-07T21:18:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2017/03/07/github-support-saml-and-scim</id>
    <content type="html"><![CDATA[<p>オンプレサーバーで GitHub Enterprise をお使いのみなさま。</p>

<p>日々オンプレサーバーのメンテ、おつかれさまです。</p>

<p>GitHub.com の Business Plan っての、良さそうですよね。</p>

<p>SCIM と SAML サポートしてて、いままでオンプレ版でしかできなかった Provisioning と Federation (SSO といった方が伝わるか？) が、GitHub.com ドメインでできるようになったんですよ。</p>

<p>これで GitHub.com が生きてればいつでも Deploy できますよ。</p>

<p>死ぬもんね、オンプレ。てか、一旦死んだら結構しばらくの間死ぬもんね、オンプレ。</p>

<p>GitHub.com なら、AWS が生き返ればきっと生き返るよ。</p>

<p>ということで、Business Plan の SAML と SCIM、ちょっと試してみましたよ。</p>

<h1>SAML 設定</h1>

<p>GitHub Help の <a href="https://help.github.com/articles/managing-member-identity-and-access-in-your-organization-with-saml-single-sign-on/">この一連のドキュメント</a> を読む限り、SAML 設定しないと SCIM 使えないようです。</p>

<p>あ、SAML の SP Entity ID とかはドキュメントには書いてないです。</p>

<p>Business Plan 契約して設定画面行かないと、SP Entity ID も Assertion Consumer Service (ACS) URL もわかんないです。</p>

<p>まず金払ってからしか試せません。</p>

<p><strong>ファーストひどい。</strong></p>

<!-- more -->


<p>で、金払って Organization の Security 設定ページ (<a href="https://github.com/organizations/YOUR-ORGANIZATION/settings/security">https://github.com/organizations/YOUR-ORGANIZATION/settings/security</a>) にアクセスすると、SAML 設定が ON にできるようになってます。</p>

<p>ここに以下の情報が表示されています。</p>

<ul>
<li>Organization single sign-on URL

<ul>
<li><a href="https://github.com/orgs/YOUR-ORGANIZATION/sso">https://github.com/orgs/YOUR-ORGANIZATION/sso</a></li>
</ul>
</li>
<li>Assertion consumer service URL

<ul>
<li><a href="https://github.com/orgs/YOUR-ORGANIZATION/saml/consume">https://github.com/orgs/YOUR-ORGANIZATION/saml/consume</a></li>
</ul>
</li>
</ul>


<p>あれ？SP Entity ID は？と思ったそこのあなた。</p>

<p>SP Entity ID はここには記載されていません。</p>

<p><strong>セカンドひどい。</strong></p>

<p>実際 SAML Request を発行させてみないとわからないっぽいんですが、面倒なんでここに書いときますね。</p>

<ul>
<li>SP Entity ID

<ul>
<li><a href="https://github.com/orgs/YOUR-ORGANIZATION">https://github.com/orgs/YOUR-ORGANIZATION</a></li>
</ul>
</li>
</ul>


<p>です。</p>

<p>で、これらを元に IdP 側に SP 登録して、その後 GitHub 側で以下の情報を入力すると、SAML 設定自体は完了です。</p>

<ul>
<li>Sign on URL</li>
<li>Issuer (IdP Entity ID)</li>
<li>Public Certificate (IdP Certificate)</li>
</ul>


<p>え？NameID Format はって？</p>

<p>えぇ、特にドキュメントにも設定画面にも指定ないですね。</p>

<p>そう、特にドキュメントにも設定画面にも指定ないです。</p>

<p><strong>サードひどい。</strong></p>

<p>Business Plan になってからサポートに問い合わせたら、Gist に書かれたドキュメントが送られて来て、そこには NameID Format は Email だよって書いてあったんで、Email 推奨のようです。</p>

<p>が、実は UUID とか指定しても動きます。</p>

<p>あと、Email 指定してもそのメアドのユーザーにログインできるわけでもないです。</p>

<p><a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#110;&#x6f;&#118;&#x40;&#101;&#120;&#97;&#x6d;&#112;&#108;&#101;&#46;&#x63;&#111;&#x6d;">&#110;&#x6f;&#118;&#64;&#101;&#120;&#97;&#109;&#112;&#x6c;&#101;&#x2e;&#99;&#x6f;&#109;</a> の NameID を持つ SAML Assertion で、<a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#110;&#x6f;&#118;&#x40;&#x6d;&#97;&#116;&#97;&#x6b;&#x65;&#x2e;&#106;&#x70;">&#x6e;&#111;&#x76;&#x40;&#109;&#97;&#x74;&#x61;&#107;&#101;&#x2e;&#x6a;&#x70;</a> の GitHub アカウントにログインできたりします。</p>

<p>SAML Federation とか言うてるけど、結局既存の GitHub.com アカウントに SAML IdP 側のアカウントを Link するだけなんですよ。</p>

<p>その紐付けは、SAML での初回ログイン時に GitHub.com 側の ID &amp; Password 入力して行います。</p>

<p>つまり、<a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x6e;&#x6f;&#118;&#x40;&#101;&#120;&#97;&#x6d;&#x70;&#108;&#101;&#x2e;&#99;&#x6f;&#109;">&#110;&#x6f;&#118;&#64;&#x65;&#120;&#x61;&#x6d;&#112;&#108;&#101;&#46;&#x63;&#x6f;&#109;</a> の NameID を持つ SAML Assertion をどの GitHub アカウントに紐づけるかは、エンドユーザーが決定権を持っています。</p>

<p>情シスじゃないです。</p>

<p><strong>フォースひどい。てかお前それ致命的やろ。</strong></p>

<p>ちなみに、NameID は不変かつ同一 IdP 内でユニークでさえあればなんでもいいです。</p>

<p>Email 推奨してたドキュメントは、多分なんか気分的に Email のがいんじゃね？くらいのノリだったんだと思います。</p>

<p>実際には NameID Format が Persistent で NameID が UUID、とかにしても普通に動いてました。</p>

<h2>SCIM 設定</h2>

<p>SCIM にいたっては、一切のドキュメントが公開されていません。</p>

<p>GitHub が公式サポートをうたう OneLogin から GitHub.com を選んで設定してみましたが、OneLogin 側に設定が必要な SCIM Base URL の値すらどこにも書いてありません。</p>

<p><strong>もうひどいカウントやめていいですか？</strong></p>

<p>はい、サポートに問い合わせて聞いたら Gist のドキュメント送られて来ます。</p>

<p>普通に SCIM Base URL 書いてあります。</p>

<ul>
<li>SCIM Base URL

<ul>
<li><a href="https://api.github.com/scim/v2/organizations/YOUR-ORGANIZATION">https://api.github.com/scim/v2/organizations/YOUR-ORGANIZATION</a></li>
</ul>
</li>
</ul>


<p>で、ここに <code>admin:org</code> scope 持つ OAuth2 Token を添えて SCIM API Request 送ってやればいいです。</p>

<p>あ、どの属性が必須かって？</p>

<p>Gist ドキュメントもらえば書いて&hellip;ないですけど、API リクエスト送り続けてエラー見続けたらそのうちわかります。</p>

<p>ということで、現状の挙動見る限り、必須な SCIM User Attributes は以下の通りです。</p>

<ul>
<li>id</li>
<li>userName (email)</li>
<li>name

<ul>
<li>familyName</li>
<li>givenName</li>
</ul>
</li>
<li>emails (userName と同じメアドを primary に)</li>
</ul>


<p>はい、ドキュメントさえあれば、プロビジョニングなんて簡単ですよ。</p>

<p>で、プロビするじゃないですか？</p>

<p>さすがにプロビしたアカウントに関しては、SAML で NameID にそのメアド指定したら GitHub.com アカウントとの紐付けとかなくするっとログインできると思うじゃないですか？</p>

<p>はい、SAML 初回ログイン時にアカウント紐付け必須です。</p>

<p>てかそもそも SAML Assertion に指定されるメアドと GitHub.com アカウントのメアドが一致する必要はないので、SCIM でプロビしたアカウントに別メアドの SAML Assertion 送りつけて紐付けたりもできます。</p>

<p><strong>お前それ致命的やろ。</strong></p>

<p>よくそれで月額 <strong>$21/user</strong> も取れると思ったな。</p>

<p>いや、Business Plan アカウントに対するサポートからの回答速度は爆速ですけど。</p>

<p>1時間もしないうちに回答きますけど。</p>

<p>そこはすばらしいですけど。</p>

<p><strong>お前それ致命的やろ。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MacOS Sierra (10.12.x) でマイナポータルにログイン]]></title>
    <link href="http://oauthjp.github.io/blog/2017/01/26/myna-on-mac-os-sierra/"/>
    <updated>2017-01-26T21:37:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2017/01/26/myna-on-mac-os-sierra</id>
    <content type="html"><![CDATA[<p>お久しぶりです、nov です。</p>

<p>おかげで無事12月末で <a href="http://yauth.jp">YAuth.jp</a> も初年度を終え、2期目に突入しております。</p>

<p>MVP は意気込み送ってこいや的なメールが来ており、いいかげんそろそろ Windows 10 でドメインジョイン (正直 UX とかよくわかってない) せんとなぁとか思いつつ、今日は MacOS です。</p>

<p>MacOS でマイナポータルにログインするお話です。</p>

<p>みなさん、知ってましたか？マイナポータルって OpenID Connect の IdP なんですよ！もしかしたら Access Token とか払い出しちゃう機能なんかもあるんですよ！</p>

<p>ということで、まぁその辺を調べるにも、ログインせんことには何も始まりません。</p>

<p><strong>え？マイナンバーカード持ってないだって？？んなやつぁしらん！！！</strong></p>

<p>そんな人は <a href="https://openid-foundation-japan.github.io/800-63-3/index.ja.html">NIST SP 800-63-3 翻訳版</a> でも読んで、Identity Proofing とかハードウェアトークンとかに思いをはせつつ市役所いって取って来てください。</p>

<p>マイナンバーカード取る時、NIST SP 800-63-3 の3ページ目テストに出ますからね。</p>

<!-- more -->


<p><em>嘘です。</em></p>

<h2>MacOS Sierra でマイナポータルにログイン</h2>

<p>さて、Windows 10 でログイン、できるに決まってますよね。</p>

<p>e-Tax にログインできるんなら、おなじような仕組みのマイナポータルにだってログインできるに決まってます。</p>

<p>ということで、今日は e-Tax から見放された MacOS Sierra でマイナポータルにログインしてみましょう。</p>

<p>クソ長い PDF を真面目に読まれる方は、<a href="https://myna.go.jp/SCK0101_03_001/SCK0101_03_001_Init.form">公式マイナポータルログイン手順</a> をご覧ください。</p>

<h3>カードリーダー買う &amp; ドライバーインストール</h3>

<p>マイナンバーカードリーダーのアフィリンクを貼りたいがためにこの記事を書いているといっても過言ではありません。</p>

<p>このサンワサプライのカードリーダーは、<a href="https://www.sanwa.co.jp/support/download/dl_driver_ichiran.asp?code=ADR-MNICUBK">MacOS Sierra 対応のドライバ</a> あります。</p>

<p><a href="http://amzn.to/2j7WSEx"><img src="https://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=B01M2DJ9WG&amp;Format=_SL160_&amp;ID=AsinImage&amp;MarketPlace=JP&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=bianca0b-22" alt="サンワサプライ 接触型ICカードリーダライタ ADR-MNICUBK" /></a></p>

<p>マイナポータル公式の対応カードリーダー表には El Capitan の欄はあるけど Sierra の欄がなく、そこみてもどれが Sierra 対応なのかよくわかりません。</p>

<p>NTT コミュニケーションズのやつはドライバが El Capitan までだったりしたので、Sierra 対応カードリーダー選ぶのが最初のハードルです。</p>

<p>さて、Amazon さんから <a href="http://amzn.to/2j7WSEx">サンワサプライ 接触型ICカードリーダライタ ADR-MNICUBK</a> 届いたら、Sierra 対応のドライバインストールしてください。</p>

<p>この記事執筆時点では、以下の一番下のやつです。</p>

<p><a href="https://www.sanwa.co.jp/support/download/dl_driver_ichiran.asp?code=ADR-MNICUBK"><img src="http://oauthjp.github.io/images/posts/myna/card-reader-drivers.png" alt="ADR-MNICUBK Deivers" /></a></p>

<p>これでカードリーダーのセットアップは完了です。</p>

<h3>Java 8 Update 121 にアップデート</h3>

<p><a href="https://img.myna.go.jp/html/dousakankyou.html">マイナポータル動作環境について</a> によると、Java Version 8 Update 111 以上が必要なようです。</p>

<p>あと、Java のアップデートするたびに、ポリシーファイルとかいうのが書き換えられて、再度なんか設定し直しらしいです。</p>

<p>ということで、とりあえず現時点での最新の Java 入れときましょう。</p>

<p><img src="http://oauthjp.github.io/images/posts/myna/java8-121.png" alt="Java 8 Update 121" /></p>

<p>Oracle Java 入れたことあれば　MacOS の設定アプリに屈辱の &ldquo;Java&rdquo; メニュー現れてるはずなんで、そっからアップデートできるはずです。</p>

<p>入れたこと無い人は、&#8221;MacOS Java 8&#8221; とかでググるなりして入れてください。</p>

<p>屈辱です。</p>

<h3>JPKI 利用者クライアントソフトのインストール &amp; 初期設定</h3>

<p>続いて <a href="https://img.myna.go.jp/html/dousakankyou.html">マイナポータル動作環境について</a> の「JPKI利用者クライアントソフトの準備」からもリンクされてる <a href="https://www.jpki.go.jp/download/index.html">JPKI利用者クライアントソフト</a> の MacOS 版をインストールします。</p>

<p>こいつはちょっと時代の流れに付いてくるのがゆっくりなので、「JRE 8.0 Update111」を推奨して来ますが、Java 8 Update 121 では少なくとも動きます。</p>

<p>あ、あと「Smart Card Services」は入れちゃダメです！</p>

<p>いや、不要なだけで入れてもいいのかもです。</p>

<p>まぁとにかくマイナンバーカード使う場合は「Smart Card Services」はいりません。</p>

<p>ということで、入れるのは　<a href="https://www.jpki.go.jp/download/mac.html">JPKI利用者クライアントソフト &ndash; Macintosh をご利用の方</a> の一番下の方の「利用者クライアントソフトのダウンロード」ってとこにリンクされてるやつです。</p>

<p><em>いや、ダウンロードリンク下すぎでしょ。</em></p>

<p>で、インストール終わるとこんなの出て来ます。</p>

<p>よくわかんないけど「はい」にしときましょう。</p>

<p><img src="http://oauthjp.github.io/images/posts/myna/jpki-cert-expiry-notification.png" alt="JPKI 証明書有効期限通知設定" /></p>

<p>Retina 対応してないやつ、久々にみました。</p>

<p>最後にインストールされた全アプリが表示されます。</p>

<p><img src="http://oauthjp.github.io/images/posts/myna/jpki-applications.png" alt="JPKI アプリ一覧" /></p>

<p>この中の「Java実行環境への登録」ってのだけ実行しといてください。</p>

<h3>マイナポータル環境設定プログラムのインストール &amp; 設定</h3>

<p>さて、JPKI 利用者クライアントソフトの設定が終わったら、また <a href="https://img.myna.go.jp/html/dousakankyou.html">マイナポータル動作環境について</a> に戻って、今度は「マイナポータル環境設定プログラムの実施」ってとこから「<a href="https://img.myna.go.jp/tools/mac/MyNASetup.pkg">環境設定プログラム (Mac 用)</a>」をインストールします。</p>

<p>こいつはインストール後に特に何かを主張したりはしません。</p>

<h3>ブラウザの制限をちょっと弱める</h3>

<p>最後に <a href="https://img.myna.go.jp/manual/2.pdf">マイナポータル環境設定プログラム &ndash; ご利用方法マニュアル</a> の P.20〜P.25 だけちゃんと読みながら、ブラウザのセキュリティ制限を少しずつ弱めます。</p>

<p>P.24 の「安全でないモード」とか、なんていう裏技感。</p>

<p>あ、ちなみに Chrome はサポートされてません。</p>

<p>Safari 使ってください。</p>

<h3>いよいよマイナポータルログイン</h3>

<p>さて、ここまで設定できたら、Safari を再起動して、マイナポータルトップ画面のログインボタンをクリックしてください。</p>

<p>マイナンバーカード取得時に設定した PIN コードの入力を求める Popup が出て来たら、成功です。</p>

<p><img src="http://oauthjp.github.io/images/posts/myna/myna-pin-input.png" alt="マイナポータルログイン" /></p>

<p>PIN を入れてログイン成功したことを確認したら、あとはご自由にマイナポータルで遊んでみてください。</p>

<p>特にまだ何ができるわけでもないですけどね。</p>

<h3>最後に</h3>

<p>ここまで来たあなたは、ブラウザのセキュリティ制約をいくつか解除してしまっています。</p>

<p>マイナポータルに満足したら、ちゃんと元どおり 3rd-party Cookie は「閲覧した Web サイトは許可」、Popup はブロック、Java プラグインは無効化しておきましょう。</p>

<p>いや、もっと厳しくしてもいいし、そのまんまでいいならそれも自己判断でいいんですけどね。</p>

<p>では、素敵なマイナライフを！！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTPS でも Full URL が漏れる？OAuth の code も漏れるんじゃね？？]]></title>
    <link href="http://oauthjp.github.io/blog/2016/07/27/https-full-url-leaks/"/>
    <updated>2016-07-27T10:48:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/07/27/https-full-url-leaks</id>
    <content type="html"><![CDATA[<p>なんですかこれは！</p>

<p><a href="http://arstechnica.com/security/2016/07/new-attack-that-cripples-https-crypto-works-on-macs-windows-and-linux/">New attack bypasses HTTPS protection on Macs, Windows, and Linux</a></p>

<p>DHCP につなぐと PAC ファイルがダウンロードされて HTTPS であろうとアクセス先の Full URL は漏れるですって？</p>

<p>Web Proxy Autodiscovery ですって？</p>

<p>チョットニホンゴデオネガイシマス</p>

<p>ってことで、まぁこれが実際どれくらい簡単に実現できる攻撃パターンなのかは他のセキュリティ業界の方々に後で聞くとして、この記事でも触れられてる OpenID Connect とか OAuth2 への影響について、ちょっとまとめておきましょうか。</p>

<h2>Authorization Request &amp; Response が漏れる</h2>

<p><code>response_mode=form_post</code> なんていうのも一部ありますが、基本 OAuth2 / OpenID Connect の Authorization Request &amp; Response は GET です。</p>

<p>Implicit Flow の場合は Response Parameter が URL Fragment についてるので、Server に送られる Full URL が漏れたところで特に URL Fragment の内容は漏れないですが、Code Flow の場合は Response の Query についてる Authorization Code は漏れますね。</p>

<p>まぁ Authorization Request に含まれる <code>state</code> とかも漏れますが、今回のケースだと Cookie とかは漏れないんで、<code>state</code> が漏れること自体は大して問題ではないでしょう。</p>

<p>ただ、Redirect URL に HTTPS 使っても <code>code</code> 漏れるってのは、辛そうですね。</p>

<h2>Authorization Code が漏れたらどうなるの？</h2>

<p>Code 置換攻撃 (Code Cut &amp; Paste Attack) が可能になります。</p>

<p>ここに漏れた <code>code</code> があるとしましょう。すると、以下の手順で攻撃者は <code>code</code> 所有者の RP 上のアカウントにログインすることができます。</p>

<ol>
<li>攻撃者自身のブラウザで Authorization Request 発行</li>
<li>攻撃者自身の IdP 上のアカウントで IdP にログイン</li>
<li>Authorization Response を途中で止める</li>
<li>Authorization Response 中に含まれる <code>code</code> を被害者のものに置換 (<code>state</code> は置換しない)</li>
<li>Code 置換済の Authorization Response を RP に送る</li>
</ol>


<p>こうすると、RP が <code>state</code> を使った CSRF 対策を行っていても、RP は受け取った <code>code</code> を使って攻撃者を被害者としてログインさせてしまいます。</p>

<p>これが Code 置換攻撃です。</p>

<p>では、これを防ぐ手立てはあるのでしょうか？</p>

<!-- more -->


<h2>OpenID Connect の場合 : ID Token の nonce をチェック</h2>

<p>OpenID Connect では、Authorization Request で <code>nonce</code> というパラメータを送ることができますね。</p>

<p>あれは <code>state</code> とよく似た役割を果たしますが、<code>code</code> とは紐付かない <code>state</code> と異なり、<code>nonce</code> は <code>code</code> と紐づいて保存され、最終的に発行される ID Token に含まれて返ってきます。</p>

<p>よって、<code>code</code> だけ置換しても、<code>nonce</code> に紐付いた Cookie なりを奪わない限り、RP が Token Endpoint から返ってきた <code>nonce</code> をチェックした時点で <code>code</code> 置換を検知できることになります。</p>

<p>ようするに、OpenID Connect の仕様的には OPTIONAL やけど、とりあえず <code>nonce</code> 使っとけや、ってことですね。</p>

<h2>OAuth 2.0 の場合 (1) : PKCE 拡張を使う</h2>

<p><code>nonce</code> のない OAuth 2.0 の場合、Authorization Request &amp; Response のセッションと <code>code</code> を紐付けるパラメータが特にありません。</p>

<p>そして、それでは Code 置換攻撃は防げません。</p>

<p>よって、<code>code</code> と紐付いたパラメータを用意してやる必要があります。</p>

<p>OpenID Foundation Japan 事務局長としては「OpenID Connect 使えや」って話でもあるわけですが、もうちょっとお手軽な方法としては <a href="https://tools.ietf.org/html/rfc7636">OAuth PKCE</a> というのもあります。</p>

<p>PKCE はもともと <code>client_secret</code> を持てない OAuth Client 向けに作られた仕様ですが、Authorization Request で送った <code>code_challenge</code> と紐づく <code>code_verifier</code> を Token Endpoint に送ることになるので、当然ながら IdP 側では <code>code</code> と <code>code_challenge</code> を紐付けて管理することになります。</p>

<p>つまり、<code>code</code> を置換すると、<code>code_verifier</code> が合わなくなって、Token Request が失敗する、と。</p>

<p>ちなみに、PKCE には <code>code_challenge_mode</code> っていうパラメータがありますが、<code>code_challenge_mode=plain</code> は Authorization Request みれる状況では <code>code_verifier</code> 自体が漏れることになるんでダメで、この攻撃防ぐためには <code>S256</code> を使ってくださいね。</p>

<p>さて、これで OAuth 2.0 でも Code 置換攻撃、防げましたね。</p>

<p>これからは Confidential Client (<code>client_secret</code> 持てる OAuth Client) でも PKCE 使えってことですね。</p>

<p>ただ PKCE は OAuth 拡張なんで、OAuth Server (IdP) 側がまず PKCE 対応する必要があります。</p>

<p>Facebook Login とか使ってる人たちは、どうすればいいんでしょうねぇ〜</p>

<h2>OAuth 2.0 の場合 (2) : response_mode=form_post を使う (Thanks to @zigorou)</h2>

<p>PKCE 同様 <code>response_mode=form_post</code> も拡張仕様なのでどの OAuth Server (IdP) でも使えるわけではないですが、<code>response_mode=form_post</code> を使うと Authorization Code は POST Body に含まれて返されるので、Full URL が漏れても <code>code</code> は漏れません。</p>

<p>Session と紐付けた <code>nonce</code> なり <code>code_verifier</code> なりを管理するより、RP にとっては <code>response_mode=form_post</code> を使うほうが楽かもしれませんね。</p>

<p>「Session と紐付ける」って概念、意外に通じないことも多いですし。</p>

<h2>まとめ</h2>

<p>OpenID Connect を使ってる場合は、RP が常に <code>nonce</code> 使えばいいだけなんで、RP だけが注意してれば大丈夫ですね。</p>

<p>OAuth 2.0 を使ってる場合は、OAuth Server (IdP) 側がまず PKCE なり OpenID Connect なりに対応して、RP がそれを使う必要がありそうです。</p>

<p><strong>Facebook のみなさん、聞こえますかぁ〜</strong></p>

<p>ps.</p>

<p>「OAuth 2.0 の場合」というセクションタイトルになってますが、OpenID Connect でも nonce の代わりに PKCE なり response_mode=form_post 使ってもいいです。</p>

<p>OAuth 2.0 のレベルで解決できてるなら、OpenID Connect 特有のパラメータを利用しなくても (この攻撃は) 防げます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NIST 800-63C を翻訳しました]]></title>
    <link href="http://oauthjp.github.io/blog/2016/07/15/nist-800-63c/"/>
    <updated>2016-07-15T15:06:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/07/15/nist-800-63c</id>
    <content type="html"><![CDATA[<p>先日このブログでも紹介した <a href="http://oauth.jp/blog/2016/07/01/jwk-and-oauth-revocation-translated/">OAuth Revocation, JWK JWK Thumbprint 仕様の翻訳版</a> に引き続き、OpenID Foundation Japan 翻訳・教育 WG リーダーとしての Nov です。</p>

<p>先日 <a href="https://www.facebook.com/OpenIDTrans/posts/1226159194083566">翻訳 WG の Facebook Page</a> でも告知したように、現在 <a href="https://pages.nist.gov/800-63-3/">NIST SP 800-63-3 &ndash; Digital Authentication Guideline</a> の翻訳を開始しています。</p>

<p>今日はその中から、すでに翻訳が完了している <a href="https://openid-foundation-japan.github.io/800-63-3/sp800-63c.ja.html">NIST SP 800-63C &ndash; Federation and Assertions</a> のご紹介です。</p>

<h2>Level of Assurance</h2>

<p>プロフェッショナルなみなさまのことです、すでに Level of Assurance とか LoA とかいう単語を耳にしたこともおありでしょう。</p>

<p>NIST SP 800-63 は、LoA の各レベルでの要求事項を具体的に定めている NIST (米国国立標準技術研究所) の公式ドキュメントで、800-63-3 はその Revision 3 です。</p>

<p>Revison 3 では、Revision 2 まで単一のドキュメントだった 800-63 を、以下の4つに分割しています。</p>

<ul>
<li>SP 800-63-3 (Digital Authentication Guideline)</li>
<li>SP 800-63A (Identity Proofing &amp; Enrollment)</li>
<li>SP 800-63B (Authentication &amp; Lifecycle Management)</li>
<li>SP 800-63C (Federation &amp; Assertions)</li>
</ul>


<p>そして LoA も3つの Assurance Levels に分割し、それぞれをレベル分けした上で、それぞれのレベルの組み合わせを持って LoA を定義しています。</p>

<ul>
<li>Identity Assurance Level (IAL, Lv.1 &ndash; Lv.3 までの3段階)</li>
<li>Authenticator Assurance Level (AAL, Lv.1 &ndash; Lv.3 までの3段階)</li>
<li>Federation Assurance Level (FAL, Lv.1 &ndash; Lv.4 までの4段階)</li>
</ul>


<p>LoA 自体は今まで通り Lv.1 &ndash; Lv.4 までの4段階で、それぞれの LoA に求められる IAL, AAL, FAL のレベルは以下の通りとなっています。</p>

<table>
<thead>
<tr>
<th></th>
<th> LOA </th>
<th> IAL </th>
<th> AAL </th>
<th> FAL </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>  1  </td>
<td>  1  </td>
<td>  1  </td>
<td>  1</td>
</tr>
<tr>
<td></td>
<td>  2  </td>
<td>  2  </td>
<td> 2 or 3 </td>
<td>  2</td>
</tr>
<tr>
<td></td>
<td>  3  </td>
<td>  2  </td>
<td> 2 or 3 </td>
<td>  2</td>
</tr>
<tr>
<td></td>
<td>  4  </td>
<td>  3  </td>
<td> 3 </td>
<td>  4</td>
</tr>
</tbody>
</table>


<p>LoA Lv.2.5 とか、Lv.1+ とか、謎のオレオレ定義が乱立してた LoA の定義も、こういう仕組みで多少はフィレキシブルに扱えるように&hellip;</p>

<p>ま、なるといいですね。</p>

<h2>Federation Assurance Level (FAL)</h2>

<p>で、上記のうち FAL を定義しているのが、<a href="https://openid-foundation-japan.github.io/800-63-3/sp800-63c.ja.html">NIST SP 800-63C &ndash; Federation and Assertions</a> です。</p>

<p>800-63C では、Assertion と Federation Protocol のレベル分けのために、それらの特徴を複数のカテゴリに渡って分類し、それらの組み合わせによって FAL を定義しています。</p>

<table>
<thead>
<tr>
<th></th>
<th> FAL </th>
<th> Requirement </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>  1  </td>
<td> Bearer assertion, direct presentation, asymmetrically signed by CSP</td>
</tr>
<tr>
<td></td>
<td>  2  </td>
<td> Bearer assertion, indirect presentation, asymmetrically signed by CSP</td>
</tr>
<tr>
<td></td>
<td>  3  </td>
<td> Bearer assertion, indirect presentation, asymmetrically signed by CSP and encrypted to RP</td>
</tr>
<tr>
<td></td>
<td>  4  </td>
<td> Holder of key assertion, indirect presentation, asymmetrically signed by CSP and encrypted to RP</td>
</tr>
</tbody>
</table>


<p>Bearer か Holder-of-Key かとか、Direct か Indirect か (Artifact 使うか使わないか) とか、署名のみか署名後暗号化するかとか、プロフェッショナルなみなさまにはたまらないですよね！</p>

<p>ってことで、プロフェッショナルなみなさまにおかれましては、ぜひ翻訳版読んでいただいて、<a href="https://github.com/openid-foundation-japan/800-63-3">日本語版の GitHub Repository</a> へのフィードバックお待ちしております！</p>

<p>あと NIST 本家の英語版も絶賛更新中らしいんで、<a href="https://github.com/usnistgov/800-63-3">英語語版の GitHub Repository</a> にもフィードバックしてあげると喜ばれると思います！</p>

<p>僕も3箇所ほどフィードバックして見ましたが、特に報告者の国籍等は関係無く反応返ってくるので、どっかのパブコメよりはよっぽど&hellip;おっと、誰か来たようだ。</p>

<h2>残りの 800-63-3, 800-63A, 800-63B について</h2>

<p>絶賛翻訳中です。</p>

<p>NIST 800-63-3 シリーズはセクションごとにファイルが分割していて翻訳箇所の並列化がしやすくなってるので、翻訳手伝ってくれるひとはまだまだ募集してます。</p>

<p>応募方法は <a href="https://www.facebook.com/OpenIDTrans/posts/1226159194083566">翻訳 WG の Facebook Page</a> をご覧ください。</p>

<p>じっくりドキュメントを読み込みたい方には、翻訳とかいい機会だと思いますよ！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Office 365 と外部 SAML IdP との連携設定]]></title>
    <link href="http://oauthjp.github.io/blog/2016/07/01/o365-saml-federation/"/>
    <updated>2016-07-01T11:03:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/07/01/o365-saml-federation</id>
    <content type="html"><![CDATA[<p>どうも、事務局長の Nov です。</p>

<p>どうも、ジムキョクチョのノブです。</p>

<p>どうも、ノブキョクチョです。</p>

<p>どうも、のぶチョです。</p>

<p>そう、のぶ千代です。</p>

<p>最近歳のせいか、Rails で SAML IdP とか作ってます。</p>

<p>今日は自作 SAML IdP を Office 365 と連携させてみたので、その格闘の記録を残しておきます。</p>

<p>Office 365 の制約とか Azure AD の制約とか全く前提知識なしに格闘した記録なんで、そういうのいいから手っ取り早くやり方教えろやって人は我らがふぁらおぅ兄さんのこちらの連載をご覧ください。</p>

<ul>
<li><a href="http://idmlab.eidentity.jp/2014/11/office365azureadopenamid.html">Office365/AzureAD &ndash; OpenAMとのID連携 (1)</a></li>
<li><a href="http://idmlab.eidentity.jp/2014/12/office365azureadopenamid.html">Office365/AzureAD &ndash; OpenAMとのID連携 (2)</a></li>
<li><a href="http://idmlab.eidentity.jp/2014/12/office365azureadopenamid_25.html">Office365/AzureAD &ndash; OpenAMとのID連携 (3)</a></li>
</ul>


<!-- more -->


<h2>Office 365 &amp; Azure AD のドメインが違う問題</h2>

<p>僕、最初に Azure AD に YAuth.jp のディレクトリ (<code>yauth.onmicrosoft.com</code>) 作成して、そのあと別の機会に Office 365 の Subscription (<code>yauthjp.onmicrosoft.com</code>) を開始したんで、それら2つが別ディレクトリになっておりまして、前者に <code>yauth.jp</code> ドメインを紐付けてたんで、Office 365 側に <code>yauth.jp</code> ドメインを紐付けられなかったんですね。</p>

<p>で、二つを Merge しようとして <a href="http://ebi.dyndns.biz/windowsadmin/2016/04/07/azure%E3%82%B5%E3%83%96%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E6%97%A2%E5%AE%9A%E3%81%AE%E3%83%87%E3%82%A3%E3%83%AC%E3%82%AF%E3%83%88%E3%83%AA%E3%82%92o365%E3%81%A7/">Azureサブスクリプションの既定のディレクトリをO365で利用しているAzure Active Directoryに変更する方法</a> ってのを教えてもらったんで、やってみようとしたんですが&hellip;</p>

<p>よくみたら Merge じゃなかったっていうね。</p>

<p>で、まぁ Azure AD 側の <code>yauth.onmicrosoft.com</code> はもうあきらめて消しちゃえってことで消そうとしたら、ユーザーいるから消せねーだの、アプリが登録されてるから消せねーだの言われて、ちまちま消した挙句、<code>Office 365 Management APIs</code> ってのが最後どうしても消せず&hellip;</p>

<p>こうなった。</p>

<p><img src="http://oauthjp.github.io/images/posts/azure/azure-ad-directories.png" alt="Azure AD Directories" /></p>

<p>消せないけどいらん <code>yauth.onmicrosoft.com</code> 側のディレクトリを &ldquo;remove-me&rdquo; にリネームして、そっちから <code>yauth.jp</code> の紐付け解除して <code>yauthjp.onmicrosoft.com</code> 側のディレクトリに紐付け直した。</p>

<p>しょっぱなから解決してないですね。</p>

<p>でも結論から言いますと、これ、たぶん SAML 連携とは全く関係なかったんだろうなって、いまでは思います。</p>

<h2>PowerShell 必須問題</h2>

<p>なんか Azure AD の管理画面には SAML IdP 追加する箇所ないんですよ。</p>

<p>SAML IdP の登録に必要なパラメータなんてせいぜい5-6個やのに、PowerShell ってやつが必須なんですよ。</p>

<p>で、どうも Google 先生がいうには、Mac では PowerShell 使えないっていうじゃないですか。</p>

<p>で、立ち上げましたよ、Windows 10 の VM。<br/>
Mac から Remote Desktop 経由でいじりたかったんでね。</p>

<p>また Surface Pro4 使う機会逃しましたよ。</p>

<p>そしてまた Windows 10 に最初っから入ってる PowerShell じゃ、Azure AD には繋げないんですよ、これが。</p>

<p>いろいろ Google 先生に聞いて出てくるやつかたっぱしから試しても、なんかずっと謎のエラーでつづけてて、あぁ〜、これが MS 流のエラーってやつかぁとか思いながら、最終的にはこれにしたがってエラーなくなりました。</p>

<p><a href="https://technet.microsoft.com/en-ca/library/jj151815.aspx#bkmk_installmodule">Azure Active Directory Cmdlets &ndash; Install the Azure AD Module</a></p>

<p>でもここももう一回ゼロからやり直せって言われたら、またはまる自信ありまくり。</p>

<p>うん、ここもまた解決してない。</p>

<h2>PowerShell 経由で SAML IdP 登録</h2>

<p>これは <a href="http://idmlab.eidentity.jp/2014/12/office365azureadopenamid.html">Office365/AzureAD &ndash; OpenAMとのID連携 (2)</a> にしたがって <code>Set-MsolDomainAuthentication</code> っての走らせたらすんなり完了。</p>

<h2>Federated Domain は Primary にできない制約</h2>

<p>しらんかったよ、Federated Domain は Primary にできないなんて。</p>

<p>MS さん、<code>Failed to change primary domain.</code> しか言ってくれないしさ。</p>

<p>Primary Domain にできないと、そのドメインのメアド持ったユーザー作れないじゃないですか。</p>

<p>SAML IdP 登録したのに Federation できないじゃないですか。</p>

<p>なんか無駄に DNS 設定変えてみたりして、DNS 浸透待ちしまくったよ。</p>

<p>結果、Google 先生に「Federated Domain は Primary にできない」って教えられたよ。</p>

<h2>User の Immutable ID 61文字までしか入れられない制約</h2>

<p>Federated Domain は Primary にできないんで、Azure AD 管理画面からは Federated Domain のユーザーを追加できないんですね。(いや、別にできてもいいとおもうねんけど、なんかそういう制約があるんです)</p>

<p>つまり、ここでも PowerShell 必要なんですよ。</p>

<p>そして、Google 先生に導かれたのがこの PowerShell コマンドです。</p>

<p><a href="https://technet.microsoft.com/en-ca/library/dn194096">New-MsolUser</a></p>

<p>でもまた謎のエラーで、しばらく経ってからやり直せとか言われる。</p>

<p>どんだけまっても同じエラーで、これはしばらく経ってもラチあかねんんじゃね？ってなって&hellip;</p>

<p>結果、Google 先生に「<a href="https://www.gittprogram.com/question/80283_new-msoluser-immutableid-max-length-error.html">Immutable ID には61文字までしか入れられない</a>」って教えられたよ。</p>

<p>こっちは64文字だよ&hellip;</p>

<p>うん、とりあえず SHA1 取った。</p>

<p>解決&hellip;なのか？w</p>

<h2>SAML Request スカスカやのに SAML Response への制約は多い</h2>

<p>SAML Response に関する制約はこちらにまとまってる通りで、それはまぁ SAML IdP 自作できてればそんな対応大変じゃないんですけども&hellip;</p>

<p><a href="https://msdn.microsoft.com/ja-jp/library/azure/dn641269.aspx">シングル サインオンを実装するための SAML 2.0 ID プロバイダーの使用</a></p>

<p>SAML Request スカスカなくせに Response に対する制約多くないすか？</p>

<p>SAML Request に <code>ProtocolBinding</code> とかつけてくれないんすか？ <code>AssertionConsumerServiceURL</code> は？</p>

<p>まぁその辺 OAuth でも省略しても動いたりすることありますけど、そこ省略するとライブラリとかが大変ですよね。</p>

<p>いや、ライブラリそんなないし、O365 対応できないライブラリなんてニーズないんでしょうから、別にいいんですけどね。</p>

<p>でもまぁ、その辺って、センスですよね。</p>

<h2>おわりに</h2>

<p>と、まぁなんだかんだあったけども、無事 O365 にログインできました！</p>

<p>大人の階段のぼってるわぁ〜</p>

<p>プロ千代なってまうわぁ〜</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth Revocation と JWK を翻訳しました]]></title>
    <link href="http://oauthjp.github.io/blog/2016/07/01/jwk-and-oauth-revocation-translated/"/>
    <updated>2016-07-01T10:14:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/07/01/jwk-and-oauth-revocation-translated</id>
    <content type="html"><![CDATA[<p>どうも、この度 OpenID Foundation Japan の事務局長になった Nov です。</p>

<p>事務局長就任のご挨拶的なポエムを書けというオーラをふつふつと感じながら、ガン無視してこの記事を書いております。</p>

<p>さて、みなさん覚えておられるでしょうか？</p>

<p><a href="http://openid-foundation-japan.github.io">OpenID Foundation Japan 翻訳 Working Group</a> のことを。</p>

<p>僕が OpenID のエバンジェリストになる前からリーダーをしており、古くは 2010 年に今は亡き OpenID 2.0 の仕様を翻訳していた、あの伝説の WG を。</p>

<p><strong>その伝説の WG が、2年超の休眠期間を終えて、ついに復活します！</strong></p>

<p>復活第一弾は、OAuth Revocation と JWK！</p>

<ul>
<li><a href="http://openid-foundation-japan.github.io/rfc7009.ja.html">OAuth 2.0 Token Revocation &ndash; RFC 7009</a></li>
<li><a href="http://openid-foundation-japan.github.io/rfc7517.ja.html">JSON Web Key (JWK) &ndash; RFC 7517</a></li>
</ul>


<p>え、この2つにどういう関連性があるのかって？</p>

<p>特にないです！</p>

<p>JWK 翻訳しようとしたら、途中まで翻訳されて休眠してた OAuth Revocation の存在を思い出しただけです！</p>

<!-- more -->


<h2>OAuth Revocation</h2>

<p>OAuth Revocation は、必要なくなったけどまだ有効期限が残っている Access Token や Refresh Token を、OAuth Client が OAuth Server に「もういらないよ」って伝えて、OAuth Server 側で Token の無効化を行う仕様です。</p>

<p>これはまぁ、これだけ実装しても Client が通知してくれなけりゃあまり意味がないので、Client にちゃんと通知させることができるようなガバナンスとセットで意味をなす仕様です。<br/>
サポートしたい OAuth Server の中の人は、ガバナンスもがんばってください。</p>

<h2>JSON Web Key (JWK)</h2>

<p>JWK は、OpenID Connect の ID Token の署名検証用の鍵を公開する場合によく使われる、JSON Format の鍵表現仕様です。</p>

<p>たとえば Google なんかでは、<a href="http://accounts.google.com/.well-known/openid-configuration">OpenID Provider Config Endpoint</a> にアクセスすると、<code>jwks_uri</code> っていう URL が返されて、その <code>jwks_uri</code> にアクセスすると (2016.07.01 時点では) 以下のような JSON が返ってきます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="nt">&quot;keys&quot;</span><span class="p">:</span> <span class="p">[{</span>
</span><span class='line'>    <span class="nt">&quot;kty&quot;</span><span class="p">:</span> <span class="s2">&quot;RSA&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;alg&quot;</span><span class="p">:</span> <span class="s2">&quot;RS256&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;use&quot;</span><span class="p">:</span> <span class="s2">&quot;sig&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;kid&quot;</span><span class="p">:</span> <span class="s2">&quot;73d4e5a3ccd130498bdb8c47fa025464505264ff&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;n&quot;</span><span class="p">:</span> <span class="s2">&quot;yvWe5x68Dc7OV9E7v-wN6li4ChMbZM1DmIZg1C2Ei-78Mqrfl8x3tZMee-ukykEUBcYQicgBRTo8TfKjAerbSKQ8K7ZKDgzPBEGRmYI9UYpZkCwOzhJ-UYU0QB3HcbF1c0l8sZxWTbzNQkiAmEesHH7klqZWScNou2KQEZR9Cs8zHH4clFqbVp8_jVb6xXuVMkpcDGodBjPvmDHA7BI7suirtiGdAnBtZ_cAX8m6MlX3WknNQ4tr88L-XZhTu8pQi0l-uQgsnTNR0k1XWVzmhCs2ftn1kF-UC8ipnei2va0WmX4EMZ-_6rbWRunio1hr9siOFVFdwQw9m34RXiE_Ow&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;e&quot;</span><span class="p">:</span> <span class="s2">&quot;AQAB&quot;</span>
</span><span class='line'>  <span class="p">},</span> <span class="p">{</span>
</span><span class='line'>    <span class="nt">&quot;kty&quot;</span><span class="p">:</span> <span class="s2">&quot;RSA&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;alg&quot;</span><span class="p">:</span> <span class="s2">&quot;RS256&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;use&quot;</span><span class="p">:</span> <span class="s2">&quot;sig&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;kid&quot;</span><span class="p">:</span> <span class="s2">&quot;5c20e39d07fff8a69a0b134fe90bf965c8ea458e&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;n&quot;</span><span class="p">:</span> <span class="s2">&quot;r0DVakOHSFsC6x4IEGtqxERP1YJaP-tycQL5b3cpmnxvjfckHZ9pnql0TPaMHKEdjHlr68MBWatgikGLg1l8injeez_fBOk7BDGyjKezxQAY3qDiGD79CD4EuSobOhYZOiSmtRZDRSrULLtcEksOkWvoBi3aRwVPFipdOOTZvP8TRE3erp-TEtVcaACt3_rWKaW7LTA3RLsFzArVDL_tzsGMuACvz0Uab73cUSjYSS6ErJKIQ-cHqsBRhQf1aYvXxu0Jw8TxrRFwbFRgaDlt9NWptMkTAuClzs_ChXlk3K4I6m2fTaNnNgdk0I5sJel-OebertIM91SlnbGzpRSsfw&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;e&quot;</span><span class="p">:</span> <span class="s2">&quot;AQAB&quot;</span>
</span><span class='line'>  <span class="p">},</span> <span class="p">{</span>
</span><span class='line'>    <span class="nt">&quot;kty&quot;</span><span class="p">:</span> <span class="s2">&quot;RSA&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;alg&quot;</span><span class="p">:</span> <span class="s2">&quot;RS256&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;use&quot;</span><span class="p">:</span> <span class="s2">&quot;sig&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;kid&quot;</span><span class="p">:</span> <span class="s2">&quot;70f6c4267925b33136a1d1cfee4ebc57b249e5cb&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;n&quot;</span><span class="p">:</span> <span class="s2">&quot;qjpXf8YUP22n4Z5DY-YBb8ksxT0YsPDPaCfNtFyXwyE4zInlnw4dSiUud6y0WjPZaVhhVuV_jjgnOgh16lKgaJVYSEaaZDiukI02n5kZ02ZTCkqU27bafL7zBzMBssLliKgnaLFaNH8JBh0mj3suTWp0aB3hMouj1IkkdUB_MCfc6I56tyOwon5JK3vGrYk9vZ--cjTSllN9NYJcWfcUyGoI7RgNz9gvBIznD24NQR1cxmArkusaqmQj6AbARixklSiMpT1qIp0IG-L6wqFi6FHlcbUZnDxCZJVWHfCB9Gfdoox3lgBbdzAebFDomIgxpHwhxsA-iRhYyrjUlSrRiQ&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;e&quot;</span><span class="p">:</span> <span class="s2">&quot;AQAB&quot;</span>
</span><span class='line'>  <span class="p">}]</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>これは JWK 仕様に定められた JSON Web Key Set (JWK Set) というもので、<code>keys</code> という JSON Array の中に含まれている一つ一つの JSON Object が JSON Web Key (JWK) です。</p>

<p>OpenID Connect の場合は RSA 鍵を使うことが多いですが、EC 鍵も Shared Secret も JWK で表現できます。</p>

<p>ACME や WebCrypto など、OpenID Connect 以外の仕様でも、JWK 表現された鍵を見かけることが増えてきたので、今回翻訳することにしました。</p>

<p>実は各暗号アルゴリズムごとに必要な JSON メンバの定義などは JSON Web Algorithm という別仕様にまとめられているので、そちらもいつか翻訳しなきゃなとは思っています。</p>

<p>あと JWK の識別子 (<code>kid</code>) として利用されることがおおい JWK Thumbprint という仕様も、そのうち翻訳しようと思っています。</p>

<p>ということで、今後も <a href="http://openid-foundation-japan.github.io">OIDF-J 翻訳 WG</a> の活動をお楽しみに！</p>

<p>[追記]</p>

<p>JWK Thumbprint も翻訳しました。</p>

<ul>
<li><a href="http://openid-foundation-japan.github.io/rfc7638.ja.html">JSON Web Key (JWK) Thumbprint &ndash; RFC 7638</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Office 365 SAML implementation vulnerability]]></title>
    <link href="http://oauthjp.github.io/blog/2016/05/14/office-365-saml-implementation-vulnerability/"/>
    <updated>2016-05-14T10:32:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/05/14/office-365-saml-implementation-vulnerability</id>
    <content type="html"><![CDATA[<p>先日 Office 365 のこんな記事見つけたので、一応まとめておきますかね。</p>

<p><a href="http://www.economyofmechanism.com/office365-authbypass.html">The road to hell is paved with SAML Assertions</a></p>

<p>タイトルだけ見るとまた SAML is DEAD 案件かと思いきや、Office 365 の脆弱性の話です。</p>

<p>SAML 悪く無いです。</p>

<p>SAML isn&rsquo;t vulnerable, just DEAD.</p>

<h2>SAML SP としての Office 365</h2>

<p>Office 365 は SAML Service Provider (SP) として動作するので、みなさんがお持ちの Identity Provider (IdP) を SAML IdP として動作することができれば、みなさんの IdP に登録されてるアカウントを使って Office 365 にログインすることができます。</p>

<p>みなさんの社内の ADFS とか、Ping Federate / Okta / OneLogin &hellip; みたいな IDaaS とか、そういうのは大抵 SAML IdP として動作するので、そういう製品を使ってるなら、みなさんの会社のアカウントでそのまま Office 365 にログインできます。</p>

<p>通常 SAML SP は、IdP から返ってくる SAML Response に含まれる IdP 側のユーザー識別子 (Subject Identifier) と IdP 自身の識別子 (Issuer Identifier) のペアを元に、SP 側のアカウントにログインさせます。</p>

<p>がしかし、Office 365 の場合は、IdP が渡してくる Email アドレスと Office 365 がローカルで持ってる Email アドレスの一致だけを見て Office 365 ローカルのユーザーを認証していたようです。Subject Identifier も Issuer Identifier も無視していた、と。</p>

<p>(実際には、SAML IdP と Office 365 の間に Azure AD が介在しており、SAML Assertion の検証は Azure ADがやるようなアーキテクチャになっていて、Azure AD では Subject Identifier &amp; Issuer Identifier をちゃんと見ているようですが、全体として見ると Office 365 が SAML IdP の Issuer と Subject をガン無視した形になってます。この辺の話しだすとややこしい割に MS 以外の人にはあまり関係無い話になっちゃうので、今回はスルー)</p>

<h2>Office 365 の脆弱性概要</h2>

<p>これで何が起こっていたかというと、<code>nov@victim.example.com</code> という Email アドレスを持つ Office 365 ユーザーのアカウントにログインする際に、<code>attacker.example.com</code> という IdP が <code>nov@victim.example.com</code> という Email アドレスを含んだ SAML Assertion を発行すると、Office 365 がその Assertion を受け入れて <code>nov@victim.example.com</code> の Office 365 アカウントへのログインを許可してしまっていました。</p>

<p>よって、以下の2つのパターンが、どちらも同じ Office 365 アカウントにログイン可能になっていました。</p>

<table>
<thead>
<tr>
<th></th>
<th> Issuer Identifier    </th>
<th> Subject Identifier  </th>
<th> Email Address          </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> attacker.example.com </td>
<td> 58df3c9b2c32ca86f.. </td>
<td> <code>nov@victim.example.com</code></td>
</tr>
<tr>
<td></td>
<td> victim.example.com   </td>
<td> 20166f0c077c1f6c1.. </td>
<td> <code>nov@victim.example.com</code></td>
</tr>
</tbody>
</table>


<p>うん、これは最悪ですね。</p>

<!-- more -->


<h2>Consumer の世界に置き換えると、つまりどういうこと？</h2>

<p>Consumer 分野であれば、Facebook と Google の両方を IdP として使う RP がいる場合、Facebook が返すユーザーの Email アドレスが Gmail だったりすることは普通にあります。</p>

<p>この時、Facebook が <code>nov@gmail.com</code> というメアドを返してきた場合に、RP 側で <code>nov@gmail.com</code> というメアドを持つユーザーを、たとえそのアカウントが Facebook アカウントと紐付いていない状況だったとしても認証してしまう、と、Office 365 がやっていたのは、そういう処理です。</p>

<p>Facebook と Google だけが IdP であれば、どちらも Email 疎通確認等をちゃんとしているという前提があるため、以下の2つの Identity は同一人物に紐づくという前提で設計することもできるでしょう。</p>

<table>
<thead>
<tr>
<th></th>
<th> Issuer  Identifier </th>
<th> Subject Identifier  </th>
<th> Email Address   </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> google.com         </td>
<td> 58df3c9b2c32ca86f.. </td>
<td> <code>nov@gmail.com</code></td>
</tr>
<tr>
<td></td>
<td> facebook.com       </td>
<td> 58df3c9b2c32ca86f.. </td>
<td> <code>nov@gmail.com</code></td>
</tr>
</tbody>
</table>


<p>しかし、OpenID 2.0 の頃のように、ユーザーが Dynamic に任意の IdP を選択できるとしたらどうでしょう？</p>

<p>以下の3つめのアカウントが、その上の2つと同一人物に紐づくという前提条件は、あっさり崩れてしまいます。</p>

<table>
<thead>
<tr>
<th></th>
<th> Issuer Identifier    </th>
<th> Subject Identifier  </th>
<th> Email Address   </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> google.com           </td>
<td> 58df3c9b2c32ca86f.. </td>
<td> <code>nov@gmail.com</code></td>
</tr>
<tr>
<td></td>
<td> facebook.com         </td>
<td> 58df3c9b2c32ca86f.. </td>
<td> <code>nov@gmail.com</code></td>
</tr>
<tr>
<td></td>
<td> attacker.example.com </td>
<td> 58df3c9b2c32ca86f.. </td>
<td> <code>nov@gmail.com</code></td>
</tr>
</tbody>
</table>


<p>Office 365 の場合、テナントごとに任意の IdP を指定することができるため、攻撃者が Office 365 にテナント登録してしまいさえすれば、<code>attacker.example.com</code> を IdP として登録できてしまい、上記の3つめのパターンを作り出すことができてしまいます。</p>

<p>そして、OpenID Connect でも「OAuth 認証」でも、同じような脆弱性は発生しそうですね。</p>

<p>SAMLer 以外のみなさんも、気をつけないとですね。</p>

<h2>こういう場合、どうすればいいの？</h2>

<p>まずは基本的には、以下3つのパターンが RP 側では全て異なるアカウントに紐づくように設計することです。</p>

<p>つまり、Subject Identifier と Issuer Identifier のペアごとに、異なるアカウントに紐づくようにする、と。</p>

<table>
<thead>
<tr>
<th></th>
<th> Issuer Identifier    </th>
<th> Subject Identifier  </th>
<th> Email Address   </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> google.com           </td>
<td> 58df3c9b2c32ca86f.. </td>
<td> <code>nov@gmail.com</code></td>
</tr>
<tr>
<td></td>
<td> facebook.com         </td>
<td> 58df3c9b2c32ca86f.. </td>
<td> <code>nov@gmail.com</code></td>
</tr>
<tr>
<td></td>
<td> attacker.example.com </td>
<td> 58df3c9b2c32ca86f.. </td>
<td> <code>nov@gmail.com</code></td>
</tr>
</tbody>
</table>


<p>その上で、RP 側で Email アドレスがユニークである必要があるのであれば、3つのアカウントを RP 側で一つのアカウントに紐付けるためのフローを RP が頑張って実装するか、IdP から渡される Email アドレスを無視して別の Email アドレスを設定させる等の処理が必要です。</p>

<p>そのあたりの細かい実装方法については&hellip; <a href="http://yauth.jp">YAuth.jp</a> に相談？w</p>

<h2>Office 365 はどういう修正をしたのか？</h2>

<p>これは、元記事にも書いて無いですね。</p>

<p>でも7時間で修正されたって書いてあるので、上記のような解決策ではなくて、以下の1つめのパターンを reject するようにしたのでしょう。</p>

<table>
<thead>
<tr>
<th></th>
<th> Issuer Identifier    </th>
<th> Subject Identifier  </th>
<th> Email Address          </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> attacker.example.com </td>
<td> 58df3c9b2c32ca86f.. </td>
<td> <code>nov@victim.example.com</code></td>
</tr>
<tr>
<td></td>
<td> victim.example.com   </td>
<td> 58df3c9b2c32ca86f.. </td>
<td> <code>nov@victim.example.com</code></td>
</tr>
</tbody>
</table>


<p>要するに Issuer チェックをするようにしたんでしょうが、SAML IdP と Office 365 の間に Azure AD がいるっていう状態で、具体的にどの箇所でどういう検証をするようにしたのかってのは、よくわからず。</p>

<p>Office 365 の MVP の人とかに聞くとわかるんですかね、こういうのは？</p>

<p>ps.
本記事執筆にあたっては、<a href="http://idmlab.eidentity.jp">腹違いの兄さんことふぁらおう兄さん</a>に長時間にわたって相談に乗っていただきました。にいさん、いつもありがとうございます！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth / Connect における CSRF Attack の新パターン]]></title>
    <link href="http://oauthjp.github.io/blog/2016/05/06/another-csrf-attack/"/>
    <updated>2016-05-06T14:19:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/05/06/another-csrf-attack</id>
    <content type="html"><![CDATA[<p>昨日こんなのが OAuth ML に流れてました。</p>

<p><a href="https://mailarchive.ietf.org/arch/search/?email_list=oauth&amp;gbt=1&amp;index=G4J3H1BMyIN01FCOLKqLjrx7AZ4">[OAUTH-WG] Another CSRF attack</a></p>

<h2>前提条件</h2>

<p>RP (Relying Party a.k.a. OAuth Client) が2つ以上の IdP (Identity Provider a.k.a. OAuth Server) と連携している状況で、片方の IdP に悪意がある。</p>

<ul>
<li>悪意ある IdP = AIdP (A は Attacker の略)</li>
<li>その他の IdP = HIdP (H は Honest の略)</li>
</ul>


<h2>攻撃フロー</h2>

<p><img src="https://www.websequencediagrams.com/cgi-bin/cdraw?lz=YWx0IFZpY3RpbSdzIFNlc3Npb24KICAgAA4HLT5SUDogTG9naW4gdy8gQUlkUAAZBVJQLT4AMQY6ACENQUlkUDogQXV0aFogUmVxIHcvIHN0YXRlLVYAUAVBSWQALwoAIgVlbnRpY2F0ZQA0EgAmC0gAUAZ0dGFja2VyJ3MgY3JlZGVudGlhbHMAgSgFSABTBQB3BmNvZABIBgBfDkhJZFAncwAZBQCBCwsgKHRvIHJlZGlyZWN0X3VyaSBmb3IASgUpAIF2EACBbwlSUDoANglpcyB0aWVkIHRvIHRoZSBzAII7BiwgT0shAIIfCQCBOAYAgQ4JAIEmBlIAgUMOYWNjZXNzX3Rva2VuICYgaWQABQYAglwQIEhlbGxvLCB3aGF0J3MgeW91ciBuYW1lPwCDIhFJJ20Ag1EHCmVsc2UAgjEMAINaDACCTAgAg0wcAIJwCACDCwcAKQkAgw8HAINaEkEAgwgMADUIAINcEgA7DwAgFQCDIQ4AUwYAgScNAIMDE0EAgi1pAIFTCldlbGNvbWUgYmFjaywAhkoHIQplbmQK&amp;s=earth" alt="Another CSRF Attack" /></p>

<ol>
<li>Victim が AIdP を使って RP へのログインを試みる。</li>
<li>RP は Authorization Request を AIdP に送る。

<ul>
<li>AuthZ Req には Browser Session と紐付いた <code>state</code> パラメータをつけている。</li>
</ul>
</li>
<li>AIdP は Victim を認証し、必要に応じて同意を取得する (ふりをする)

<ul>
<li>同時に AIdP は裏で HIdP から <code>code</code> を取得する。</li>
<li>HIdP の code は Attacker の HIdP 上のアカウントに紐付いているもの。</li>
</ul>
</li>
<li>AIdP は HIdP から取得した <code>code</code> を、RP の HIdP 用 <code>redirect_uri</code> に返す。

<ul>
<li>この時 Step2 で RP が発行した <code>state</code> を付与する。</li>
</ul>
</li>
<li>RP は Browser Session と紐付いた <code>state</code> を検証した上で <code>code</code> を HIdP の Token Endpoint に送る。</li>
<li>HIdP は Attacker のアカウントに紐付いた <code>access_token</code> を返す。</li>
<li>RP は Victim をログインさせる。

<ul>
<li>ここで HIdP 上の Attacker アカウントと RP 上の Victim アカウントが紐づけられる。</li>
</ul>
</li>
</ol>


<p>そして、Attacker は任意のタイミングで自身の HIdP 上のアカウントを使って、RP 上の Victim のアカウントにログインできる。</p>

<h2>防御策</h2>

<p><code>state</code> をリクエスト先の IdP とも紐づけましょう。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FB Message API Callback as an Azure Function]]></title>
    <link href="http://oauthjp.github.io/blog/2016/04/19/fb-message-callback-with-azure-function/"/>
    <updated>2016-04-19T10:56:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/04/19/fb-message-callback-with-azure-function</id>
    <content type="html"><![CDATA[<p>今日は Azure Function で FB Message API Callback を作ってみます。</p>

<p>Azure Function は、Azure Portal の Marketplace で &ldquo;Function App&rdquo; って検索すると出てきますね。</p>

<p><img src="http://oauthjp.github.io/images/posts/azure/azure-function-in-marketplace.png" alt="Azure Function in Marketplace" /></p>

<p>Function App の Deploy がおわったら、QuickStart から &ldquo;Webhook + API&rdquo; を選びましょう。</p>

<p><img src="http://oauthjp.github.io/images/posts/azure/azure-function-quickstart.png" alt="Azure Function QuickStart" /></p>

<p>以下の様な Node.js のテンプレートアプリが出来上がります。</p>

<p><img src="http://oauthjp.github.io/images/posts/azure/azure-function-template.png" alt="Azure Function Template" /></p>

<p>まずは FB Message の WebHook としてこの Function を登録します。</p>

<!-- more -->


<p>Azure Function の <code>Function URL</code> を FB Message API の <code>WebHook Callback URL</code> に登録して、適当な <code>verify_token</code> を設定します。</p>

<p><img src="http://oauthjp.github.io/images/posts/azure/fb-message-callback.png" alt="FB Message API Callback (FB WebHook)" /></p>

<p>WebHook Verification のために、テンプレの Azure Function を以下の様に書き換えます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">[</span><span class="s1">&#39;hub.verify_token&#39;</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;verify-me&#39;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">context</span><span class="p">.</span><span class="nx">res</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">body</span><span class="o">:</span> <span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">[</span><span class="s1">&#39;hub.challenge&#39;</span><span class="p">]</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nx">context</span><span class="p">.</span><span class="nx">done</span><span class="p">();</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>これで FB 側の <code>Verify and Save</code> ボタンを押せば、WebHook の Verifycation が成功して WebHook の登録が完了します。</p>

<p>では次に、Text Message を Echo するように Azure Function を書き換えましょう。</p>

<p>まずは FB Graph API の Messaging API を叩くために必要な FB Page Token を、Azure Function の <code>Application Setting &gt; App Setting</code> に設定しておきます。</p>

<p>この時に使う FB Page Token は、先ほど WebHook を登録したページ (FB Messenger API の設定ページ) で取得したものを使う様にしてください。そこで取得した FB Page Token は Expire しません。</p>

<p><img src="http://oauthjp.github.io/images/posts/azure/azure-function-env.png" alt="Azure Function Env" /></p>

<p>あとは Azure Function 側を以下の様に書き換えてやれば OK です。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">https</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;https&#39;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">sendTextMessage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">sender</span><span class="p">,</span> <span class="nx">text</span><span class="p">,</span> <span class="nx">context</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">postData</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
</span><span class='line'>    <span class="nx">recipient</span><span class="o">:</span> <span class="nx">sender</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">message</span><span class="o">:</span> <span class="p">{</span><span class="nx">text</span><span class="o">:</span> <span class="nx">text</span><span class="p">}</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">req</span> <span class="o">=</span> <span class="nx">https</span><span class="p">.</span><span class="nx">request</span><span class="p">({</span>
</span><span class='line'>    <span class="nx">hostname</span><span class="o">:</span> <span class="s1">&#39;graph.facebook.com&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">port</span><span class="o">:</span> <span class="mi">443</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/v2.6/me/messages&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">method</span><span class="o">:</span> <span class="s1">&#39;POST&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">headers</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>      <span class="s1">&#39;Content-Type&#39;</span><span class="o">:</span> <span class="s1">&#39;application/json&#39;</span><span class="p">,</span>
</span><span class='line'>      <span class="s1">&#39;Authorization&#39;</span><span class="o">:</span> <span class="s1">&#39;Bearer &#39;</span> <span class="o">+</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">APPSETTING_FB_PAGE_TOKEN</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="nx">req</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">postData</span><span class="p">);</span>
</span><span class='line'>  <span class="nx">req</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">messaging_evts</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">messaging</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">messaging_evts</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">evt</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">messaging</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span><span class='line'>    <span class="nx">sender</span> <span class="o">=</span> <span class="nx">evt</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">evt</span><span class="p">.</span><span class="nx">message</span> <span class="o">&amp;&amp;</span> <span class="nx">evt</span><span class="p">.</span><span class="nx">message</span><span class="p">.</span><span class="nx">text</span><span class="p">,</span> <span class="nx">context</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">sendTextMessage</span><span class="p">(</span><span class="nx">sender</span><span class="p">,</span> <span class="nx">evt</span><span class="p">.</span><span class="nx">message</span><span class="p">.</span><span class="nx">text</span><span class="p">,</span> <span class="nx">context</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nx">context</span><span class="p">.</span><span class="nx">done</span><span class="p">();</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>早速該当 FB Page にメッセージを送ってみましょう。Echo が返ってくると思います。</p>

<p>さてと、YAuth.jp の問い合わせ対応 Bot を作ってみるかな。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Windows Server 2016 版 ADFS を触ってみた]]></title>
    <link href="http://oauthjp.github.io/blog/2016/04/17/oidc-on-adfs-2016/"/>
    <updated>2016-04-17T19:38:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/04/17/oidc-on-adfs-2016</id>
    <content type="html"><![CDATA[<p>MVP になったことですし、早速 Azure 常に Windows Server 2016 の VM 立ち上げて、次期バージョンの ADFS を動かしてみました。</p>

<p>想定ユースケースは、Native App とその Backend Server があって、Backend Server が Native App 向けに提供している API 用の Access Token も、ADFS が発行するというものです。</p>

<p>まさしく今後エンプラで増えていくであろうパターンですね。</p>

<h2>Setup Hybrid Client on ADFS</h2>

<p>ADFS Manager に &ldquo;Application Groups&rdquo; っていう設定が増えてるんで、そこから &ldquo;Native Application and Web API&rdquo; ってのを選択して、Connect RP (= OAuth Client) を登録します。</p>

<p><img src="http://oauthjp.github.io/images/posts/adfs/hybrid-client-new.png" alt="New Hybrid Client" /></p>

<p>スクショいっぱい撮るのが面倒なのですっ飛ばしますが、こんな感じで Native App とその Backend Server を ADFS に &ldquo;Application Group&rdquo; として登録しました。</p>

<p><img src="http://oauthjp.github.io/images/posts/adfs/hybrid-client.png" alt="Registered Hybrid Client" /></p>

<p>ちなみに、この時 Backend には特に Native App と別の client_id が発行されたりはしません。</p>

<p>ここまでで、ADFS 側の準備は完了です。以降、<a href="https://gist.github.com/nov/3f284aa8cec5ed6bc332e9a5c9d93851">こちらの gist</a> に沿って、Step by Step で見ていきます。</p>

<!-- more -->


<h2>GET /.well-known/openid-configuration</h2>

<p>まずは ADFS の OpenID Configuration を取得しましょう。</p>

<p>あいにく ADFS の Webfinger は<a href="https://gist.github.com/nov/577c25a1ece53bc97d962d5e74c06496">まともに動いてる気配がしない</a>ので、issuer は <code>https://&lt;your-adfs-domain&gt;/adfs</code> をハードコードします。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">config</span> <span class="o">=</span> <span class="ss">OpenIDConnect</span><span class="p">:</span><span class="ss">:Discovery</span><span class="o">::</span><span class="ss">Provider</span><span class="p">:</span><span class="ss">:Config</span><span class="o">.</span><span class="n">discover!</span><span class="p">(</span>
</span><span class='line'>  <span class="s1">&#39;https://sts.example.com/adfs&#39;</span>
</span><span class='line'><span class="p">)</span> <span class="c1"># GET https://sts.example.com/adfs/.well-known/openid-configuration</span>
</span></code></pre></td></tr></table></div></figure>


<p>すると、こんな JSON が返ってきます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="nt">&quot;issuer&quot;</span><span class="p">:</span> <span class="s2">&quot;https://sts.example.com/adfs&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;authorization_endpoint&quot;</span><span class="p">:</span> <span class="s2">&quot;https://sts.example.com/adfs/oauth2/authorize/&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;token_endpoint&quot;</span><span class="p">:</span> <span class="s2">&quot;https://sts.example.com/adfs/oauth2/token/&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;jwks_uri&quot;</span><span class="p">:</span> <span class="s2">&quot;https://sts.example.com/adfs/discovery/keys&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;token_endpoint_auth_methods_supported&quot;</span><span class="p">:</span> <span class="p">[</span>
</span><span class='line'>    <span class="s2">&quot;client_secret_post&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;client_secret_basic&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;private_key_jwt&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;windows_client_authentication&quot;</span>
</span><span class='line'>  <span class="p">],</span>
</span><span class='line'>  <span class="nt">&quot;response_types_supported&quot;</span><span class="p">:</span> <span class="p">[</span>
</span><span class='line'>    <span class="s2">&quot;code&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;id_token&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;code id_token&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;token id_token&quot;</span>
</span><span class='line'>  <span class="p">],</span>
</span><span class='line'>  <span class="nt">&quot;response_modes_supported&quot;</span><span class="p">:</span> <span class="p">[</span>
</span><span class='line'>    <span class="s2">&quot;query&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;fragment&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;form_post&quot;</span>
</span><span class='line'>  <span class="p">],</span>
</span><span class='line'>  <span class="nt">&quot;grant_types_supported&quot;</span><span class="p">:</span> <span class="p">[</span>
</span><span class='line'>    <span class="s2">&quot;authorization_code&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;refresh_token&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;client_credentials&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;urn:ietf:params:oauth:grant-type:jwt-bearer&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;implicit&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;password&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;srv_challenge&quot;</span>
</span><span class='line'>  <span class="p">],</span>
</span><span class='line'>  <span class="nt">&quot;subject_types_supported&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;pairwise&quot;</span><span class="p">],</span>
</span><span class='line'>  <span class="nt">&quot;scopes_supported&quot;</span><span class="p">:</span> <span class="p">[</span>
</span><span class='line'>    <span class="s2">&quot;aza&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;vpn_cert&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;user_impersonation&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;openid&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;profile&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;admin-only&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;email&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;logon_cert&quot;</span>
</span><span class='line'>  <span class="p">],</span>
</span><span class='line'>  <span class="nt">&quot;id_token_signing_alg_values_supported&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;RS256&quot;</span><span class="p">],</span>
</span><span class='line'>  <span class="nt">&quot;token_endpoint_auth_signing_alg_values_supported&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;RS256&quot;</span><span class="p">],</span>
</span><span class='line'>  <span class="nt">&quot;access_token_issuer&quot;</span><span class="p">:</span> <span class="s2">&quot;http://sts.example.com/adfs/services/trust&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;claims_supported&quot;</span><span class="p">:</span> <span class="p">[</span>
</span><span class='line'>    <span class="s2">&quot;aud&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;iss&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;iat&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;exp&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;auth_time&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;nonce&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;at_hash&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;c_hash&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;sub&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;upn&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;unique_name&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;pwd_url&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;pwd_exp&quot;</span>
</span><span class='line'>  <span class="p">],</span>
</span><span class='line'>  <span class="nt">&quot;microsoft_multi_refresh_token&quot;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;userinfo_endpoint&quot;</span><span class="p">:</span> <span class="s2">&quot;https://sts.example.com/adfs/userinfo&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>response_types_supported</code> 見る限り、<code>code token</code> とか <code>code token id_token</code> はサポートされてないですね。なんででしょうね？</p>

<p>まぁ、気にせず進みましょう。</p>

<h2>GET /oauth2/authorize</h2>

<p>取得した OP Config をもとに、Authorization Request を発行します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">client</span> <span class="o">=</span> <span class="ss">OpenIDConnect</span><span class="p">:</span><span class="ss">:Client</span><span class="o">.</span><span class="n">new</span><span class="p">(</span>
</span><span class='line'>  <span class="ss">identifier</span><span class="p">:</span> <span class="s1">&#39;2940bc16-983c-41ca-b373-4c6045278627&#39;</span><span class="p">,</span> <span class="c1"># Native App&#39;s client_id</span>
</span><span class='line'>  <span class="n">redirect_uri</span><span class="p">:</span> <span class="s1">&#39;custom-schema://foobar&#39;</span><span class="p">,</span>
</span><span class='line'>  <span class="n">authorization_endpoint</span><span class="p">:</span> <span class="n">config</span><span class="o">.</span><span class="n">authorization_endpoint</span><span class="p">,</span>
</span><span class='line'>  <span class="n">token_endpoint</span><span class="p">:</span> <span class="n">config</span><span class="o">.</span><span class="n">token_endpoint</span><span class="p">,</span>
</span><span class='line'>  <span class="n">userinfo_endpoint</span><span class="p">:</span> <span class="n">config</span><span class="o">.</span><span class="n">userinfo_endpoint</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">authorization_uri</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">authorization_uri</span><span class="p">(</span>
</span><span class='line'>  <span class="ss">scope</span><span class="p">:</span> <span class="o">[</span><span class="ss">:openid</span><span class="p">,</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:profile</span><span class="o">]</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; https://sts.example.com/adfs/oauth2/authorize/?</span>
</span><span class='line'><span class="c1">#            client_id=2940bc16-983c-41ca-b373-4c6045278627&amp;</span>
</span><span class='line'><span class="c1">#            redirect_uri=custom-schema%3A%2F%2Ffoobar&amp;</span>
</span><span class='line'><span class="c1">#            response_type=code&amp;</span>
</span><span class='line'><span class="c1">#            scope=openid+email+profile</span>
</span></code></pre></td></tr></table></div></figure>


<p>この URL をブラウザで開くと、ADFS のログイン画面が表示されて、ログインしたら特に同意画面とかはなく <code>custom-schema://foobar</code> にリダイレクトして戻ってきます。</p>

<p>リダイレクト URL の Query には code がついてるので、そいつコピーします。</p>

<h2>GET /oauth2/token</h2>

<p>取得した code を使って、Access Token を取得します。</p>

<p>今回は Native App 向けに <code>response_type=code</code> を指定してるので、client_secret なしで Access Token が取得できます。(ID Token も同時に発行されます)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">client</span><span class="o">.</span><span class="n">authorization_code</span> <span class="o">=</span> <span class="n">code</span>
</span><span class='line'><span class="n">token</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">access_token!</span>
</span></code></pre></td></tr></table></div></figure>


<p>取得した Access Token は JWT になっているので、Payload を見てみましょう。<code>aud</code> が <code>urn:microsoft:userinfo</code> になっています。
あと、Authorization Request では <code>openid email profile</code> を指定したはずなのに、ここでは <code>scp</code> (scopes) が <code>openid</code> だけになってますね。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="nt">&quot;aud&quot;</span><span class="p">:</span> <span class="s2">&quot;urn:microsoft:userinfo&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;iss&quot;</span><span class="p">:</span> <span class="s2">&quot;http://sts.example.com/adfs/services/trust&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;iat&quot;</span><span class="p">:</span> <span class="mi">1460887152</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;exp&quot;</span><span class="p">:</span> <span class="mi">1460890752</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;apptype&quot;</span><span class="p">:</span> <span class="s2">&quot;Public&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;appid&quot;</span><span class="p">:</span> <span class="s2">&quot;2940bc16-983c-41ca-b373-4c6045278627&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;authmethod&quot;</span><span class="p">:</span> <span class="s2">&quot;urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;auth_time&quot;</span><span class="p">:</span> <span class="s2">&quot;2016-04-17T09:37:20.197Z&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;ver&quot;</span><span class="p">:</span> <span class="s2">&quot;1.0&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;scp&quot;</span><span class="p">:</span> <span class="s2">&quot;openid&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;sub&quot;</span><span class="p">:</span> <span class="s2">&quot;BsG1N+rcilM2dnBDB7kyha6YglKD3d9qcwbCixQEGlQ=&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>GET /userinfo</h2>

<p>では UserInfo を取得します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">token</span><span class="o">.</span><span class="n">userinfo!</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>email profile</code> の両 scope がどこかにいってしまったので、案の定 <code>sub</code> しか返ってきませんね。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="nt">&quot;sub&quot;</span><span class="p">:</span> <span class="s2">&quot;BsG1N+rcilM2dnBDB7kyha6YglKD3d9qcwbCixQEGlQ=&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>sub</code> だけなら Access Token にも入ってたし、UserInfo Endpoint いらねんじゃね？とか思いますが、まぁ Windows Server 2016 リリース時にはなんか変わってるかもですね。</p>

<h2>GET /oauth2/token (for Backend API)</h2>

<p>さて、ここまでは普通の OpenID Connect / OAuth2 のフローでしたが、いよいよ Native App の Backend API 用の Access Token を取得します。</p>

<p>先ほど Access Token &amp; ID Token を取得した際に、Refresh Token も取得していたので、この Refresh Token を使って <code>resource</code> パラメータに ADFS に登録しておいた Backend API の Identifer を指定します。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">client</span><span class="o">.</span><span class="n">refresh_token</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">refresh_token</span>
</span><span class='line'><span class="n">token2</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">access_token!</span><span class="p">(</span>
</span><span class='line'>  <span class="ss">resource</span><span class="p">:</span> <span class="s1">&#39;http://backend.dev&#39;</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>すると、また JWT-formatted な Access Token が発行されるので、Payload を確認します。</p>

<p><code>aud</code> が <code>http://backend.dev</code> に変わっていますね。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="nt">&quot;aud&quot;</span><span class="p">:</span> <span class="s2">&quot;http://backend.dev&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;iss&quot;</span><span class="p">:</span> <span class="s2">&quot;http://sts.example.com/adfs/services/trust&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;iat&quot;</span><span class="p">:</span> <span class="mi">1460886940</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;exp&quot;</span><span class="p">:</span> <span class="mi">1460890540</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;apptype&quot;</span><span class="p">:</span> <span class="s2">&quot;Public&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;appid&quot;</span><span class="p">:</span> <span class="s2">&quot;2940bc16-983c-41ca-b373-4c6045278627&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;authmethod&quot;</span><span class="p">:</span> <span class="s2">&quot;urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;auth_time&quot;</span><span class="p">:</span> <span class="s2">&quot;2016-04-17T09:37:20.197Z&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;ver&quot;</span><span class="p">:</span> <span class="s2">&quot;1.0&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Backend API Access</h2>

<p>あとは、Backend API 側では <code>iss=http://sts.example.com/adfs/services/trust</code> かつ <code>aud=http://backend.dev</code> な Access Token を受け入れるだけですね。</p>

<p>Backend API 側では、OP Config の <code>jwks_uri</code> から JWT の署名検証用の公開鍵 (JWK-formatted) を取得して、Access Token の署名を検証するのを忘れずに。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="err">//</span> <span class="err">https://sts.example.com/adfs/discovery/keys</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="nt">&quot;keys&quot;</span><span class="p">:</span> <span class="p">[{</span>
</span><span class='line'>    <span class="nt">&quot;kty&quot;</span><span class="p">:</span> <span class="s2">&quot;RSA&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;use&quot;</span><span class="p">:</span> <span class="s2">&quot;sig&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;alg&quot;</span><span class="p">:</span> <span class="s2">&quot;RS256&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;kid&quot;</span><span class="p">:</span> <span class="s2">&quot;B1B8yZ-HAp7g2iz8D6LO3X2gOeI&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;x5t&quot;</span><span class="p">:</span> <span class="s2">&quot;B1B8yZ-HAp7g2iz8D6LO3X2gOeI&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;n&quot;</span><span class="p">:</span> <span class="s2">&quot;1ag4fTO65qrnmUENL4K4ZK8fchrV7BbTNfaHIfwT1nFuIO-4C8lh3VkWykIlUwd0ANWwQsY75Xb5ZC8P67QnXexV8CoXu5jHp2lsHm4Fhq75QEpRql7OpamOKBFqPtWvBneWTZOCnr1SrWR9DjBWnfRhMKr-4Oleaqp--YCIBaIiVaJDx6YqLKmTn5UeFSfcV9LT4y6yjFqgNK2mS6epFnmree9mjVYCyRdCWJRWyrA1xVbSA2xmu6i9z7ZuNaEUFKyL3uTwArzKkipy0aDBSVRsKuhCMV8dFsVBm3EWmyHzsoneT-zGM2aG5EYF7oOUlx2lXafiCDCYQ0YqRRWddQ&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;e&quot;</span><span class="p">:</span> <span class="s2">&quot;AQAB&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;x5c&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;MIIC1jCCAb6gAwIBAgIQFcgeY4EZ65RDuxjfwa+tXDANBgkqhkiG9w0BAQsFADAnMSUwIwYDVQQDExxBREZTIFNpZ25pbmcgLSBzdHMubWF0YWtlLmpwMB4XDTE2MDQxMjExNTU1MloXDTE3MDQxMjExNTU1MlowJzElMCMGA1UEAxMcQURGUyBTaWduaW5nIC0gc3RzLm1hdGFrZS5qcDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANWoOH0zuuaq55lBDS+CuGSvH3Ia1ewW0zX2hyH8E9ZxbiDvuAvJYd1ZFspCJVMHdADVsELGO+V2+WQvD+u0J13sVfAqF7uYx6dpbB5uBYau+UBKUapezqWpjigRaj7VrwZ3lk2Tgp69Uq1kfQ4wVp30YTCq\/uDpXmqqfvmAiAWiIlWiQ8emKiypk5+VHhUn3FfS0+MusoxaoDStpkunqRZ5q3nvZo1WAskXQliUVsqwNcVW0gNsZruovc+2bjWhFBSsi97k8AK8ypIqctGgwUlUbCroQjFfHRbFQZtxFpsh87KJ3k\/sxjNmhuRGBe6DlJcdpV2n4ggwmENGKkUVnXUCAwEAATANBgkqhkiG9w0BAQsFAAOCAQEAK0bCMCgF3hfRnV5zwtO8Wzd5XBMkFVQmipOizv\/Llznn12jpe4mk1fKHqp1EuTtbEFQ93YGs9yaJb3bpU9MsSqKaTbcK269NgG\/v1ke1KcGFjL\/BkxABY5pRWG2U0Rpw1SL16DXoZj0gLT91A8gTikm8wTE8mqKBNarC6runStu8qw08iQqadkbg8zU+o7vLduyZlHTOO1sdXpKOcU1O+wirPz0tMtKfaXznF81LMhWhRxwRNOHqju8Vc5a1gcGG9Sj9lS0LaD+k7ybtiHx4DhiZ0tQP14C+OWPZDH1vtudkf6UpyBasxB4kVuOHDTB7sjPnOTqA4zKiKrHekW2jUg==&quot;</span><span class="p">]</span>
</span><span class='line'>  <span class="p">}]</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>この Backend API 用の scope をどう扱えばいいのかとかは、またそのうち調べて見るかもしれません。</p>

<p>どうせ「同意」とかいう概念がない IdP なんだから、Backend API 用の scope も形骸化しそうな気はするけど。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Microsoft MVP Award を受賞しました]]></title>
    <link href="http://oauthjp.github.io/blog/2016/04/02/microsoft-mvp/"/>
    <updated>2016-04-02T18:02:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/04/02/microsoft-mvp</id>
    <content type="html"><![CDATA[<p>2016年度の Microsoft MVP Award を受賞させていただきました。</p>

<p>これもひとえにあんのパパのおかげです。パパは<a href="https://blogs.technet.microsoft.com/junichia/2016/04/01/%E5%98%98%E3%81%AE%E3%82%88%E3%81%86%E3%81%AA%E6%9C%AA%E6%9D%A5%E3%81%AE%E5%A7%8B%E3%81%BE%E3%82%8A%E3%81%A7%E3%81%99%EF%BC%81/">2007年4月 Microsoft 入社</a>ということなので、僕が新卒になったころからの MS エバンジェリストってことっすよ。</p>

<p>通常であればにいさんと呼びたいところですが、今回新たな MVP も産んだことですし、Identity 業界の慣習にならって積極的にパパ呼ばわりしていきたいとおもいます。</p>

<p>また、<a href="https://mvp.microsoft.com/ja-jp/pages/mvp-award-update">Award のカテゴリー</a>は &ldquo;Microsoft Azure&rdquo; ってなってたので、<a href="http://idmlab.eidentity.jp">ふぁらおぅにぃさん</a>が腹ちがいのにぃさんになった感じですかね、きっと。</p>

<p>どこまで今回の MVP Award のカテゴリーにマッチしてるのかはよくわかってないんですが、僕がいま興味あるエリアは AzureAD &amp; ADFS の Connect サポート、Graph API、Windows 10 の FIDO サポートあたりなんで、その辺りでいろいろ遊びながらこのブログとかで記事書いていければいいなと思います。</p>

<p>もちろんエディタは <a href="https://code.visualstudio.com/">Visual Studio Code</a> で。(まじこいつ起動はえー！Atom より圧倒的に起動はえー！！)</p>

<p>とりあえず Microsoft Edge の FIDO 実装で遊ぶためにも、Surface Pro4 を買わないとですね！</p>

<p>ということで、つい先日 Windows Server 上で新規ファイル作成すらできなくてがく然とした Windows 音痴な僕ですが、今後ともよろしくお願い致しますm<em> </em>m</p>

<p>ps.<br>
新規ファイル作成は、右クリックじゃなく、メモ帳開いて <code>[Ctrl] + [S]</code> な。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[独立 & YAuth.jp 設立]]></title>
    <link href="http://oauthjp.github.io/blog/2016/03/26/yauth-dot-jp-founded/"/>
    <updated>2016-03-26T12:27:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/03/26/yauth-dot-jp-founded</id>
    <content type="html"><![CDATA[<p>昨日を最終出社日として、GREE 正社員生活を終えました。4月からは独り会社作って独立します。</p>

<p>転職じゃなくて独立で、契約形態変えて GREE さんともお仕事する可能性十分あるので、あまり退職っていう実感はないのですが、これもまぁ一応退職エントリー&hellip;ですかね？</p>

<p>新会社での業務内容としては、Identity まわりのコンサルとか技術支援とかをメインでやる予定。</p>

<p>ありがたいことにすでに数件4月以降の仕事依頼もいただいており、気軽に新しい案件受けづらい状況なのですが、もし興味あれば<a href="mailto:nov@yauth.jp">ご連絡いただければ</a>と思います。</p>

<p>ID の専門家として仕事しつづけるとしたら、1社に閉じるより数社の仕事同時にこなす方がいいんじゃないかとか、そういう流動的に動ける人もこの国に数人いたほうがいいんじゃないかとか、そういうのが独立のきっかけとしてあるので、いろんな会社のお話聞いてみたいです。</p>

<!-- more -->


<p>ちなみに、新しく作る会社は <a href="http://yauth.jp">YAuth.jp 合同会社</a> という名前です。「本当にその名前でやるの？」とか言われたりもしましたが、結構響きも好きなんですよ。YAuth.jp、いい名前でしょ？</p>

<p>現在絶賛法人登記手続き中ですが、きっと来週頭には法人番号がもらえるはず！来週中は法務局とか税務署とかいろいろ行く予定！税務署ってどこにあるんすか、いったい！</p>

<p>ということで、今後は OAuth.jp 共々、<a href="http://yauth.jp">YAuth.jp</a> もよろしくお願い致しますm<em> </em>m</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[「OAuth 認証」を定義しよう]]></title>
    <link href="http://oauthjp.github.io/blog/2016/02/25/oauth-authentication/"/>
    <updated>2016-02-25T11:27:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/02/25/oauth-authentication</id>
    <content type="html"><![CDATA[<p>「OAuth 認証」って言葉が出てくると、「認証と認可は違う」とか言い出す人が出てきて、大体の場合「OAuth 認証」言ってた人たちがやりたいことの話とはズレた議論が始まるので、もういっその事「OAuth 認証」とは何かを定義してみましょうかね。</p>

<h2>「OAuth 認証」で Relying Party (RP) がやりたかったこと</h2>

<p>RP (OAuth Client) は、ブラウザの前にいる人を、認証したかったんですよね？</p>

<p>もう少し正確にいうと、ブラウザの前にいる Entity が、RP 側で把握しているどの Identity と紐付いているか、というのを知りたかったんですよね？</p>

<p>いきなり Entity とか Identity とかいう専門用語が出てきてアレですが、そのあたりのことは先日の OpenID TechNight #13 でもお話ししたので、以下のスライドの Entity・Identity・Authentication・Authorization のあたりのページを見てください。</p>

<iframe src="http://oauthjp.github.io//www.slideshare.net/slideshow/embed_code/key/Lw5OsZp5n6qwXb" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>


<p>で、あるサービスが End-User を認証したいって思った時って、普通は当該サービスが事前に当該 Entity に対して ID と Password を登録させて Identity Record (「サービスアカウント」と言ってもいい) を作成し、後日当該 Entity が当該サービスに訪れた際は登録済みの ID と Password を提示させて当該 Entity に紐づく Identity を確定するわけです。</p>

<p>でも Identity Federation (上記スライドでは「ID 連携」と表現している) という手法を使うと、外部のサービス (Identity Provider, IdP) の Identity を当該サービス (Relying Party, RP)の Identity と紐付けて管理することで、End-User から直接パスワードを預からなくても、ブラウザの前にいる Entity (= End-User) に紐づく IdP 側の Identity に紐付いた RP 側の Identity を確定できるので、結果として End-User に紐づく RP 側の Identity を確定することができます。</p>

<p>で、どうやって IdP と RP がそれぞれに管理している Identity を紐付けるのか、というのが、Federation Protocol の肝なわけですが、「OAuth 認証」というのはその一種です。</p>

<!-- more -->


<h2>「OAuth 認証」とは</h2>

<p>OAuth 自体は「End-User が OAuth Server に管理を委託している Resource に対して、OAuth Client がアクセスすることを許可する方法」を標準化した OAuth Core (RFC 6749) と、「End-User の許可を得た OAuth Client が実際に OAuth Server 上の Resource にアクセスする方法」を標準化した OAuth Bearer (RFC 6750) を核とした標準仕様群なので、Federation Protocol に必要な「IdP 上の Identity をどう表現し RP に伝えるか、という仕組み」は持っていません。</p>

<p>しかし、「IdP 上の Identity をどう表現し RP に伝えるか、という仕組み」は別に標準化されていなくてもいいんですよ。どうせみなさんほとんど Facebook Login しかしないんだから。</p>

<p>っていうことで、「IdP (OAuth Server) 上の Identity 情報にアクセスする API へのアクセス権だけを OAuth Protocol に従って RP (OAuth Client) に渡しましょう。Identity 情報にアクセスする API は、まぁ JSON に user_id とか含めりゃだいたい動くでしょ。」っていうノリでできあがったのが、「OAuth 認証」です。</p>

<p>標準化された方法ではないけども、Identity Federation はしてますね。</p>

<p>Identity 情報にアクセスする API って各 IdP で仕様バラバラなんですけど、みんな OAuth 使ってアクセス権やり取りするってところは共通です。</p>

<p>実際には Identity Federation に必要な多くの部分がそのバラバラな部分に依存したりしてるわけで、とても標準的な Federation Protocol とは呼べない代物ですけども。</p>

<p>ということで、「OAuth 認証」の定義としては、</p>

<p><b>「RP が、IdP の提供する任意の Identity 情報取得 API に対して OAuth Protocol に従ってアクセスすることで、Identity Federation を行う方法の総称」</b></p>

<p>とかでいかがでしょうか？</p>

<p>ちなみに、OpenID Connect においては、UserInfo API ってのが標準化された Identity 情報取得 API で、Identity 情報に加えて IdP 側の認証セッション情報をやり取りする手段が ID Token です。</p>

<p>Identity Federation に必要な情報の多くの部分は実は IdP 側の認証セッションに関する情報だったりするわけですが、その辺の話は、また今度にしましょう。</p>

<h2>補足) 結局「認証か認可か」という議論は何だったのか？</h2>

<p>さて、OAuth は「End-User が OAuth Server に管理を委託している Resource に対して、OAuth Client がアクセスすることを許可する方法」でしたね。</p>

<p>「End-User が OAuth Client 上の Resource へのアクセス権を持つかどうかを、OAuth Client が判断する方法」ではなくて。</p>

<p>普通「認証か認可か」について議論するときって、以下のように主語と目的語が揃っていて、動詞だけが違う条件の元で議論すると思うんですよ。</p>

<ul>
<li>IdP authenticates End-User</li>
<li>IdP authorizes End-User&rsquo;s access (to Resource on IdP)</li>
</ul>


<p>でも「OAuth を利用した認証」と「OAuth における認可」っていう比較をする時って、以下の2つを比較してませんか？</p>

<ul>
<li>RP authenticates End-User (relying on IdP&rsquo;s help)</li>
<li>End-User authorizes RP&rsquo;s access (to Resource on IdP) / IdP authorizes RP&rsquo;s access (to Resource on IdP, on behalf of End-User)</li>
</ul>


<p>いや、それ比較してもいいんですよ。いいんですけど、よほどの前提知識がない限り、主語と目的語と動詞が全部違う2つのコンテキストを比較して、意味のある結論を導き出すことは困難なんじゃないかと思うんです。</p>

<p>本当に「認証か認可か」って比較をするのであれば、以下のコンテキストで比較して意義ある答えにたどり着くようなコンテキストで議論したほうがいいよなぁ、と。</p>

<ul>
<li>Service X authenticates End-User Y</li>
<li>Service X authorizes End-User Y&rsquo;s access (to Resource Z)</li>
</ul>


<p>なので、「OAuth と OpenID Connect」の比較の流れで出てくる「認証と認可」っていう議論に関しては、生暖かく見守っております :p</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenID Connectはそんなに大変かね？]]></title>
    <link href="http://oauthjp.github.io/blog/2016/02/24/is-openid-connect-far-from-oauth2/"/>
    <updated>2016-02-24T11:14:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/02/24/is-openid-connect-far-from-oauth2</id>
    <content type="html"><![CDATA[<p><a href="http://qiita.com/TakahikoKawasaki/items/f2a0d25a4f05790b3baa">OAuth 2.0 + OpenID Connect のフルスクラッチ実装者が知見を語る &ndash; Qiita</a> ってのになんかフォローアップしろよ的なのが来たので。</p>

<p>ざっと読んだ感想としては、「OpenID Connect の OPTIONAL な機能全部実装したら、そら大変ですね」という感じ。（Authlete に関しては、OpenAM みたいな感じで使われる、OpenAM よりはるかに簡単に使える代わりに有料の何かなんだろうな、というイメージです）</p>

<h2>OAuth は必要なのか？</h2>

<ul>
<li>Basic 認証は死んだ。</li>
<li>ユーザー単位での API のアクセスコントロールがしたいです。</li>
</ul>


<p>っていう前提で話すると、OAuth 以外まともな選択肢が無いんじゃないでしょうか。</p>

<p>OAuth の各種 Extension (RFC 6749 &amp; 6750 以外にいろいろある) に関しては、適宜必要なのを実装すればいいんだけど、どれが必要なのかを選ぶのが大変なのは事実で、そこのベストプラクティスとかユースケースごとのガイドラインは今後の課題。IETF OAuth WG の中の人たちも、それは認識している。</p>

<h2>「OAuth 認証」とは</h2>

<p>OAuth は「End-User (に信頼された OAuth Server) が OAuth Client のアクセス権限をコントロールする」というコンテキストにおいての標準化されたプロトコルであって、「Identity Provider (IdP) が End-User を認証した結果を受け取って、Relying Party (RP) が (IdP への信頼を元に) End-User を認証する」というコンテキストで OAuth を使うユースケースが「OAuth 認証」と呼ばれるやつです。</p>

<p>後者のコンテキストで、OAuth は何も標準的な仕様を定めてはいません。</p>

<p>IdP が End-User を認証した結果を RP に伝える方法 (ID Token 相当) や、そのコンテキストで求められることが多い認証されたユーザー属性情報の取得方法 (UserInfo 相当) については、完全に各 Platform が独自に API を提供してるだけなので、そういう意味では「OAuth 認証」ってのは「オレオレ Connect」みたいなもんですね。</p>

<p>まぁでも「オレオレ OAuth」の上で「オレオレ Connect」やる「JWT 認証」よりはマシなんじゃないかなっていう気はします。</p>

<!-- more -->


<h2>OpenID Connect 関連仕様、多すぎ問題</h2>

<p>うん、OpenID Connect の仕様群は、全部読むと大変ですね。</p>

<p>Authlete の人も Dynamic Client Registration は読む必要無かったと思うけど、読む必要あるかどうかを判断するのがまず大変。</p>

<p>そして、そこは OAuth の各種 Extension を全部理解して使いこなすのも、同じように大変。</p>

<p>OAuth の各種 Extension を読まずに OAuth 実装して、その状態から OpenID Connect 仕様を全部実装しようとしたら、一回全部作り直しになってもしょうがないかなとは思います。</p>

<p>でも、自分で IdP 実装する人は、基本 <a href="http://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect Core 1.0</a> だけ読めば十分ですよ。それでも十分大変だけど。</p>

<p>RP 実装する人は、その RP が Web サイトなら <a href="http://openid.net/specs/openid-connect-basic-1_0.html">OpenID Connect Basic Client Implementer&rsquo;s Guide 1.0</a> だけで十分。</p>

<p>Native アプリなら&hellip;Native アプリのケースって Backend Server 含めると 4-party ですし、3-party を想定して策定されてる OAuth や OpenID Connect の範囲を超えているので、今後の課題ですかね。（そういや <a href="http://labs.gree.jp/blog/2015/12/14831/">OAuth for Native Apps</a> てのを先日書きました）</p>

<p>で、ちょっと話がそれましたが、結論としては、IdP 作るのは RP より大変で、Authlete みたいなの作るのは IdP 作るよりさらに大変、というだけのことなのではないでしょうか。</p>

<p>必要な Extension については具体的なユースケース聞かない限りなんとも言えないので、そこは Authlete 的に「とりあえず実装する」という方針だと、Authlete が大変なのはよくわかります。</p>

<p>一方で、ほとんどの IdP 実装は、既存 OAuth 実装に scope=openid と ID Token だけ追加実装すれば十分じゃね？とも思います。</p>

<p>具体的なユースケース聞かない限りなんとも言えないのですが。</p>

<h2>response_type 増えてる問題</h2>

<p>これはまぁ RFC 6749 策定時には「実装はあるけどまだ標準化するレベルになかった」ものが、OpenID Connect の時代には標準化レベルに達していて、OpenID Foundation が Connect 策定するついでに <a href="http://openid.net/specs/oauth-v2-multiple-response-types-1_0.html">OAuth 2.0 Multiple Response Type Encoding Practices</a> にまとめた、っていうのが実際のところ。</p>

<p>「現実の OAuth がとっくに RFC 6749 を超えていたのだよ」という感じでしょうか。</p>

<p>みんなが当時 IETF OAuth WG のスピード感に満足していれば、<a href="http://openid.net/specs/oauth-v2-multiple-response-types-1_0.html">OAuth 2.0 Multiple Response Type Encoding Practices</a> は IETF 側でまとめられていたよね、というのもあるし、RFC 6749 があそこまで時間かかるんだったら、response_type=code+token は Core に入れられたよね、ってのもあるにはあるけど、いまさら言ってもしゃーないすね。</p>

<h2>クライアントアプリケーションのメタ情報、多すぎ問題</h2>

<p>えっと、そもそも、Dynamic Client Registration、きっと使わないです。</p>

<p>Dynamic Client Registration を検討してるって人がもしいたら、まずは <a href="https://tools.ietf.org/html/rfc7636">OAuth PKCE</a> ってので代用できないか検討するがいいかと思います。</p>

<p>Dynamic Client Registration をセキュアにやる方法は、OAuth WG と OpenID Connect の関連仕様を全部読んでもまだ足りないはず。</p>

<p>それでも Dynamic Client Registration したいんだ！って人は&hellip;PKI まわりの技術一通り把握したら、使いこなせる&hellip;のかな&hellip;？</p>

<p>という前提の元で Dynamic Client Registration で登録された Client を Public / Confidential どちらにするかという話をすると、grant_types に implicit 以外が含まれてたら Confidential ですね。</p>

<p>そもそも Dynamic Client Registration で Public Client 登録する意義がよくわかんないですけど。</p>

<h2>Unsigned JWT 作れない問題</h2>

<p>UserInfo Response を Unsigned JWT にするってのも、きっと使わないです。</p>

<p>署名の無い URL-safe Base64 Encoded な JSON (= Unsigned JWT) とか、素の JSON より decode がちょっとめんどいっていう以外に、どんな意義があるというのでしょうか？</p>

<p>UserInfo Response を Singed and/or Encrypted JWT にするってのも、まず使わないでしょう。</p>

<p>「Aggregated Claims が使いたいんだ！」っていう人は検討してもいいですが、「Aggregated Claims って何？」っていう人は、きっと Aggregated Claims も使うこと無いでしょう。</p>

<h2>redirect_uri は必須か？</h2>

<p>これに関しては、<a href="http://openid.net/specs/openid-connect-core-1_0.html#TokenRequestValidation">Token Request Validation</a> では redirect_uri の省略を許しつつも Authentication Request の Section では REQUIRED としか書いてない Connect Core が、読みづらいですね。</p>

<p>Connect でも OAuth との整合性を保つため redirect_uri が1つの場合は省略可能としてもいいですが、OAuth Server のポリシーとして Authorization Request に redirect_uri を必須にしても良いです。</p>

<p>scope=openid の有無でそこが切り替わるっていう実装が、一番わかりづらいんじゃないでしょうか？</p>

<h2>さいごに</h2>

<p>OpenID Connect にしろ OAuth にしろ、何が大変って IdP / Server 向けのオフィシャルなガイドラインが皆無なことですよね。（最近の Google Identity Platform のドキュメント群はなかなかいい感じだと思うけど）</p>

<p>その影響で、関連仕様全部読んで必要なのだけピックアップする仕様理解力か、Core だけ読んで他全部無視するスルー力のどちらかが必要になる。</p>

<p>Qiita の記事を読む限り、Authlete では RP が幅広い OPTIONAL な機能を選択できるようなので、Authlete 実装者は関連仕様全部読む必要あるでしょうし、それら全部実装して Authlete 利用者が必要な機能選択してるんだとしたら、Authlete 利用者にもなかなか高度な仕様理解を求められそうです。</p>

<p>どういうユースケースの場合はどういう OPTIONAL が選択された、っていうノウハウが Authlete に溜まっていくと、そこは Authlete の強みになるんでしょうね。</p>

<p>特に Consumer 向けサービスやってる事業者さん向けには、そういうニーズはありそうな気がします。</p>

<p>OpenID Foundation にもそういうユースケース集作るモチベーションはあると思うので、そういうところで Authlete が活動するメリットを見出せると良いのでしょうね。</p>

<p>あと、どこかのタイミングで「Authlete では結局一度も選択されなかった機能一覧」とか提供してもらって、それらがどういうときに使われるのかを議論するのとかおもしろそう :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth IdP Mix-up Attack - part II]]></title>
    <link href="http://oauthjp.github.io/blog/2016/01/25/oauth-idp-mix-up-attack-part-ii/"/>
    <updated>2016-01-25T15:59:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/01/25/oauth-idp-mix-up-attack-part-ii</id>
    <content type="html"><![CDATA[<p><a href="http://oauth.jp/blog/2016/01/12/oauth-idp-mix-up-attack/">OAuth IdP Mix-Up Attack とは？</a> のつづき。</p>

<p>OAuth ML上で、以下のどちらを採用すべきかについての議論が収まる気配のない昨今です。</p>

<ul>
<li><a href="http://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation">http://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation</a></li>
<li><a href="http://tools.ietf.org/html/draft-sakimura-oauth-meta">http://tools.ietf.org/html/draft-sakimura-oauth-meta</a></li>
</ul>


<p>そんななか、もうちょっとややこしいというか致命的なケースが出て来ました。</p>

<ul>
<li><a href="http://nat.sakimura.org/2016/01/22/code-phishing-attack-on-oauth-2-0-rfc6749/">Code phishing attack on OAuth 2.0 [RFC6749] | .Nat Zone</a></li>
</ul>


<p>&ldquo;Mix-up Attack&rdquo; っていうやつの話をしてたはずが、いつのまにか &ldquo;Code Phishing Attack&rdquo; って名前になっててもはや2つの違いがよく分かんなくなってきますが、ブログ記事中では「フィッシングメールをRP Developerに送って、Client DeveloperにToken Endpointを書き変えさせる」というパターンが例示されています。</p>

<p>いや、そんなんに騙されるやつおらへんやろ〜、ってのがだいたいの反応かとは思いますし、RP Developerのみなさんがちゃんと注意しれてばそれで十分な話ではあるかと思います。</p>

<p>が、IdP視点でいうと、アホなRPからユーザーさんのTokenとかそのRPのclient_secretとかがだだ漏れになっちゃうとIdPのレピュテーションにひびいたりするので、なかなかつらいところです。</p>

<p>もはやここまで騙されてる状況では、Authorization Response以外何も信用できない訳で、Authorization Endpointにiss含んでも、issに紐付いたIdP Configがstaticにhard-codeされてるなら、そのhard-codeされてるconfig自体信用できないということになります。</p>

<p>「IdPごとに別のredirect_uriを使う」なんてのも、もはや無意味ですね。</p>

<p>response_type=code+id_tokenとして、fragmentについてきたID Tokenをチェックしても、Discovery無しだとダメでしょう。</p>

<p>そのため、IdPが取れる対応策は以下の2つのどちらかになるでしょう。</p>

<ul>
<li>issを返しつつ、OAuth Discoveryをサポートする</li>
<li>OAuth MetaのようにToken Endpoint URLをAuthZ Responseに含める</li>
</ul>


<p>前者は <a href="http://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation">http://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation</a> をより厳しくしたもので、後者は <a href="http://tools.ietf.org/html/draft-sakimura-oauth-meta">http://tools.ietf.org/html/draft-sakimura-oauth-meta</a> そのものです。</p>

<p>個人的にはOAuth Discoveryが必須になるとHTTP Requestが増えるので、IdP的にはあまり嬉しくないなぁと思います。</p>

<p>ps.</p>

<p>Implicit FlowにおいてResource Endpointが書き換えられていることを想定したケースでは、AuthZ ResponseにResource Endpoint(s) を含めることになって、Code Flowよりさらにややこしい話になるわけですが、それはまた別の機会に&hellip;書く&hellip;かも。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth IdP Mix-Up Attack とは？]]></title>
    <link href="http://oauthjp.github.io/blog/2016/01/12/oauth-idp-mix-up-attack/"/>
    <updated>2016-01-12T15:51:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/01/12/oauth-idp-mix-up-attack</id>
    <content type="html"><![CDATA[<p>成人式を迎えられたID厨の皆様におかれましては、大変おめでとうございます。成人前からID厨とか、キモカワですね。</p>

<p>さて、今日は、成人式直前にOAuth MLに投下された以下のpostで「OAuth 2.0の脆弱性」として紹介されている &ldquo;IdP Mix-Up Attack&rdquo; について紹介します。</p>

<p><a href="https://mailarchive.ietf.org/arch/msg/oauth/JIVxFBGsJBVtm7ljwJhPUm3Fr-w">[OAUTH-WG] OAuth Security Advisory: Authorization Server Mix-Up</a></p>

<h2>前提条件</h2>

<ul>
<li>End-UserとRPの間の (TLS-protectedでない) HTTP Request/ResponseをAttackerがproxy可能。</li>
<li>RPが2つ以上のOAuth Server (IdP) と接続しており、そのいずれかが攻撃者の管理下にある。(IdPの中の人が実は攻撃者だった etc.)</li>
<li>RPは複数のIdPに対して共通のredirect_uriを利用しており、そこへのcallbackを受け取った時にstate値を元にIdPを特定する。

<ul>
<li>ただしIdP側のredirect_uri検証が「事前登録済の値との完全一致」でない場合は、この通りではない。</li>
</ul>
</li>
</ul>


<h2>攻撃フロー</h2>

<p>以下、Attackerの管理下にあるIdPをAIdP (Attacker IdP)、その他の悪意ないIdPをHIdP (Honest IdP) と呼ぶことにします。</p>

<p><img src="http://oauthjp.github.io/images/posts/oauth-idp-mixup.png" alt="OAuth IdP Mix-Up Attack" /></p>

<ol>
<li>End-UserはRPの任意のページから「HIdPでログイン」ボタンをクリック。</li>
<li>Browser->RPへの (TLS-protectedでない) リクエストをProxyしたAttackerは、RPに「AIdPでログイン」するリクエストを送信し、AIdPのAuthorization EndpointへのRedirect Responseを受け取る。</li>
<li>AttackerはBrowserにHIdPのAuthorization EndpointへのRedirect Responseを返す。ただしstate値は2で受け取った「AIdP向けのAuthorization Requestとひもづいた」値を利用する。(これ以降全リクエストはTLS-protectedであるためAttackerのProxyは介入不可)</li>
<li>End-UserはHIdPでApproveボタンをクリック。</li>
<li>HIdPはstateとcode/tokenをquery/fragmentにつけた状態で、End-UserをRPのredirect_uriに戻す。</li>
<li>code/tokenを受け取ったRPは、state値を元に受け取ったAuthorization ResponseがAIdPからのものだと判断する。</li>
<li>RPはAIdPのToken EndpointやAPI Endpointにcodeやtokenを送りつけてしまい、HIdPのcodeやtokenがAIdP (攻撃者) の手に渡る。</li>
</ol>


<!-- more -->


<h2>対策方法</h2>

<h3>対策方法1</h3>

<p>AIdP向けのredirect_uriとHIdP向けのredirect_uriを分ける。ただしこれが効果を発揮するためには、HIdPがRPからAIdP向けのredirect_uriを受け取った際にエラーになる必要がある。</p>

<h3>対策方法2</h3>

<p>Authorization Responseにcode/token発行者のIdentity情報を含める。</p>

<p>いまOAuth WGで提案されている対応策は、以下の2つです。なんか似たようなのが2つ出てきててカオスですね。</p>

<ul>
<li><a href="http://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation">http://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation</a></li>
<li><a href="http://tools.ietf.org/html/draft-sakimura-oauth-meta">http://tools.ietf.org/html/draft-sakimura-oauth-meta</a></li>
</ul>


<h3>対策方法3</h3>

<p>悪意のある可能性があるIdPを採用しない。(まぁ、普通は採用してないですよね&hellip;)</p>

<h3>どの対応策を採用すべき？</h3>

<p>RPは以上の3つのうちいづれかを採用すれば良いですが、IdPが採用できるのは2しかないですね。</p>

<h2>Malicious Endpoint Attackってのは？</h2>

<p><a href="http://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation">OAuth 2.0 Mix-Up Mitigation &ndash; draft-jones-oauth-mix-up-mitigation-00</a> には、&#8221;IdP Mix-Up Attack&#8221; とは別に &ldquo;Malicious Endpoint Attack&rdquo; ってのが出てきます。</p>

<p>これは、Discovery &amp; Dynamic Client Registrationを前提とした状況で発生する攻撃パターンです。</p>

<p>Dynamic Registrationを前提とすると、「信頼できないIdPを採用しない」という選択肢が取りづらくなるため、より問題が大きくなります。</p>

<p>が、そもそもみなさんそんなDynamic Client Registrationとか使ってないでしょうし、これについての解説はまた機会があればということで&hellip;</p>

<h2>最後に</h2>

<p>ID厨で本当に今年成人式を迎えられたあなた！次回の <a href="http://idcon.org">#idcon</a> の懇親会タダにするんでご容赦くださいm<em> </em>m</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[PR] OpenID Summit Tokyo 2015 やります！]]></title>
    <link href="http://oauthjp.github.io/blog/2015/10/19/openid-summit-tokyo-2015/"/>
    <updated>2015-10-19T11:58:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2015/10/19/openid-summit-tokyo-2015</id>
    <content type="html"><![CDATA[<p>Identity 界隈の皆様は、11/10 に <a href="https://openid.or.jp/summit/2015/index.html">OpenID Summit 2015</a> が開催されることはすでにご存知かと思いますが、OAuth / JWT 愛なみなさまの中にはまだご存知ない方もおられるかもしれないので、こちらでも告知しておきますね。</p>

<p>はい、やります！</p>

<p><a href="https://openid.or.jp/summit/2015/index.html#schedule-timetable">タイムスケジュール</a> みていただいてもおわかりのように、IETF 横浜の翌週というタイミングで、かつ OpenID Foundation (Global の方) の全面協力もあり、OpenID Foundation から主要な外タレ勢揃いな感じでございます。JWT Love なみなさんは、もちろん Mike Jones への愛を忘れたことはないでしょうし、強面やのになぜかプーさんキャラな John Bradley は IETF OAuth WG の各種最新 RFC および draft の解説をしてくれます。</p>

<p>もちろんメインホールでは日本語のセッションもやっとります。日本語セッションは、Identity 技術活用事例とか FINTECH とかマイナンバーとか IDaaS とか&hellip;</p>

<p>あと、毎度おなじみエバ企画、今回は OpenID Connect Certification の体験 Hands-on です。</p>

<ul>
<li>OpenID Connect IdP を実装したけど、本当に自分の実装が OpenID Connect 仕様に準拠してるのか確認したい方</li>
<li>OpenID Connect ライブラリを実装したけど、Connect 準拠の IdP を作るのに事足りるライブラリになってるか確認したい方</li>
<li>なんちゃって Connect 実装とか、なんちゃって OAuth 認証実装したけど、あとどれくらいで Connect 準拠になるのか知りたい方</li>
</ul>


<p>そんな方々に、IdP 実装の Connect 準拠具合をテストするためのツールがあります。</p>

<p>OpenID Connect Certification Hands-on では、テストツールの使い方を紹介後、実際みなさんの実装に対してテストを実行していただき、テストが失敗したものに関する Debug のお手伝い等もさせていただきます。</p>

<p>Global の方の OpenID Foundation からも、Mike Jones が Hands-on 会場に来てくれるようなので、Mike の OpenID Connect Certification のセッションをみた後、そのまま Hands-on に参加すると良いと思います！</p>

<p>ということで、<a href="https://openid.or.jp/summit/2015/index.html">申し込みはこちら</a>！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IETF JOSE WG と OAuth WG から一気に9本の RFC が！]]></title>
    <link href="http://oauthjp.github.io/blog/2015/05/20/jose-and-oauth-assertion-rfcs/"/>
    <updated>2015-05-20T21:05:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2015/05/20/jose-and-oauth-assertion-rfcs</id>
    <content type="html"><![CDATA[<p>一気に出ましたね。すでに過去にもいくつかは紹介したり翻訳したりしていますが、それぞれを簡単に紹介しておきます。</p>

<h3>JOSE WG</h3>

<ul>
<li><a href="http://tools.ietf.org/html/rfc7515">RFC 7515</a> &ndash; JSON Web Signature (JWS)</li>
<li><a href="http://tools.ietf.org/html/rfc7516">RFC 7516</a> &ndash; JSON Web Encryption (JWE)</li>
<li><a href="http://tools.ietf.org/html/rfc7517">RFC 7517</a> &ndash; JSON Web Key (JWK)</li>
<li><a href="http://tools.ietf.org/html/rfc7518">RFC 7518</a> &ndash; JSON Web Algorithms (JWA)</li>
<li><a href="http://tools.ietf.org/html/rfc7520">RFC 7520</a> &ndash; Examples of Protecting Content Using JSON Object Signing and Encryption (JOSE)</li>
</ul>


<p>JWS は署名付きのデータを JSON (の Base64 URL Encode) 形式で表現するための仕様で、多くの場合は JSON Payload に対して署名するケースで利用されます。JSON じゃないデータに対して署名して、署名結果を JSON (の Base64 URL Encode) 形式で表現することもできますが&hellip;まぁ、細かい話は置いときましょう。OpenID Connect の ID Token とかは、JWS 仕様に従って署名されています。</p>

<p>JWE は暗号化されたデータを JSON (の Base64 URL Encode) 形式で表現するための仕様です。現状では JWS よりは利用頻度低いかとは思いますが、SAML Assertion を暗号化してるようなユースケースを Connect に移行する時なんかには使うでしょう。</p>

<p>JWK は JWS や JWE などで利用する鍵を JSON 形式で表現するための仕様です。上記2つとよくセットで利用されます。OpenID Connect でも、OpenID Connect Discovery をサポートしているような IdP では大体公開鍵を JWK Set 形式で公開していますね。</p>

<p>JWA は、JWS や JWE で利用される各アルゴリズムおよびそれらの識別子を定義している仕様です。JWT, JWS, JWE をライブラリを通じて利用しているケースでは、あまり気にすることはないでしょうが、JOSE ライブラリ作者は読むことになるでしょう。</p>

<p>最後のは、サンプルリストですね。これはまぁライブラリ作者が読むくらいでしょう。</p>

<h3>OAuth WG</h3>

<ul>
<li><a href="http://tools.ietf.org/html/rfc7519">RFC 7519</a> &ndash; JSON Web Token (JWT)</li>
<li><a href="http://tools.ietf.org/html/rfc7521">RFC 7521</a> &ndash; Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants</li>
<li><a href="http://tools.ietf.org/html/rfc7522">RFC 7522</a> &ndash; Security Assertion Markup Language (SAML) 2.0 Profile for OAuth 2.0 Client Authentication and Authorization Grants</li>
<li><a href="http://tools.ietf.org/html/rfc7523">RFC 7523</a> &ndash; JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants</li>
</ul>


<p>JWT は JSON (の Base64 URL Encode) 形式で Assertion を生成するための仕様です。OpenID Connect の ID Token などで利用されています。大抵は署名 (= JWS) とセットで利用されるでしょう。</p>

<p>Assertion Framework for OAuth 2.0 (ry) は、任意の Assertion を OAuth 2.0 の Client Authentication で Client Credentials として使ったり、Authorization Grant として利用して Assertion を Access Token と交換するための仕様です。これ単体では利用できず、後の2つのサブ仕様の共通部分を抽象化した仕様になっています。</p>

<p>SAML 2.0 Profile for OAuth 2.0 (ry) は、SAML Assertion を RFC 7521 の Assertion として利用するための仕様です。既存の SAML SP が持っている SAML Assertion を OAuth 2.0 の Access Token と交換して API Access させたいとか、そういう時に使います。「あぁ、それは SAML 単体じゃ無理なんで、ID-WSF 必要ですねぇ〜」って言われたら、多分 ID-WSF 無視してこれ使えば、OAuth 2.0 使えるようになるはずです。</p>

<p>JWT Profile for OAuth 2.0 (ry) は、JWT を RFC 7521 の Assertion として利用するための仕様です。Client Authentication 目的で利用するケースは、ADFS / Azure AD とかであるはずですが、Authorization Grant として利用するケースは&hellip;あったかな？</p>

<h3>Links</h3>

<ul>
<li><a href="http://oauthjp.github.io/blog/2012/10/26/json-web-token-jwt/">JSON Web Token (JWT) &ndash; OAuth.jp</a>

<ul>
<li>もうこの記事書いてから、2年半経ってるんですね〜。感慨深い。</li>
</ul>
</li>
<li><a href="http://oauthjp.github.io/blog/2015/03/16/common-jws-implementation-vulnerability/">JWS 実装時に作りがちな脆弱性パターン &ndash; OAuth.jp</a>

<ul>
<li>すでに JOSE ライブラリは大体出揃ってるので、今後新しく作ることはあまりないかもしれませんが、もし自分で JWS 実装する時は、これ注意してくださいね。</li>
</ul>
</li>
<li><a href="http://openid-foundation-japan.github.io">翻訳ドキュメント一覧 &ndash; OpenID Foundation Japan 翻訳 WG</a>

<ul>
<li>Draft 版の JOSE 仕様群は、こちらに翻訳版あります。</li>
</ul>
</li>
<li><a href="http://www.sakimura.org/2015/05/2997/">JWSとJWTがRFCになりました！ &ndash; @_Nat Zone</a>

<ul>
<li>Nat さんはじめ、みなさんおつかれさまでした！</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[個人情報保護法改正案に見る第三者提供記録義務と越境問題]]></title>
    <link href="http://oauthjp.github.io/blog/2015/03/30/traceability-and-cross-border-data-transportation/"/>
    <updated>2015-03-30T14:19:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2015/03/30/traceability-and-cross-border-data-transportation</id>
    <content type="html"><![CDATA[<p>先日の「<a href="http://oauth.jp/blog/2015/02/28/traceability-on-each-attributes/">属性単位のトレーサビリティについて</a>」という記事でも取り上げましたが、<a href="http://www.cas.go.jp/jp/houan/150310/siryou3.pdf">個人情報保護法改正案</a>では、第二十五条に「第三者提供に係る記録の作成等」という規定が設けられ、第三者提供時に提供者受療者双方に記録義務が発生することとなっています。</p>

<p>また土曜日に行われた情報法制研究会第1回シンポジウムこの提供記録義務と、同じく改正案第二十四条の「外国にある第三者への提供の制限」を組み合わせると、AWSにデータ保存 (委託行為？) するだけで、第三者提供扱いとなり、記録義務が発生してしまうのではという指摘がありました。(まとめからのリンク先、板倉先生の資料参照。パスワードは空気読んで頑張って探してください。)</p>

<p><a href="http://togetter.com/li/801181?page=1">20150328情報法制研究会 第1回シンポジウム「改正個人情報保護法の内容と今後の課題」関連まとめ(私家版)</a></p>

<p>確かに第二十四条では、認定国もしくは認定事業者以外の外国事業者に対するデータ提供の場合は、下記のように第二十三条の例外規定 (委託や共同利用を第三者提供として扱わないという規定含む) を適用しないと明記しているので、委託の場合でも第三者提供扱いとなり、記録義務が発生することになりそうです。</p>

<blockquote>この場合においては、同条の規定は、適用しない。</blockquote>


<p>さらに外国事業者への提供時には、通常の同意とは別に外国事業者への提供であることを明記した上での同意を取得する必要があるため、海外のRPを相手にする国内IdPは、</p>

<ul>
<li>RPが国内事業者であるか否か</li>
<li>RPが海外事業者である場合には認定国の事業者であるか否か</li>
<li>RPが非認定国の事業者である場合には認定事業者であるか否か</li>
</ul>


<p>を判断した上で、いずれにも当てはまらない場合は通常とは別の同意文言を提示する必要が出てきそうです。</p>

<p>いやぁ〜、Dynamic Registrationとかしてる場合じゃないっすね！</p>

<p>どうしましょか、これ？w (ノーアイデァなぅ)</p>
]]></content>
  </entry>
  
</feed>
