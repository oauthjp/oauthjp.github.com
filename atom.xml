<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[OAuth.jp]]></title>
  <link href="http://oauthjp.github.io/atom.xml" rel="self"/>
  <link href="http://oauthjp.github.io/"/>
  <updated>2014-05-09T11:13:52+09:00</updated>
  <id>http://oauthjp.github.io/</id>
  <author>
    <name><![CDATA[Nov Matake]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[OAuth 2.0 の code は漏れても大丈夫ってホント!?]]></title>
    <link href="http://oauthjp.github.io/blog/2014/05/09/what-happens-when-oauth2-code-leaked/"/>
    <updated>2014-05-09T09:59:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/05/09/what-happens-when-oauth2-code-leaked</id>
    <content type="html"><![CDATA[<p>昨日の<a href="http://oauthjp.github.io/blog/2014/05/08/covert-redirect-and-non-30x-redirects/">Covert Redirect で Query 漏れるケースもある!?</a>や<a href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect/">OAuth 2.0 の脆弱性 (!?) &ldquo;Covert Redirect&rdquo; とは</a>にあるように、OAuth 2.0 の code が漏れちゃうことも、ありえます。</p>

<p>漏れないためにやるべきことは、上記の記事や<a href="http://oauthjp.github.io/blog/2014/05/08/facebook-login-and-covert-redirect/">Facebook Login で Covert Redirect を防止する</a>なんかでも紹介してるので、そちら読んでください。</p>

<p>で、今回の内容は<strong>「code が漏れたら何がまずいのか」</strong>についてです。</p>

<h3>「code は漏れても大丈夫」説</h3>

<p><a href="http://www.openid.or.jp/blog/2014/05/covert-redirect-and-its-real-impact-on-oauth-and-openid-connect.html">「Covert Redirect」についての John Bradley 氏の解説（追記あり）</a>にも、こうありましたね。</p>

<blockquote>
OAuth と OpenID Connect には複数の response_type があるんだけど、さきのリポートの著者は、最も一般的な response_type が &#8220;code&#8221; であることに触れず、またクライアント・クレデンシャルを使ってもう一度呼び出しを行わないとアクセス・トークンは手に入らないってことも無視してる。つまり、たしかに &#8220;code&#8221; がオープン・リダイレクターを経由して漏洩するかもしれない、という点については彼が正しい。けど、その code を使って攻撃者がなにかできるわけではないよ。これこそまさに、&#8221;code&#8221; response_type を使うことで得られる効果的な緩和策だね。
</blockquote>


<p>あれ？code 漏れても問題なさそうですね？</p>

<p>ほんとでしょうか？</p>

<h4>[仕様策定者視点での答え]</h4>

<blockquote>
本当です。みんながちゃんと OAuth の仕様に沿って実装していれば。仕様に沿って実装してない場合は知らん。ちゃんとやれ。
</blockquote>


<h4>[OAuth Server 実装者視点での答え]</h4>

<blockquote>
本当です。Client がちゃんと client secret を漏洩させずに、OAuth の仕様に沿って実装していれば。client secret 漏らしたり仕様に沿って実装してない場合は、うちのユーザーに迷惑かかるかもしれんし、あなたのアプリ停止しちゃうね。
</blockquote>


<h4>[OAuth Client 実装者視点での答え]</h4>

<blockquote>
え？俺ちゃんと仕様に沿って実装できてんの？

&#8230;まぁ動いてるしできてる、よね！？

それに万が一 code 漏れても、うちに被害及ぶってより OAuth Server に被害及ぶはずやし、OAuth Server がちゃんと対策してれば、まぁなんとかなるよね？
</blockquote>


<p><strong>ゆとりか！(｀ヘ´#)</strong></p>

<p>OAuth Client 実装者がこういう考えだと、一瞬でやられちゃいそうですねぇ。</p>

<p>ってことで、ここでは<strong>「code が漏れたら OAuth Client 側でアカウント乗っ取りが発生する」</strong>ケースについて考えてみましょう。</p>

<!-- more -->


<h3>前提条件</h3>

<p>あなたのサイトは「Facebook ID でログイン」できるようになっています。(ちなみにここでは一番世に広まっている Facebook を挙げますが、問題の本質は Facebook に限定された話ではないので、ID Provider が GitHub や LinkedIn な場合でも同様です)</p>

<p>あなたのサイトからは client secret は漏れていませんし、Implicit Flow も使ってないので、「Token 置換攻撃 ※1」は受けません。</p>

<p>あなたのサイトには open redirector があり、被害者の code が攻撃者に漏洩しています。(or している可能性があります)</p>

<p>client secret は漏れていないので、攻撃者が漏洩した code を access token と交換することは、できません。</p>

<h3>攻撃例</h3>

<p>攻撃者は、あなたのサイトの正規の redirect_uri に、漏洩した code を送りつけます。</p>

<pre>
GET /facebook/callback?code=&lt;leaked-code&gt;
Host: client.example.com
</pre>


<p>ここであなたのサイトはこのリクエストを Facebook から正規のリダイレクトレスポンスとして処理します。通常、だいたいこんな処理を行うのではないでしょうか。</p>

<ol>
<li>Facebook の Token Endpoint に code を POST し、access token を取得する。</li>
<li>access token を使って <code>GET /me</code> にアクセスし、ユーザーの Facebook UserID を取得する。</li>
<li>取得した Facebook UserID と紐づくアカウントを特定し、local の session cookie を発行するなどしてログイン済にする。</li>
</ol>


<p>あれ、攻撃者が、被害者の code を使って、あなたのサイトにログインできてしまいましたね？</p>

<p>Token 置換攻撃と同じ現象が起こっちゃいましたね？</p>

<p>こんなことが起こりえる以上、</p>

<blockquote>
万が一 code 漏れても、うちに被害及ぶってより OAuth Server に被害及ぶはずやし、OAuth Server がちゃんと対策してれば、まぁなんとかなるよね？
</blockquote>


<p>なんて悠長なことは、言ってられませんね。</p>

<h3>対策方法</h3>

<p>まず、この攻撃が発生してしまう根本原因は、ここです。</p>

<blockquote>
ここであなたのサイトはこのリクエストを Facebook から正規のリダイレクトレスポンスとして処理します。
</blockquote>


<p>これを防げれば OK です。</p>

<p>これを防ぐための一番簡単な方法は、<strong>被害者と攻撃者が異なる UserAgent を使っていることを検知する</strong>ことです。</p>

<p>いわゆる CSRF 対策ができてればいいんですね。</p>

<p>ここで @ritou 先生の<a href="http://d.hatena.ne.jp/ritou/20121008/1349695124">OAuth 2.0のstateとredirect_uriとOpenID ConnectのnonceとID Tokenについて</a>でも紹介されてる state パラメータってやつが登場するわけです。</p>

<p>この state パラメータについては、Client が任意であらゆる文字列を指定できてしまうので、前提知識の乏しい Developer にとってはいまいち何を指定すればいいか分からないかもしれません。</p>

<p>@ritou 先生の記事に従って、session ID のハッシュ値を指定してもいいですし、先日 John Bradley が出してきた<a href="http://tools.ietf.org/html/draft-bradley-jwt-encoded-oauth-state-00">こちらの OAuth 2.0 拡張仕様</a>を参考にしても良いでしょう。</p>

<h3>結論</h3>

<p>ちゃんと state 使ってない OAuth Client に関しては、<strong>「code なら漏れても大丈夫」なんてウソです</strong>。</p>

<p>OAuth Server には、code 置換攻撃を防ぐ手だてはありません。</p>

<p>OAuth Client がちゃんと実装するしかありません。</p>

<p>ちゃんとしましょう。</p>

<p>※1「Token 置換攻撃」については、これまでもたびたび書いてきたので、これらの記事をどうぞ。</p>

<ul>
<li><a href="http://www.atmarkit.co.jp/ait/articles/1209/10/news105_2.html">@IT &ndash; RFCとなった「OAuth 2.0」――その要点は？ (2/2)</a></li>
<li><a href="http://oauthjp.github.io/blog/2012/02/08/ios-sdk/">&ldquo;なんちゃら iOS SDK&rdquo; でありそうな被害例</a></li>
<li><a href="http://oauthjp.github.io/blog/2012/02/07/oauth-20-implicit-flow/">「OAuth 2.0 (Implicit Flow) でログイン」の被害例</a></li>
<li><a href="http://oauthjp.github.io/blog/2012/06/29/oauth-20-implicit-flow-78852/">OAuth 2.0 Implicit Flow で認証の問題点、再び。</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Covert Redirect で Query 漏れるケースもある!?]]></title>
    <link href="http://oauthjp.github.io/blog/2014/05/08/covert-redirect-and-non-30x-redirects/"/>
    <updated>2014-05-08T15:47:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/05/08/covert-redirect-and-non-30x-redirects</id>
    <content type="html"><![CDATA[<p>Covert Redirect 連載最後は、location.href とか &lt;meta http-equiv=&ldquo;Refresh&rdquo;&gt; とかだと referrer 通じて query に含まれる code とかも漏れるかもね！ってお話です。</p>

<p>古いサイトですが、こことか見れば大体いいんじゃないでしょうか => <a href="http://www.teria.com/~koseki/memo/referrer/">リファラ実験</a></p>

<p>で、こういうリダイレクトをしてる箇所が OAuth 2.0 の redirect_uri なり OpenID 2.0 の return_to なりに指定されていれば、query に付いた code なり email なりがリファラ経由で外部に漏れるよね、という。</p>

<p>はい、漏れますね！ (投げやり</p>

<p>さて、そんなに該当例多くはないと思うのですが、ここまで該当してしまったサービスは、どうしますかねぇ&hellip;</p>

<p>Facebook であれば、<a href="http://oauthjp.github.io/blog/2014/05/08/facebook-login-and-covert-redirect/">Facebook Login で Covert Redirect を防止する</a>にあるような方法で回避できますが、それ以外の OAuth Provider なり OpenID 2.0 Provider と連携してる場合は、困っちゃいますねぇ&hellip;</p>

<!-- more -->


<h3>被害例</h3>

<p><a href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect/">OAuth 2.0 の code が漏れた場合について</a>は既に書きました。</p>

<p>Client が redirect_uri 上で state パラメータのチェックを怠っていれば、code 置換攻撃が可能になるっていうアレです。</p>

<p>OpenID 2.0 のレスポンスパラメータが漏れた場合は、そのパラメータに email や name なんかが含まれてる場合があるので、そういった場合はそれらが外部に漏洩します。</p>

<p>また世の中には OpenID 2.0 の nonce を OAuth 2.0 の access token のように使って API アクセスさせる事業者があったりするんで、そういった場合は acccess token 相当のものが漏洩します。</p>

<p>それら access token 相当の nonce が漏れた場合の実害については、提供される API に依存するのでここでは未知です。</p>

<h3>対策方法</h3>

<p>リダイレクト方法変えろ、って以外の回避策を思いついたら、この下に書きます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Facebook Login で Covert Redirect を防止する]]></title>
    <link href="http://oauthjp.github.io/blog/2014/05/08/facebook-login-and-covert-redirect/"/>
    <updated>2014-05-08T14:16:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/05/08/facebook-login-and-covert-redirect</id>
    <content type="html"><![CDATA[<p><a href="http://oauth.jp/blog/2014/05/07/covert-redirect-in-implicit-flow/">OAuth 2.0 Implicit Flow では Covert Redirect 経由で access token が漏れる件</a>については既に紹介しましたが、ここではみなさん大好き Facebook Login で OAuth Client Developer ができる対策について紹介することにします。</p>

<h3>攻撃方法</h3>

<ol>
<li>攻撃対象となる OAuth Client の FB client_id を取得

<ul>
<li>client_id は FB Login ボタンさえクリックすればアドレスバーに表示される。</li>
</ul>
</li>
<li>Authorization Request URL を構築

<ul>
<li>対象 Client が通常 response_type=code を使ってる場合でも、問答無用で response_type=token にしてください。</li>
<li><a href="https://www.facebook.com/dialog/oauth?client_id=relace-me&amp;redirect_uri=relace-me&amp;response_type=token">https://www.facebook.com/dialog/oauth?client_id=<em>&lt;client_id></em>&amp;redirect_uri=<em>&lt;redirect-url></em>&amp;response_type=token</a></li>
</ul>
</li>
<li>被害者を2で作った URL にアクセスさせます

<ul>
<li>フィッシングがんばってください。</li>
</ul>
</li>
<li>redirect_uri に指定しておいた URL で fragment に付いて来る access token を待ち構えます。</li>
</ol>


<p>以上、巧いフィッシング方法さえ思いつけば簡単ですね。</p>

<h3>防御方法</h3>

<p>防御方法は、大きく分けて3つあります。</p>

<ol>
<li>open redirector を撤廃する</li>
<li>response_type=token を利用禁止にする</li>
<li>redirect_uri を完全一致しか認めさせなくする</li>
</ol>


<!-- more -->


<h4>open redirector を撤廃する</h4>

<p>まぁそらそれがベストですよね。</p>

<p>「あっ、はい」とか言う人いるけども。</p>

<p>まぁ、「それができれば最初っからやってるっちゅうねん」ってのは、ごもっとも。</p>

<h4>response_type=token を利用禁止にする</h4>

<p>FB にはそのためのオプション &ldquo;<a href="https://developers.facebook.com/docs/graph-api/securing-requests/">appsecret_proof</a>&rdquo; があります。</p>

<p>厳密には response_type=token を利用禁止にするのではなく、access token 単体で API Request をさせない、というオプションです。</p>

<p>このオプションを有効化すると、API Request に client_secret が必要になるため、client_secret が漏洩しない限りは、たとえ access token が漏洩してしまっても問題ありません。</p>

<p>え？client_secret が漏洩するかもって？</p>

<p>そんな、OAuth 1.0 じゃあるまいし、まさか Native App に client_secret 埋め込んだりしてないはずですよね？ね？？</p>

<p>なおこのオプションを有効にできるのは、client_secret を秘匿に保てる Client、つまりサーバーサイドで動作する Web App に限られます。</p>

<p>Client が Native App な場合や、Web App と Native App の両方で同じ client_id を使っている場合は、このオプションは選べません。</p>

<p>2014年5月現在では、このオプションは以下の URL から &ldquo;App Secret Proof for Server API calls&rdquo; というのを ON にすれば有効化されます。
<a href="https://developers.facebook.com/apps/:app_id/settings/advanced/">https://developers.facebook.com/apps/:app_id/settings/advanced/</a></p>

<h4>redirect_uri を完全一致しか認めさせなくする</h4>

<p>デフォルトでは redirect_uri の部分一致を許容する Facebook ですが、redirect_uri を完全一致のみ許可させるよう指定することもできます。</p>

<p>2014年5月現在では、このオプションは以下の URL から &ldquo;Valid OAuth redirect URIs&rdquo; というのを field に URL を指定すれば有効化されます。
<a href="https://developers.facebook.com/apps/:app_id/settings/advanced/">https://developers.facebook.com/apps/:app_id/settings/advanced/</a></p>

<p>Native App でも利用する client_id に関しては、このオプションを利用しましょう。</p>

<p>Web App でも、OAuth 2.0 の独自拡張である <a href="https://developers.facebook.com/docs/graph-api/securing-requests/">appsecret_proof</a> を利用するよりも、OAuth 2.0 の仕様に乗っ取った挙動になるこのオプションの方が、ライブラリをそのまま使えるとかいろいろメリット多そうですね。</p>

<p>みなさんのユースケースにあったオプションをお選びください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenID 2.0 における Covert Redirect と RP Discovery]]></title>
    <link href="http://oauthjp.github.io/blog/2014/05/08/covert-redirect-and-openid-2-dot-0/"/>
    <updated>2014-05-08T10:57:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/05/08/covert-redirect-and-openid-2-dot-0</id>
    <content type="html"><![CDATA[<p>さて、<a href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect-in-implicit-flow/">OAuth 2.0 &amp; OpenID Connect における Covert Redirect の問題</a> についてはまとめたので、次は OpenID 2.0 についてです。</p>

<p>いいですか、OpenID Connect ではなく、OpenID 2.0 ですよ。古い方です。懐かしいですね、<a href="http://openid.net/specs/openid-authentication-2_0.html">OpenID Authentication 2.0 &ndash; Final</a>。</p>

<p>そういえば、OpenID Foundation Japan の翻訳 WG を立ち上げて、一番最初に翻訳したのが <a href="http://openid-foundation-japan.github.io/openid-authentication.html">OpenID Authentication 2.0 の 日本語訳</a>でしたね&hellip;(遠い目</p>

<p>と、昔話はそれくらいにして、本題に入りましょう。</p>

<h3>まずは Covert Redirect 発生条件について</h3>

<p>OpenID 2.0 では、レスポンスパラメータは query に引っ付いてきます。fragment は使いません。</p>

<p>なので、open redirector のリダイレクト先には、通常はレスポンスパラメータは渡りません。</p>

<p>全ての query パラメータをリダイレクト先に引き継いでしまうという、奇妙な open redirector を用意してる場合にのみレスポンスパラメータが外部に漏洩します。</p>

<p>まずはこの時点でそんなに心配することはなさそうですね。</p>

<p>まぁでもせっかくなんで、話続けますね。</p>

<!-- more -->


<h3>RP Discovery ってのがあってだな</h3>

<p>さて、OpenID 2.0 には、<a href="http://openid.net/specs/openid-authentication-2_0.html#rp_discovery">RP Discovery というものが定義されていた</a> (<a href="http://openid-foundation-japan.github.io/openid-authentication.html#rp_discovery">翻訳版はこちら</a>) のを、おぼろげに覚えている方もおられるのではないでしょうか？</p>

<p>え、そんなの聞いた事が無い？でしょうね！w</p>

<p>OpenID 2.0 は OAuth とちがって、通常 RP が OP に対して事前登録を行うことはありません。</p>

<ul>
<li>RP: Relying Party, OAuth 2.0 の Client 相当</li>
<li>OP: OpenID Provider, OAuth 2.0 の Server 相当</li>
</ul>


<p>OP と RP の間では、動的に association というものを確立します。association って何？って人には、「最初に Temporary な共有秘密鍵をする」って言っちゃえばいいですかね。</p>

<p>association が確立されると、RP は各種リクエストパラメータと共に return_to (OAuth 2.0 の redirect_uri 相当) ってのを指定して、ユーザーを OP にリダイレクトさせます。</p>

<p>で、OP はユーザー認証とか同意取得とか OAuth と似たようなことしてから、最終的に各種レスポンスパラメータを添えてユーザーを指定された RP の return_to にリダイレクトして戻します。</p>

<p>で、ここまでが全部 dynamic なんで、事前登録された return_to との完全一致、なんてことがそもそもありえないんです。</p>

<h3>RP Discovery ってのがあってだな (part 2)</h3>

<p>まぁ既に RP Discovery についての記述を読んだみなさんには釈迦に説法、ネコに小判ですか？あれですね、日本語難しいですね。</p>

<p>まぁあれです、OpenID 2.0 の仕様だけで RP Discovery 理解しろとかムリゲーな気がします。Yadis ってのがあってだな&hellip;いや、やめよう。</p>

<p>実際に、これまた懐かしの iKnow! を例に、RP Discovery ってのを概観してみましょう。</p>

<p>まず iKnow! に OpenID でログインする際のリクエストパラメータを眺めると、&#8221;openid.realm=<a href="https://*.iknow.jp/open_ids">https://*.iknow.jp/open_ids</a>&#8221; ってのが含まれてるのが分かるかと思います。</p>

<p>iKnow! はちょっとレアケースで、サブドメインを許可する為に &ldquo;*.iknow.jp&rdquo; になってますが、そういう場合は &ldquo;*&rdquo; を &ldquo;www&rdquo; に置き換えて &ldquo;<a href="https://www.iknow.jp/open_ids">https://www.iknow.jp/open_ids</a>&rdquo; にアクセスします。</p>

<script src="https://gist.github.com/nov/c702782baa98c75702dc.js"></script>


<p>あ、リダイレクトしましたね。これは follow します。</p>

<script src="https://gist.github.com/nov/67c491166bed6f9cdb7e.js"></script>


<p>で、このレスポンスヘッダに注目です。</p>

<pre>X-XRDS-Location: https://iknow.jp/discovery.xrds</pre>


<p>XRDS ってのがありますね。これが、RP の metadata が記述されたドキュメントです。</p>

<p>で、今度はこの XRDS endpoint にアクセスします。</p>

<script src="https://gist.github.com/nov/b6173c3195fa49e1c668.js"></script>


<p>はい、return_to が指定されてますね。</p>

<pre>&lt;Service priority="0"&gt;
  &lt;Type>http://specs.openid.net/auth/2.0/return_to&lt;/Type&gt;
  &lt;URI>https://iknow.jp/open_ids?_method=GET&lt;/URI&gt;
&lt;/Service&gt;</pre>


<p>で、RP Discovery をサポートしてる OP は、RP の realm にアクセスしてみて、レスポンスヘッダに &ldquo;X-XRDS-Location&rdquo; ってのがあれば、return_to の検証を行う、ってのが一般的な実装かと思います。</p>

<h3>RP Discovery って必要なの？</h3>

<p>大概の OP では不要です。</p>

<p>てか RP 側の人たちはこれほとんど知らんかったんじゃないかと。</p>

<p>噂によると一部 OP では RP Discovery が必須なやつもいるらしいですが、Gooogle, Yahoo! Japan, mixi はじめ、ほぼ全ての主要 OP では RP Discovery は OPTIONAL です。</p>

<p>また XRDS 中の return_to に指定されている URL とリクエストパラメータに含まれる return_to のマッチングルールも、完全一致だったり部分一致だったりは OP ごとに違うようです。</p>

<p>さらには RP 側が &ldquo;X-XRDS-Location&rdquo; を返さない限り、OP 側では RP Discovery をスキップします。</p>

<p>よって、RP Discovery を実装していない RP に open redirector が存在する場合は、それが悪用されるケースはあり得ます。(まぁこの記事の先頭で紹介した発生条件を満たす open redirector が存在するケースは稀ですが)</p>

<h3>対策</h3>

<p>まず query を全部引き継いでリダイレクトするのやめましょう。いや、そもそもみなさんはそんなことしてないと思いますけど。</p>

<p>RP Discovery は、まぁ頑張ってやってみてもいいかもしれないけど、結構複雑なのであまり気軽に実装できる気はしません。</p>

<p>&hellip;懐かしかったですね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implicit Flow では Covert Redirect で Token 漏れるね]]></title>
    <link href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect-in-implicit-flow/"/>
    <updated>2014-05-07T18:41:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/05/07/covert-redirect-in-implicit-flow</id>
    <content type="html"><![CDATA[<p>この記事は、<a href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect">先ほど書いたこちらの記事</a>の訂正版です。</p>

<p><strong>記事に入る前に、まずは全シンガポールにお詫び申し上げますm<em> </em>m</strong></p>

<p>さて、Covert Redirect についての説明は&hellip;超絶取り消し線はいりまくってる前の記事を読んでください、でいいでしょうか？</p>

<p>で、訂正分だけ以下に。</p>

<h3>Fragment Handling in Redirect</h3>

<p><a href="http://weblog.bulknews.net/post/85008516879/covert-redirect-vulnerability-with-oauth-2">宮川さんが記事にしてますね</a>。</p>

<p>英語だけど。</p>

<p>で、まぁ要するに、(Modern Browser は) 30x リダイレクト時に<strong>リダイレクト元に付いてた URL fragment をリダイレクト先にも引っ付ける</strong>、と。</p>

<p>fragment は server-side には送られないけど、クライアントサイドではリダイレクト先に引き継がれる、と。</p>

<p>試しに <a href="http://www.idcon.org/#foobar">http://www.idcon.org/#foobar</a> にアクセスすると、<a href="http://idcon.org/#foobar">http://idcon.org/#foobar</a> にリダイレクトされるかと思います。</p>

<p>www.idcon.org のサーバーには <strong>#foobar</strong> の部分は送られませんが、<a href="http://idcon.org/">http://idcon.org/</a> に load される client-side の JS からは、<strong>#foobar</strong> にアクセスできます。</p>

<p>なので、Covert Redirect のケースでも、open redirector をつかって最終的に被害者がリダイレクトしてくる endpoint に攻撃者が JS を仕込んでそれを自分のサーバーにでも送るようにしておけば、<strong>access token が漏洩します</strong>。</p>

<p>もちろん<a href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect">先ほどの記事にあるように</a>、Authorization Code が漏洩するケースもありますが、open redirector の実装詳細に依存しない分、Implicit Flow において fragment に含まれる access token が漏洩する方が可能性としては高いでしょう。</p>

<!-- more -->


<h3>仕様のバグではないが&hellip;</h3>

<p><a href="http://weblog.bulknews.net/post/85008516879/covert-redirect-vulnerability-with-oauth-2">宮川さんが記事</a>にもあるように、<a href="http://tools.ietf.org/html/rfc6819">RFC6819 &ndash; OAuth 2.0 Threat Model and Security Considerations</a> の <a href="http://tools.ietf.org/html/rfc6819#section-4.2.4">Section 4.2.4</a>, <a href="http://tools.ietf.org/html/rfc6819#section-5.2.3.5">Section 5.2.3.5</a> あたりにはこの問題が指摘されています。(<a href="http://openid-foundation-japan.github.io/rfc6819.ja.html">RFC6819 翻訳版はこちら</a>)</p>

<p>また <a href="http://tools.ietf.org/html/rfc6749">RFC6749 &ndash; The OAuth 2.0 Authorization Framework</a> の <a href="http://tools.ietf.org/html/rfc6749#section-3.1.2.2">Section 3.2.2.1</a> では redirect_uri の<strong>部分一致は query にしか</strong>認められていません。domain のみのマッチングや path の一部のみの一致で OK にしてしまうのは、実装上のバグと言えるでしょう。(<a href="http://openid-foundation-japan.github.io/rfc6749.ja.html">RFC6749 翻訳版はこちら</a>)</p>

<p>OpenID Connect では、query も含めて <strong>redirect_uri の部分一致を認めていません</strong>。(<a href="http://openid.net/specs/openid-connect-core-1_0.html#ImplicitAuthRequest">OpenID Connect Core Section 3.2.2.1</a> 参照, <a href="http://openid-foundation-japan.github.io/openid-connect-core-1_0.ja.html#ImplicitAuthRequest">日本語版はこちら</a>)</p>

<p>OAuth 1.0 では Refresh Token Secret が漏れない限り Access Token が Covert Redirect 経由で漏洩することは無いですし、OpenID 2.0 でも RP Discovery というのをきちんとやっていれば、redirect_uri の exact match 相当のことができます。</p>

<p>なので、特に Covert Redirect がこれらの仕様のバグであるということではありません。</p>

<p>が、まずい実装は結構ある、というのが、<a href="http://tetraph.com/covert_redirect/oauth2_openid_covert_redirect.html">元記事</a>の Provider List が伝えたかったことなのでしょう。</p>

<p>まぁ確かに redirect_uri の部分一致認めてる OAuth Server なんてそこら中にあるし、OpenID 2.0 に至っては RP Discovery 必須な OP ってどこよ？、みたいな状態ですし、OpenID Connect 実装って言っても完全に OpenID Connect の仕様に準拠してるかどうかあやしいですし&hellip;</p>

<p>いや、Google の Connect 実装は exact match ですよ。でも元記事見る限り、Google のは OpenID 2.0 実装が問題にされてますね。</p>

<p>Y!J の OpenID Connect も redirect_uri の部分一致は認められていないので、大丈夫です。</p>

<p>mixi と楽天の OAuth 2.0 実装は、そもそも Implicit Flow サポートしてません。</p>

<p>OpenID 2.0 実装に関しては&hellip;<a href="http://oauthjp.github.io/blog/2014/05/08/covert-redirect-and-openid-2-dot-0">別記事にまとめました</a>。</p>

<h3>攻撃パターン</h3>

<p>攻撃者は、redirect_uri を Client 上に存在する open redirector の endpoint に書き換えたリンクを被害者に踏ませます。</p>

<p>このリンクを踏ませる方法は何でもいいのですが、Client 側に悪意が無い限り、基本的には「通常のフロー」とは異なる方法でリンクを踏ませることになるでしょう。フィッシングですね。</p>

<p>で、あとは被害者が同意ボタンを押せば、open redirector 経由で攻撃者が指定した URL に、(ユーザーが Modern Browser を利用している場合は) fragment に access token を含んだ状態で、被害者がアクセスしてきます。</p>

<p>あとはその fragment から JS をつかって access token を抜き出して&hellip;ってのはこの記事冒頭でも書きましたね。</p>

<h3>対策</h3>

<h4>Server 側ができること</h4>

<p>redirect_uri の完全一致を必須にする。</p>

<p>いままで動いてた既存アプリが突然動かなくなるケースもあるでしょうし、そうそう気軽に変更できる部分では無いかもしれませんが、ある程度の猶予期間を用意した上で、redirect_uri の完全一致を必須にするのが良いでしょう。</p>

<p>あと、そもそもこの問題が自社の各プロトコル実装で置きうるのかどうか、redirect_uri の検証方法をいま一度 Developer 向けに広報する、とかはやった方がいいかもしれませんね。</p>

<h4>Client 側ができること</h4>

<p>例えば Facebook は、redirect_uri の完全一致を行うようにアプリ設定画面で指定することができます。(Advanced Settings の &ldquo;Valid OAuth redirect URIs&rdquo; ってやつ)</p>

<p>&ldquo;Valid OAuth redirect URIs&rdquo; はデフォルトでは空っぽで、その状態では redirect_uri の部分一致が許容されますが、ここに URL を指定することでFB 側に redirect_uri の完全一致を要求することができます。</p>

<p>そもそも Implicit Flow なんてつかわねーよ、って場合は、<a href="https://developers.facebook.com/docs/graph-api/securing-requests/">appsecret_proof</a> なんていう FB の独自拡張を利用することもできそうですが、まぁこれはそのうち調べようと心に誓いつつ全く調べてないのでよく知らないです。</p>

<p>あと open redirector 作らない、ってのね。</p>

<p>こらそこ、「あっ、はい」とか言わない。</p>

<h4>User 側ができること</h4>

<p>フィッシングに引っかかるな、くらいしか思いつかないですが、まぁそれじゃ引っかかる時は引っかかるでしょうね&hellip;</p>

<p>Client と Server が頑張る、のを応援する、ってのが一番いいかもしれませんね。</p>

<h3>最後に</h3>

<p>改めまして、全シンガポールにお詫び申し上げますm<em> </em>m</p>

<p>あと Twitter で mention いただいた <a href="https://twitter.com/miyagawa">@miyagawa</a> さんと、LINE の某厨部屋で連絡くれた <a href="https://twitter.com/mad_p">@mad_p</a> さん、ありがとうございますm<em> </em>m</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth 2.0 の脆弱性 (!?) "Covert Redirect" とは]]></title>
    <link href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect/"/>
    <updated>2014-05-07T13:53:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/05/07/covert-redirect</id>
    <content type="html"><![CDATA[<h3>訂正</h3>

<p>リダイレクト時の fragment の扱いを勘違いしていたため、本記事全体訂正します。</p>

<p>細かく訂正いれてると分けわかんなくなってきたんで、<a href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect-in-implicit-flow/">新しい記事書きました</a>。</p>

<p>ゴールデンウィークまっただなかに Twitter で海外の ID 厨から袋だたきにあってたので、もうこの問題は片付いただろうとすっかり油断してた「Covert Redirect」の件ですが、日本でもゴールデンウィーク明けてバズりだしたので、一旦問題を整理した方がよさそうですね。</p>

<h3>事の発端</h3>

<p>Wang Jing さんていうシンガポールの大学院生が、<a href="http://tetraph.com/covert_redirect/oauth2_openid_covert_redirect.html">こんなサイト</a>を公開すると共に <a href="http://www.cnet.com/news/serious-security-flaw-in-oauth-and-openid-discovered/">CNet</a> はじめ各種メディアが取り上げたのが、バズりだした発端のようです。</p>

<h3>前提知識</h3>

<p>OAuth 2.0 や OpenID Connect だけでなく、OAuth 1.0 や OpenID 1.0/2.0 や SAML なんかでも、<strong>2つのサービスの間でリダイレクトを経由して</strong>、Access Token や ID Token などのいわゆる <strong>&ldquo;Security Token&rdquo; の授受</strong> が行われます。</p>

<p>Covert Redirect の問題は本質的にはこれら全てに影響しますが、各仕様一個一個見て行くといろいろ疲れるので、ここでは OAuth 2.0 に絞って話をすすめましょう。</p>

<p>OAuth 2.0 では、まず Client が End-User の UserAgent を Server の Authorization Endpoint というところにリダイレクトします。よく Twitter とか Facebook の ID で外部サービスにログインするとき、一度 Twitter や Facebook にリダイレクトして、同意画面表示されますよね？あれです。</p>

<p><img src="https://fbcdn-dragon-a.akamaihd.net/hphotos-ak-prn1/t39.2178-6/851557_535801936465660_169463870_n.png" alt="FB の同意画面" /></p>

<p>で、みなさん何も考えず熟慮の結果、同意ボタンを押すじゃないですか。そして、元のサイト (= Client) に戻って来る、と。</p>

<p>OAuth 愛好家の間で &ldquo;OAuth Dance&rdquo; なんて呼ばれてるアレですね。</p>

<p>で、今回の話は、その <strong>&ldquo;OAuth Dance&rdquo; 中の話</strong> です。</p>

<!-- more -->


<h3>Covert Redirect てなんだ？</h3>

<p>Server 側の同意画面で同意ボタンを押すと、Client にリダイレクトして戻って来る。</p>

<p>そう、同意すると、元の Client に戻って来るんですよ。</p>

<p>で、Client 側に open redirector があって、まさにその open redirector めがけて戻ってきちゃったりしたら、そらもう open に redirect する訳です。</p>

<p>さらに悪いことに、open redirector の実装によっては、リダイレクト時に query に引っ付いてきたデータがそのリダイレクト先にまで渡っちゃうこともあるんです。</p>

<p>渡された query パラメータを全てリダイレクト先にまで forward するような実装、ちょっと正気の沙汰とは思えないかもしれないけど、まぁそういうのは実際あるらしいですし。(ESPN ってサイトがそうらしい)</p>

<p>こうして <strong>Client 側の open redirector が悪用</strong> されて、<strong>query についた Security Token が攻撃者に漏れちゃう</strong> っていうこれ、これが <strong>Covert Redirect</strong> なんです。</p>

<h3>Redirect URI に open redirector !?</h3>

<p>え？なんで redirect_uri に指定するエンドポイントに open redirector が存在すんだよ！って？</p>

<p>えぇ、普通ありえないですよね。</p>

<p>いくら open redirector だらけのザルサイトでも、さすがに redirect_uri に指定するエンドポイントくらいは&hellip;</p>

<p><em>&hellip;いや、P言語ならありえなくもない気がしてきましたけど&hellip;</em></p>

<p>でも Covert Redirect で想定されているケースでは、Client が本来指定する redirect_uri とは別の URL が、攻撃者によって redirect_uri に指定されるというのを想定してます。</p>

<p>で、Server 側では、事前に登録済の redirect_uri と部分一致すれば OK にしちゃうケースが結構あるんです。(domain だけが一致すれば OK とか)</p>

<p>この、<strong>Server 側の甘めの redirect_uri 検証</strong> と、<strong>Client 側が内包する open redirector</strong>、Covert Redirect はこの2つがうまいことくみ合わさって成立するんです。</p>

<p>Server 側では、一度部分一致を許した実装が広く世の中につかわれだしてしまうと、そこの仕様を変更するのはなかなか大変なんで、いざ直そうと思っても数ヶ月から数年の政治的調整作業等が必要になっちゃうかもですね。</p>

<h3>で、どれくらいヤバいの？</h3>

<p><s>実際の影響については、OpenID Connect の仕様策定者の一人でもある <a href="http://www.thread-safe.com/2014/05/covert-redirect-and-its-real-impact-on.html">John Bradley さんが記事書いてる</a>ので、まぁそれを読んでください。</p>

<p>ほんとはちゃんとこれ訳そうと思ったんですが、<a href="http://www.openid.or.jp/blog/2014/05/covert-redirect-and-its-real-impact-on-oauth-and-openid-connect.html">OpenID Foundation Japan から翻訳版</a>まで出たので、もういんじゃね？って空気を感じています。</p>

<p><em>もういんじゃね？って空気を感じながらも、必死に記事を書いてる僕の心境、お察しください&hellip;</em></p>

<p>で、まぁそんな僕の気持ちなんてスルーして翻訳版なり原文なりを要約すると、Covert Redirect によって <strong>access token 漏れるとか、そんな心配は無い</strong>ってことです。</p>

<p>さらに言えば、<strong>それ別に新しい発見でも何でも無いし</strong>って。</p>

<p><em>え？？漏れないの？？発見でもないの？？</em></p>

<p><em>シンガポールウソばっかなの？？</em></s></p>

<h3>ちょっとヤバいかも (?) なケース</h3>

<p>ただ、Authorization Code が漏れることはあり得て、被害者の code を攻撃者が正規 Client に送りつけて来て、攻撃者の Client 上のアカウントと被害者の Server 上の access token が紐づいちゃう、なんてことはあり得なくはないですね。</p>

<p>FB Login つかってるサイトでは、Client 上の既に FB と Connect 済の被害者のアカウントに、攻撃者がログインできちゃうかもしれないですね。</p>

<p>ただこれは、各 Client が state パラメーターってのをつかって CSRF 対策することで防ぐことができます。</p>

<p>state パラメータってのは&hellip;まぁ @ritou 先生のブログを読んでみてください。</p>

<p><a href="http://d.hatena.ne.jp/ritou/20121008/1349695124">http://d.hatena.ne.jp/ritou/20121008/1349695124</a></p>

<h3>結論</h3>

<p><s>Covert Redirect によって <strong>access token 漏れるとか、そんな心配は無い</strong>。</s></p>

<p>ただし悪用される open redirector の実装によっては、<strong>code は漏れることもあり得る</strong>。</p>

<p>code が漏れて CSRF に脆弱な Client と組合わさると、被害者の code が本来紐づくべきでない攻撃者のアカウントと紐づいて、Client 側でアカウントが乗っ取られたりってことはあり得る。</p>

<h3>対策</h3>

<p>これから Server 作るときは、redirect_uri は事前登録必須 + 完全一致にしようね。</p>

<p>(特に外部 ID ログイン目的で) OAuth 2.0 を利用する Client 作ってる人は、state パラメータちゃんとチェックしようね。</p>

<p>以上、仕事に戻ります (>_&lt;)></p>

<p><em>ほんとゴールデンウィーク明け初日から&hellip;</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Y!J API が止まった日 - GlobalSign の Root 証明書切れから学んだこと]]></title>
    <link href="http://oauthjp.github.io/blog/2014/01/30/globalsign-root-cert-expired/"/>
    <updated>2014-01-30T11:28:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/01/30/globalsign-root-cert-expired</id>
    <content type="html"><![CDATA[<p>昨日あたりから、Yahoo! Wallet や YConnect といった、Yahoo! Japan の API にアクセスできなくなったって人、ちらほらいるかもしれませんね。</p>

<p>僕もちょっとそういうケース見かけました。</p>

<p>なんか Yahoo! Japan がポカしちゃったの？とか、まぁ昨日まで健康に動いてたシステムが突然 Yahoo! Japan の API にアクセスできなくなっちゃったんだし、そらそう思うのもムリはない。</p>

<p><strong>が、今回のケース、Yahoo! は全く悪くない！<br>プライバシーフリークはどうかと思うがな！！</strong></p>

<p>では早速、今回起こったことを、振り返ってみましょう。</p>

<h3>Yahoo! API にアクセスできなくなった</h3>

<p>Yahoo! Japan は、<b>yahoo.co.jp</b> 以外にも、CDN 用や API 用など、用途ごとにいくつかのドメインを持ってます。
今回止まったのは、その中の API 用の <b>*.yahooapis.jp</b> というドメイン。</p>

<p>Yahoo! Wallet はよく知らないけど、YConnect だと <b>userinfo.yahooapis.jp</b> っていうドメインがあって、そこにアクセスできなくなった。</p>

<p>ただし、API サーバーが止まったとかそういうのではなく、API にリクエスト投げる側での、SSL エラーによって。</p>

<!-- more -->


<h3>どんな SSL エラーが起こっていたのか？</h3>

<script src="https://gist.github.com/nov/8702799.js"></script>


<p>うん&hellip;なんかエラーでてるね！w</p>

<p><code>SSL certificate problem, verify that the CA cert is OK.</code> ですって！</p>

<p>でもぶっちゃけこれでどこが悪いかとか、何すればいいのかとか、サッパリですよね！</p>

<p>SSL まわりのエラー、たいていいつもそんな感じですよね。</p>

<p>そんなとき、来ました！Yahoo! Japan Tech Blog！</p>

<p><a href="http://techblog.yahoo.co.jp/maintenance/4/">WebAPIやOpenIDでSSLエラーが起きる現象につきまして &ndash; Yahoo! JAPAN Tech Blog</a></p>

<h3>GlobalSign の Root 証明書が、期限切れ！？</h3>

<p>Yahoo! Japan Tech Blog 読んで問題理解できる人どれくらいいるのかはよくわかりませんが、まぁ結論としては、リクエスト元のマシンに bundle されてる GlobalSign の Root 証明書が古かったと。</p>

<p>で、今回某マシン上にあった期限切れ GlobalSign Root 証明書が、これ。</p>

<script src="https://gist.github.com/nov/8703001.js"></script>


<p>僕の手元のマシンにある、最新 (といっても発行されたのはもう数年も前) の GlobalSign Root 証明書はこちら。</p>

<script src="https://gist.github.com/nov/8702954.js"></script>


<p>違いは &ldquo;<b>Not After : &hellip;</b>&rdquo; ってところ。</p>

<p>ちなみにどちらの Root 証明書も、そこに含まれてる公開鍵自体は同じなので、こいつの対になってる秘密鍵も同じ。
公開鍵が同じなのは、こんな感じで確認できる。</p>

<script src="https://gist.github.com/nov/8699469.js"></script>


<p>鍵ペア自体は同じなので、その秘密鍵で署名された証明書達 (GlobalSign の中間証明書達) はどちらの Root 証明書を使っても verify できるし、その中間証明書と紐づく秘密鍵で署名されている Yahoo! 等の事業者が持ってる証明書も、どちらの Root 証明書を使っても verify できる。</p>

<p>というか、できていた。古い方が expire するまでは。</p>

<p>もうちょっと細かい話をすると、例えば <b>userinfo.yahooapis.jp</b> の SSL 証明書を検証する場合だと、大雑把に言うと以下のようなフローになる。</p>

<ol>
<li><b>userinfo.yahooapis.jp</b> の証明書 (<b>*.yahooapis.jp</b> 向けマルチドメイン証明書) を取得</li>
<li>1) の証明書が local にある信頼された証明書リストに含まれるかチェック => 通常は含まれてない</li>
<li>1) の証明書を直接信頼することはできないので、1) の証明書の発行者を検証するため 1) の証明書から発行者情報取得</li>
<li><b>*.yahooapis.jp</b> 証明書発行者の証明書を取得 (GlobalSign の中間証明書)</li>
<li>4) の証明書が local にある信頼された証明書リストに含まれるかチェック => 通常は含まれてない</li>
<li>4) の証明書を直接信頼することはできないので、4) の証明書の発行者を検証するため 4) の証明書から発行者情報取得</li>
<li>GlobalSign 中間証明書発行者の証明書を取得 (GlobalSign Root 証明書)</li>
<li>6) の証明書が local にある信頼された証明書リストに含まれるかチェック => <b>これは含まれてる！！</b></li>
</ol>


<p>で、7) の証明書が valid であれば、1) の証明書も valid になる。</p>

<p>そして、7は valid だった。expire するまでは。</p>

<p>でも、expire しちゃったんですね、このタイミングで。<br>
<b>Not After : Jan 28 12:00:00 2014 GMT</b></p>

<p>日本時間で、28日の夜9時。</p>

<p>この時を境に、古い方の GlobalSign Root 証明書を持ってるマシンでは、*.yahooapis.jp はじめ GlobalSign 発行の SSL 証明書を持ってるいろんなサーバーにアクセスする際に、SSL エラーが発生しだしたんですね。</p>

<p>&hellip;そらまぁ、Root 証明書 Expire してますし、エラーですよね&hellip;</p>

<h3>何が起こっていて、何は起こっていなかったのか。</h3>

<p>起こってたこと</p>

<ul>
<li>*.yahooapis.jp アクセス時の SSL エラー</li>
<li>一部の古い OS 積んでるようなマシンに bundle されてる GlobalSign Root 証明書の期限切れ</li>
</ul>


<p>起こってなかったこと</p>

<ul>
<li>Yahoo! の API サーバーが止まった</li>
<li>*.yahoo.co.jp アクセス時の SSL エラー</li>
<li>Yahoo! Japan 側での SSL 証明書更新、設定変更</li>
<li>その他なんらかの Yahoo! 側での異常</li>
<li>OAuth 関連のエラー</li>
</ul>


<p>ようするに、あれだ。</p>

<p><b>お前らいつまで Debian5 (とか CentOS5 とか) 使ってんだよ</b> と。</p>

<p>まぁちゃんと Root 証明書リストとか必要に応じてアップデートできるんなら別だけど、ムリなんだったらやっぱ新しい OS 使おうぜ、と。</p>

<h3>僕がやったこと</h3>

<p>僕が手を下さないと行けなかったのは、たいしたサーバーじゃなかったし、さくっと <code>/etc/ssl/certs/GlobalSign_Root_CA.pem</code> を vi で書き換えるという荒技を使いましたよ。</p>

<p>まさか Root 証明書を vi で書き換える日が来るなんてね。</p>

<h3>得られた教訓</h3>

<p>ぶっちゃけ、Root 証明書って Expire すんだな、ってしみじみ思いましたよ。</p>

<p>落ち着いて考えると、そらまぁするんでしょうけども。</p>

<p>あと GlobalSign、もちょっと期限切れ直前におっきな声でアラートあげてもいんじゃないかなぁ？</p>

<p>今回の件は、厳密には Y!J も GlobalSign も悪くないし、ある意味天災的なもんかとも思いますが、でもこの件で GlobalSign から証明書買おうとする人は、一時的には減るよね。</p>

<p>だって古い OS からはそのままだと SSL エラーでるようになっちゃったんだもの、GlobalSign 発行の証明書。</p>

<p>他にも証明書発行業者が複数あるなかで、それは結構なビジネスリスクですよね。</p>

<p>まぁどんなキャンペーンやればみんなが Debian5 &ndash;> Debian6 に上げるのか、アイデア無いですけども&hellip;</p>

<br>


<br>


<br>


<p>そして、もう一つ、僕らは重要なことを学んだ気がする。</p>

<p><strong style="font-size: 2.5em">PKI、年取ったな。</strong></p>

<br>


<br>


<br>


<p>ps1.</p>

<p>ちなみに、今後数年はメジャーな Root 証明書が Expire することなさげです。気づいたらその数年あっという間に過ぎてんでしょうけど。</p>

<br>


<br>


<br>


<p>ps2.</p>

<p>タイトルの最初で言っといてなんですが、Yahoo! Japan の API は止まってません。
Tech Blog といい、Yahoo! 側では何の問題も起こしてないのに、いろいろこまめに対応しててすばらしいなと思います！</p>

<p><strong>プライバシーフリークはどうかと思うけどな！</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby & PHP の JOSE 実装で JWE draft v17 に追いつきました]]></title>
    <link href="http://oauthjp.github.io/blog/2013/10/25/jwe-draft-v17/"/>
    <updated>2013-10-25T16:34:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2013/10/25/jwe-draft-v17</id>
    <content type="html"><![CDATA[<p>@nov です。</p>

<p>JWE はまだまだ変わりそうな気がしてしばらく最新仕様への追随を怠っていたのですが、先日<a href="https://github.com/nov/json-jwt/issues/14">こんな pull request</a> をいただいたので、以下の2つのライブラリの JWE 実装を、JWE draft v17 に追随させました。</p>

<ul>
<li><a href="https://github.com/nov/json-jwt">Ruby json-jwt gem</a></li>
<li><a href="https://github.com/nov/jose-php">PHP JOSE</a></li>
</ul>


<p>ところでその pull request 内でのやり取りで知ったのですが、Xbox One ってのが JWE を使ってるらしいですね。</p>

<p>他にも Production で JWE 使ってるとことかあるんでしょうか？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails SessionにCookieStore使った時の問題点]]></title>
    <link href="http://oauthjp.github.io/blog/2013/09/26/rails-session-cookie/"/>
    <updated>2013-09-26T12:45:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2013/09/26/rails-session-cookie</id>
    <content type="html"><![CDATA[<p>今日 @mad_p さんからRT来てたこのツイートに関して、ちょっと調べたのでまとめときます。</p>

<blockquote class="twitter-tweet"><p>Security Issue in Ruby on Rails Could Expose Cookies <a href="http://t.co/JlsXVEn4rZ">http://t.co/JlsXVEn4rZ</a></p>&mdash; Ruby on Rails News (@RubyonRailsNews) <a href="https://twitter.com/RubyonRailsNews/statuses/383002160654336000">September 25, 2013</a></blockquote>


<script async src="http://oauthjp.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<h3>前提条件</h3>

<p>Railsではデフォルトでsessionをcookieにのみ保存して、DBなりmemcacheなりのserver-side storageには何も保存しません。
これがCookieStoreとか呼ばれてるやつです。</p>

<p>この場合のsession cookieは、Railsのsession object (Hash object) をMarshal.dumpしてそれに署名を付けたtokenです。
rails 4では署名付ける代わりに暗号化してるけど、ここで述べる問題に関してはsignedなのかencryptedなのかは関係ないのでその点は無視していいです。</p>

<p>「current user identifierを含むSigned JSONをcookieに入れてるのと同じなので、OpenID ConnectのID Tokenがcookieに入ってるようなもんだと思えばいい」と言えば、#idcon に来たり定期的にOAuth.jp読んだりしてる人には通じるだろうと期待します。</p>

<h3>問題点</h3>

<p>server-sideではstate管理しないので、当然remoteでセッションの無効化はできません。
つまりログアウトしてもsession cookieのtoken自体は無効化されません。</p>

<p>これを確認するには、サイトにログインしてCookie Headerから_foo_cookieってやつ見つけ出してその値をコピーして、CharlesでRequest Cookie Headerの_foo_sessionの値を常にそのコピーした値に書き換えてやるようなRewriteルールを設定してやって、サイトからログアウトしてみるとよいです。
通常server-sideでsession管理してるサービスだとこれでログアウトされるけど、CookieStoreを使ってる場合はこの条件の元ではログアウトしてもログイン状態のままになります。</p>

<p>でもまぁこれはCookieStoreの仕組み上どうしようもないのです。</p>

<p>問題は、session cookieが無効化できないのに、それが永遠に有効であること。
FBとかY!Jとかでやってる「パスワード変更したら既存のsessionが無効になる」ってのはRailsは一切面倒見てくれないので、パスワード変えても漏洩したsession cookieは有効なままです。
なので、ひとたびsession cookieが漏れたら、完全にアウト。
なにやってもアカウント乗っ取られたまんま。永遠に。</p>

<!-- more -->


<h3>解決策</h3>

<p><a href="http://www.bryanrite.com/ruby-on-rails-cookiestore-security-concerns-lifetime-pass/">こちらのブログ記事</a>は2011年のものなので、この問題自体は古くから知られている問題なのだと思います。僕知らなかったけど :p</p>

<p>この記事では以下のように「SSL使えばいいよ」って解決策示されてるけど、SSL化はsession cookieが漏洩する可能性を低くするだけで、「session cookie tokenが永遠に有効である」という状況を回避するものではないです。</p>

<blockquote>
The best and easiest solution is simply to use SSL.  Not just on your login forms and actions, but your entire site, or at least any pages where you have sessions turned on.  With SSL on, the user will not be able to replay your cookies and the entire attack vector is shut down.  Rails 3.1 has a handy force_ssl switch you can use, and you can use something like:
</blockquote>


<p>「session cookie tokenが永遠に有効である」という状況を回避したい場合は、各デベロッパーが <code>session[:expires_at] = 1.hour.from_now</code> とかして session cookie token 自体に有効期限を含めて、それを毎リクエストごとにチェックする必要があります。</p>

<p>OpenID ConnectのID Tokenでも同じ問題が発生しうるので、ID Tokenは有効期限 (exp) をtoken自体に含んでいます。
で、ID Tokenを受け取ったサービスは、署名検証と同時に有効期限もチェックすることで、ID Tokenが漏洩してもなりすましリスクを一定期間内に狭めることができます。
ID Tokenはnonceを含むこともできる (し多分通常はnonce付いてる) ので、onetime tokenとして利用することもできます。
onetime tokenとして扱うと、なりすましリスクはかなり限定的になるでしょう。(ゼロではない)</p>

<p>&hellip;ってことで、RailsのsessionでもOpenID ConnectのID Tokenが含んでるような情報を含むようにして、ID Tokenのverificationと同じような処理をsession受け取った際にやってやれば、それで良いのです。
あとはConnectの仕様さえ読めばOKェ</p>

<p>もしくはCookieStoreの代わりにMemcacheStore使うようにしてもいいです。
sessionをserver-sideで管理するようにさえすれば、この問題はそもそも発生しないですし。
パフォーマンスに影響しますけど。</p>

<h3>捕捉</h3>

<p>Railsには<code>config/initializers/session_store.rb</code>には<code>expires_after</code>ってオプションもあるけど、こちらはあくまでcookieの有効期限であって、悪意の無い通常のユーザーが普通にブラウザでアクセスしてればその期間すぎたらブラウザがcookieを削除してくれるけど、悪意あるユーザーはわざとcookieの有効期限無視してsession cookie送りつけてきたりするので、そこの設定はこのケースでは意味ない。</p>

<p>ログアウト処理で<code>session.delete</code> (<code>session.clear</code>だっけ？ちょっと記憶曖昧) すると、RailsはSetCookieヘッダーを返してブラウザからそのsession cookieを削除しようとします。
が、そのsession cookieを削除するかどうかの決定権は、server-sideではなくclient-sideに存在します。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JWT & JWS 翻訳第一弾リリース]]></title>
    <link href="http://oauthjp.github.io/blog/2013/09/08/jwt-jws-trans-phase1-released/"/>
    <updated>2013-09-08T15:30:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2013/09/08/jwt-jws-trans-phase1-released</id>
    <content type="html"><![CDATA[<p>先日 <a href="http://oauthjp.github.io/blog/2013/08/17/jwt-jws-trans/">JWT &amp; JWS 翻訳プロジェクトスタート &amp; イベント紹介</a> でお伝えした JWT &amp; JWS 翻訳プロジェクトですが、無事翻訳をリリースできました。</p>

<ul>
<li><a href="http://openid-foundation-japan.github.io/draft-ietf-oauth-json-web-token-11.ja.html">JSON Web Token (JWT)</a></li>
<li><a href="http://openid-foundation-japan.github.io/draft-ietf-jose-json-web-signature-14.ja.html">JSON Web Signature (JWS)</a></li>
<li><a href="http://openid-foundation-japan.github.io/draft-ietf-jose-use-cases-03.ja.html">JOSE UseCases</a></li>
</ul>


<p>OpenID TechNight Vol.10 ではこれらの仕様の概要説明も行いましたので、そこでのスライドもここに挙げておきます。
(なぜかいま現在僕の環境ではこちら404 Not Foundになってしまいますが&hellip;)</p>

<ul>
<li><a href="http://slideshare.net/matake/jwt-trans">JWT &amp; JOSE 翻訳</a></li>
</ul>


<p>引き続き JSON Web Encryption (JWE) および OAuth2 JWT Bearer Token Profile も翻訳予定です。(スケジュール未定)
翻訳にご協力いただける方は、<a href="http://twitter.com/nov">@nov</a> まで :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[エンプラグレード OAuth 2.0]]></title>
    <link href="http://oauthjp.github.io/blog/2013/08/30/enterprise-grade-oauth2/"/>
    <updated>2013-08-30T00:27:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2013/08/30/enterprise-grade-oauth2</id>
    <content type="html"><![CDATA[<p>エンプラ、よく分かりません。</p>

<p>エンプラグレード、逆に不安です。</p>

<p>と、まぁそんな内輪ネタはさておき、最近はエンプラで OAuth 2.0 使う事例も増えてるようです。</p>

<p>Google Apps とか導入してたら、OAuth 2.0 とか G+ Sign-in (= OpenID Connect) も使うでしょうし、そんな時にエンプラだと特定のアプリにだけ特定の API へのアクセスを許可したい、なんてこともあるんでしょう。</p>

<p>で、今日それっぽい事例をちょっと見かけたので、response_type=code ってなってるとこを response_type=token に書き換えてやったんですが&hellip;</p>

<p>しっかり access_token 取れて、自分で書いたスクリプトからも API アクセスできましたよ！</p>

<p>特定アプリに限定したつもりでも、別に自分のアカウントと紐づいた access_token 取るだけなら client_secret いらなかったりするのは、当然っちゃ当然なのですが、これがエンプラの世界では許容されるのかされないのかがよく分かんないです。</p>

<p>もし許容されないのだとしたら、特定のアプリに限定するってなら response_typ=code に限定するとかもしないとダメなんでしょうねぇ。</p>

<p>と、Octopress に移行して断然ブログ書きやすくなったので、つらつら書いてみました。</p>

<!-- more -->


<p>== 以下ステマ ==</p>

<p>ん？「エンプラで OAuth 2.0」ってのに興味湧きました？</p>

<p>そんなあなたに <a href="http://openid.doorkeeper.jp/events/5373">OpenID TechNight vol.10</a>！</p>

<p>今回の TechNight は日本最先端のエンプラ ID 厨たちが集うエンプラ特集。</p>

<p>先日アメリカで開催された世界のエンプラ ID 厨が集う <a href="http://www.cloudidentitysummit.com">Cloud Identity Summit (CIS) 2013</a> に参加した日本のエンプラ ID 厨たちが、CIS で感じた世界のエンプラ ID ビジネス／テクノロジーの動向を熱く語ります。たぶん。</p>

<p>てかなんだここ最近のエンプラ ID 厨の盛り上がりは！</p>

<p>エンプラ ID 厨向けの TechNight に既に申し込み100名超えてるとか (((((( ;ﾟДﾟ)))))ｶﾞｸｶﾞｸﾌﾞﾙﾌﾞﾙ</p>

<p>ps.</p>

<p>関西在住でさすがにそんな気軽に関東に来れないって方には、<a href="http://nosurrender.jp/idit2013/">ID &amp; IT 2013</a> の大阪会場に参加するという手も。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JWT & JWS 翻訳プロジェクトスタート & イベント紹介]]></title>
    <link href="http://oauthjp.github.io/blog/2013/08/17/jwt-jws-trans/"/>
    <updated>2013-08-17T19:15:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2013/08/17/jwt-jws-trans</id>
    <content type="html"><![CDATA[<p>先週から, JWxファミリーの以下の3つの仕様書の翻訳を始めています.</p>

<ul>
<li><a href="http://tools.ietf.org/html/draft-ietf-oauth-json-web-token-11">JSON Web Token (JWT)</a></li>
<li><a href="http://tools.ietf.org/html/draft-ietf-jose-json-web-signature-14">JSON Web Signature (JWS)</a></li>
<li><a href="http://tools.ietf.org/html/draft-ietf-jose-use-cases-03">JOSE UseCases</a></li>
</ul>


<p>翻訳資料の公開は <a href="http://openid.doorkeeper.jp/events/5373">OpenID TechNight Vol.10</a> のある 9/4 に予定してます.
<a href="http://openid.doorkeeper.jp/events/5373">OpenID TechNight Vol.10</a> では僕から簡単にこれら各仕様の概要についてもご紹介しますので, 興味ある方はぜひご参加を.</p>

<p>また <a href="https://github.com/openid-foundation-japan/draft-ietf-jose">JWx 翻訳プロジェクト GitHub レポジトリ</a>にはこの他にも JSON Web Encryption や JWT Bearer といった関連仕様も含まれていて, これらも同様に翻訳予定です.
これらの翻訳公開時期はまだ未定ですが, 9/20 の <a href="http://nosurrender.jp/idit2013/">ID &amp; IT 2013</a> に合わせて公開できればなと考えています.
こちらのカンファレンスもエンタープライズ業界で Identity に携わっている人には必見です!</p>

<p><strong>要するに, 9月がアツイ!</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress x GitHub Pagesに移行]]></title>
    <link href="http://oauthjp.github.io/blog/2013/08/17/migration-to-octopress-x-github-pages/"/>
    <updated>2013-08-17T16:00:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2013/08/17/migration-to-octopress-x-github-pages</id>
    <content type="html"><![CDATA[<p>どうもTumblrをブログとして使うの辛いので、Octopressに移行します。</p>

<p>またURL変わっちゃうのは&hellip;直せそうではあるけどちとメンドイ&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Login with Amazon、もう使っても大丈夫！]]></title>
    <link href="http://oauthjp.github.io/blog/2013/06/04/login-with-amazon/"/>
    <updated>2013-06-04T00:00:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2013/06/04/login-with-amazon</id>
    <content type="html"><![CDATA[<p>先日以下のような記事を書きました。</p>


<p><a href="http://oauthjp.github.io/blog/2013/05/30/login-with-amazon">Login with Amazonを使うと、あなたのサイトのユーザーがアカウントハイジャックされる。</a></p>


<p>Login with Amazon 危険ですよ！という記事だったのですが、その後 Login with Amazon のドキュメントに、Token Info API が追加されました。</p>


<p>こちらの Step4 Obtain Profile Information のサンプルコードで、Profile API を叩く前に Token 発行先の Client ID が自身の Client ID と一致することを確認する処理が追加されています。</p>


<p><a href="http://login.amazon.com/website">Web - Login with Amazon Developer Center</a></p>


<p>こちらのより詳細なドキュメントには、Security Considerations の &#8220;Impersonating a Resource Owner in Implicit Flow&#8221; という節で、Token Info API を使わない場合の攻撃例が述べられています。</p>


<p><a href="https://images-na.ssl-images-amazon.com/images/G/01/lwa/dev/docs/website-developer-guide._TTH_.pdf">Login with Amazon - Developer Guide for Websites (PDF)</a></p>


<p>というわけで、Login with Amazon、ドキュメント通り実装すれば安全です :)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Login with Amazonを使うと、あなたのサイトのユーザーがアカウントハイジャックされる。]]></title>
    <link href="http://oauthjp.github.io/blog/2013/05/30/login-with-amazon/"/>
    <updated>2013-05-30T00:00:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2013/05/30/login-with-amazon</id>
    <content type="html"><![CDATA[<p>Amazon が、<a href="http://login.amazon.com">Login with Amazon</a> というAPIおよびそれに付随する JS / iOS / Android SDKs を出してきました。</p>


<p>以下の記事にあるように、OAuth 2.0 ベースで認証連携を行う仕組みです。</p>


<p><a href="http://itpro.nikkeibp.co.jp/article/NEWS/20130530/480782/">Amazonアカウントでアプリやサイトにログイン、「Login with Amazon」を提供開始：ITpro</a></p>


<p>しかし、この Login with Amazon、まさに僕が以前以下の記事で紹介した「Facebook ID でログイン」の間違った実装方法を、公式ドキュメントで推奨してしまっています。</p>


<p><a href="http://www.atmarkit.co.jp/ait/articles/1209/10/news105_2.html">デジタル・アイデンティティ技術最新動向（2）：RFCとなった「OAuth 2.0」――その要点は？ (2/2) - ＠IT</a></p>


<p>この Amazon のドキュメントを読んで (or 「Facebook ID でログイン」を実装した経験を元に) Login with Amazon を自身の Web Site や iOS / Android アプリに導入すると、まず確実にあなたのサイト / アプリのアカウントがハイジャックされるような脆弱性を生むことになります。</p>


<p>@IT の記事からのリンクは OAuth.jp の Posterous -&gt; Tumblr 移行に伴いリンク切れになってしまっているので、ここにも OAuth 2.0 Implicit Flow を認証連携に使うことの危険性を説明するエントリーをリンクしておきます。</p>


<p><a href="http://oauthjp.github.io/blog/2012/02/08/ios-sdk">&#8220;なんちゃら iOS SDK&#8221; でありそうな被害例</a></p>


<p>Facebook の場合は、上の記事にあるような response_type=code+token を iOS / Android アプリでは使えないので、以下の記事末尾にあるような対処法も用意されています。</p>


<p><a href="http://oauthjp.github.io/blog/2012/02/07/oauth-20-implicit-flow">「OAuth 2.0 (Implicit Flow) でログイン」の被害例</a></p>


<p>が、ざっと Login with Amazon のドキュメントを読んだ限り、そのような対処法が一切用意されていない。</p>


<p>これはもう、Login with Amazon を導入した時点で、Amazon 側の対応無しではあなたのサイト / サービスの脆弱性を止めることができないということです。</p>


<p>既に一部有識者より Amazon 側に連絡が行っているようなので、さすがにこのまま Amazon が何の対応も取らないということは考えにくいですが、Amazon が何らかのアップデートを出してくるまで、Login with Amazon を使ってはいけません。</p>


<p>ご注意を。</p>


<p>[追記 2013.06.04]</p>


<p>Login with Amazon の問題点、解決されました。詳しくは以下の記事を。</p>


<p><a href="http://oauthjp.github.io/blog/2013/06/04/login-with-amazon">Login with Amazon、もう使っても大丈夫！</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth 2.0 Core & Bearer Spec (RFC 6749 & RFC 6750) 翻訳公開！]]></title>
    <link href="http://oauthjp.github.io/blog/2013/01/23/oauth-20-core-bearer-spec-rfc-rfc-6749-rfc-67/"/>
    <updated>2013-01-23T00:00:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2013/01/23/oauth-20-core-bearer-spec-rfc-rfc-6749-rfc-67</id>
    <content type="html"><![CDATA[<p>ずいぶん前に「<a href="http://oauthjp.github.io/blog/2011/11/29/oauth-20-core-bearer-spec-76993">OAuth 2.0 Core &amp; Bearer Spec 翻訳公開！</a>」で紹介したように、OAuth 2.0 Core &amp; Bearerは、OpenID Foundation Japanの翻訳WGで翻訳を公開していましたが、2012年に両specがRFC化されたのを受け、今回RFC版も翻訳しました。</p>


<ul><li><a href="http://openid-foundation-japan.github.com/rfc6749.ja.html">The OAuth 2.0 Authorization Framework (RFC 6749)</a></li>
<li><a href="http://openid-foundation-japan.github.com/rfc6750.ja.html">The OAuth 2.0 Authorization Framework: Bearer Token Usage (RFC 6750)</a></li>
</ul>


<p>前回翻訳したdraft版から仕様自体に大きな変更はありませんが、特に</p>


<ul><li>まだdraft版も読んだことが無い人</li>
<li>自社のAPIドキュメントからdraft版の翻訳にリンクしている人</li>
</ul>


<p>などは、RFC版を参照していただければと思います。</p>


<p>いまこれらとは別に、”<a href="http://openid-foundation-japan.github.com/rfc6819.ja.html">OAuth 2.0 Threat Model and Security Considerations (RFC 6819)</a>” という、OAuth 2.0の利用に際して注意すべきセキュリティ上の特徴・注意点などについてまとめたドキュメントを翻訳中です。こちらも翻訳完了次第公開予定。(追記: 2013.01.25 翻訳公開済)</p>


<p>最後に、2/1に東京ミッドタウンのYahoo! Japanオフィスで <a href="http://idcon.doorkeeper.jp/events/2448">#idcon 15th ~ YConnect &amp; Future of Authentication ~</a> というイベントをやります。OAuth 2.0ベースのOpenID次世代仕様であるOpenID Connectについて、世界で初めてOpenID Connect対応API (YConnect) を一般公開したYahoo! Japanの担当者の方の話も聞けるので、興味あったら参加してください :)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Yahoo! JapanがOAuth 2.0 & OpenID Connectに対応]]></title>
    <link href="http://oauthjp.github.io/blog/2012/11/08/yahoo-japanoauth-20-openid-connect/"/>
    <updated>2012-11-08T00:00:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2012/11/08/yahoo-japanoauth-20-openid-connect</id>
    <content type="html"><![CDATA[<p>2011年12月のOpenID Summit Tokyoで、2012年中のOpenID Connect対応を宣言したYahoo! Japanが、本日ついに宣言通りOpenID Connectをサポート開始しました。</p>


<p>もともとOAuth 2.0も対応していなかった（よね？）ので、OAuth 2.0対応も同時リリースです。</p>


<p>まだバグとかあるっぽいけど、何はともあれ世界の大手IdPの中で一番最初にproduction環境でOpenID Connect対応できたのはすばらしい！</p>


<p><iframe scrolling="no" margin src="http://www.slideshare.net/slideshow/embed_code/10433061" frameborder="0"> </iframe></p>


<div style="margin-bottom: 5px;"><strong> <a href="http://www.slideshare.net/tzmtk/openid-summit-tokyo-2011" title="OpenID Summit Tokyo 2011" target="_blank">OpenID Summit Tokyo 2011</a> </strong> from <strong><a href="http://www.slideshare.net/tzmtk" target="_blank">Taizo Matsuoka</a></strong></div>


<p>まだOpenID ConnectのDiscoveryとDynamic Registrationには対応していないので、<a href="https://connect-rp.heroku.com">Nov RP</a>に &#8220;yahoo.co.jp&#8221; とか入力しても使えない状態ですが、それは今後に期待です。</p>


<p>YConnectをちょこっと触ってみて思った要望とかは以下のgistにまとめていってます。</p>


<script src="https://gist.github.com/4031074.js?file=gistfile1.textile"></script>


<p>scopeにopenidが指定されてるのにtoken responseにid_tokenが含まれてないとか、response_type=code+id_tokenの時にcodeとid_tokenがredirect_uriのfragmentではなくqueryについているなどの問題は、ただのバグとして修正すれば良いでしょう。</p>


<p>それ以外でいま気になってる点としては、以下の2点です。</p>


<ul><li>response_type=code+tokenサポートしてもらわないとserver-side componentを持つmobile appから使おうとしたときにいろいろめんどくさいことになっちゃうのはFBとか見てたら明らですが、現状のYConnectは「サーバーサイド」アプリとして登録した場合response_typeにcodeかcode+id_tokenしか指定できないみたいです。これはちょっとやめた方が良い気がします。</li>
<li>あと、id_tokenのsignature algorithmはdefault RS256ということで進んでいるので、YConnectだけがHS256だとまたYAuthとか言われちゃったりしそうですね。</li>
</ul>


<p>それ以外にも、なぜかyahoo.co.jp以外のドメインのメアドはverfiedじゃなくても返してくれる (試しに <a href="mailto:hoge@hoge.com">hoge@hoge.com</a> というメアドを登録してみたらそれ返してきたw）のにyahoo.co.jpのメアドは返してくれないというのも不思議といえば不思議ですが、まぁ社内調整とかいろいろめんどくさいことありそうですし、それが原因でOpenID Connect対応のスケジュールが遅れるくらいならとりあえずそれでもいいのかなとも思います。</p>


<p>Implicitの方でscopeにopenidが指定された時にnonceが必須になってるかとかもチェックしたかったのですが、なんかいま「クライアントサイド」のアプリを登録しようとするとエラーになっちゃうバグがあるようなので、そちらはまた明日にでも。覚えてれば。</p>


<p>OAuth 2.0 draft 0の時点で対応してきたFacebookのように、これからOpenID Connectのbreaking changesに追随するのは大変だと思いますが、引き続きがんばってください！あと、OpenID Connectにbreaking changeがある時に一番大きな声で文句言える立場にいるので、ぜひOpenID Connect Interopにも積極的に参加していただければ :)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSON Web Token (JWT)]]></title>
    <link href="http://oauthjp.github.io/blog/2012/10/26/json-web-token-jwt/"/>
    <updated>2012-10-26T00:00:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2012/10/26/json-web-token-jwt</id>
    <content type="html"><![CDATA[<p>@novです。</p>


<p>個人的に最近OAuth 2.0よりJWT (というかJWS) を利用するシーンが多く、毎回同じ説明するのもめんどくさいのでブログにまとめるかと思い、どうせならOAuth.jpに書くかということで、こんな記事を書いております。</p>


<p>（そろそろJWTとJWSは、OpenID Foundation Japanの翻訳WGで翻訳するべき？）</p>


<h3>JSON Web Token (JWT) とは、JSONをトークン化する仕組み。</h3>


<p>元々はJSONデータにSignatureをつけたりEncryptionする仕組みとして考えられたものの、Signature部分がJSON Web Signatue (JWS)、Encryption部分がJSON Web Encryption (JWE) という仕様に分割された。</p>


<p>それぞれ2012年10月26日現在の最新仕様はこちら。</p>


<p>（JWTとJWSは既にだいぶ仕様が固まってきているものの、まだIETFのInternet-Draftなので注意）</p>


<ul><li><a href="http://tools.ietf.org/html/draft-ietf-oauth-json-web-token-04">JSON Web Token (JWT, draft 04)</a></li>
<li><a href="http://tools.ietf.org/html/draft-ietf-jose-json-web-signature-06">JSON Web Signature (JWS, draft 06)</a></li>
<li><a href="http://tools.ietf.org/html/draft-ietf-jose-json-web-encryption-06">JSON Web Encryption (JWE, draft 06)</a></li>
</ul>


<p>JWEはまだ実際に使うケースが無いので、ここでは説明しない。</p>


<p><b><i>追記:</i></b><br><i>draft versionが違いますが、<a href="http://openid-foundation-japan.github.io/draft-ietf-oauth-json-web-token-11.ja.html">JWT仕様翻訳版</a>と<a href="http://openid-foundation-japan.github.io/draft-ietf-jose-json-web-signature-14.ja.html">JWS仕様翻訳版</a>もご参考に。</i></p>


<h3>Signed JWT</h3>


<p>JWS使ってSignatureつけられたJWT。</p>


<p>HeaderとPayloadとSignatureという3つのセグメントから構成される。</p>


<p>Headerは署名アルゴリズムなどを含むJSONを、URL-safe Base64 Encodingした文字列。</p>


<p>Payloadは実際に送信したいJSONデータそのものを、URL-safe Base64 Encodingした文字列。</p>


<p>Signatureは、HeaderとPayloadを &#8220;.&#8221; で連結した文字列に対して、Headerに指定されたアルゴリズムで署名をして、その署名をURL-safe Base64 Encodingした文字列。</p>


<p>サンプルは<a href="http://tools.ietf.org/html/draft-ietf-oauth-json-web-token-04#section-3.1">JWT Spec Section 3.1</a> (draft 04の場合) を読むこと。</p>


<p><b><i>追記:</i></b><br><i>draft versionが違いますが、<a href="http://openid-foundation-japan.github.io/draft-ietf-oauth-json-web-token-11.ja.html#ExampleJWT">JWT仕様の翻訳版の該当箇所はこちら</a>。</i></p>


<h3>Signature Algorithms</h3>


<p>サポートされているアルゴリズムは、これまた別仕様のJSON Web Algorithm (JWA) で規定されている。</p>


<ul><li><a href="http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-06">JSON Web Algorithm (JWA, draft 06)</a></li>
</ul>


<p>JWA Section 3 (draft 06 現在) では、JWSの署名アルゴリズムとして以下のアルゴリズムがサポートされている。</p>


<ul><li>HMAC-SHA256</li>
<li>HMAC-SHA384</li>
<li>HMAC-SHA512</li>
<li>RSA-SHA256</li>
<li>RSA-SHA384</li>
<li>RSA-SHA512</li>
<li>ECDSA-SHA256</li>
<li>ECDSA-SHA384</li>
<li>ECDSA-SHA512</li>
</ul>


<p>正直ECDSA (楕円曲線暗号) ってのは僕もよく理解していなし、Ruby以外で使いたい場合にどう書けばいいかとかさっぱりなので、個人的には共通鍵使う場合はHMAC、公開鍵使う場合はRSAを使っている。</p>


<p>例えば、こんな感じ。</p>


<ol><li>認証サーバーからiOSアプリに渡すデータには (認証サーバーの秘密鍵を使って) RSA-SHA256使って署名</li>
<li>iOSアプリからリソースサーバー (認証サーバーとは別) に渡すJSONには、Step 1で認証サーバーに署名されたJWSに入ってる共通鍵を利用してHMAC-SHA256使って署名</li>
<li>リソースサーバーはiOSアプリからStep 1で発行されたJWSとStep 2で発行されたJWSを同時に受け取って、Step 1のJWSを検証した後そこに含まれてる共通鍵でStep 2のJWSを検証</li>
<li>リソースサーバーはレスポンスに (リソースサーバーの秘密鍵を使って) RSA-SHA256使って署名</li>
</ol>


<p>（iOSではSHA256よりSHA1の方が使いやすいらしく、HMAC-SHA1とRSA-SHA1使ってたりすることもあるが..）</p>


<h3>各言語のライブラリ (情報求む！)</h3>


<ul><li><span>Ruby </span><a href="https://github.com/nov/json-jwt">json-jwt</a></li>
<li><span>Python </span><a href="https://github.com/rohe/pyjwkest">pyjwkest</a></li>
<li><span>Java </span><a href="https://bitbucket.org/nimbusds/nimbus-jose-jwt/wiki/Home">Nimbus JOSE+JWT</a></li>
<li><span>PHP </span><a href="https://github.com/ritou/php-Akita_JOSE">PHP Akita JOSE</a><span>,</span><span> </span><a href="https://github.com/nov/jose-php">JOSE</a></li>
<li><span>Perl </span><a href="https://github.com/xaicron/p5-JSON-WebToken">JSON::WebToken</a></li>
</ul>


<p>Rubyのjson-jwtとPHPのJOSE (2番目の方) は僕が作ってるので、README (希望としてはSpecも) とか読んでも使い方分からない場合は僕に直接聞いていただければと思います。</p>


<p>それ以外はあんまり詳しく使い方知らないので、使い方についてはドキュメント (あれば) 読むなりそれぞれの作者に直接聞いてください。それぞれの作者に紹介するくらいならできます。</p>


<p>node.jsとかObjective-CにもJSON Web Tokenのライブラリは見かけるのですが、HMACしかサポートしてなかったりしていまいち使えそうなの見つけられてません。（多分Google Wallet APIでHMACなJWSが使われてるので、それだけサポートしたライブラリがあるんだと予想）</p>


<p>ここにない言語でRSAもサポートしてるライブラリご存知でしたらお教えいただけるとうれしいです。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Facebookが新たなAccess Token Introspection APIを出したようです]]></title>
    <link href="http://oauthjp.github.io/blog/2012/10/16/facebookaccess-token-introspection-api/"/>
    <updated>2012-10-16T00:00:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2012/10/16/facebookaccess-token-introspection-api</id>
    <content type="html"><![CDATA[<p>今朝fb_graphにこんな要望が来てて知ったのですが、Facebookが新たなAccess Token Introspection APIを出したようです。</p>


<p><a href="https://github.com/nov/fb_graph/issues/269">Adding support for /debug_token endpoint · Issue #269 · nov/fb_graph</a></p>


<p>こんなリクエストを送ると</p>


<p><a href="https://gist.github.com/3896829"><a href="https://gist.github.com/3896829">https://gist.github.com/3896829</a></a></p>


<p>こんなレスポンスが帰ってくる、と。</p>


<p><a href="https://gist.github.com/3896826"><a href="https://gist.github.com/3896826">https://gist.github.com/3896826</a></a></p>


<p>&#8220;data&#8221; ってなんやろとかApp Token無いと使えへんのメンドイなとか思ったりはしますが、ちゃんと別のClientに発行されたAccess Tokenを<code>input_token</code>として送るとエラーが帰ってくるし、Success Responseにはscopeとかissued_atとかも付いてくるので、いろいろと使い勝手は良さそうですね。まぁ例のごとく完全に独自仕様ですが。</p>


<p>って実際にGraph API Explorerで試したら、issued_at返ってこないですが（謎</p>


<p>オフィシャルドキュメントはこちら。</p>


<p><a href="https://developers.facebook.com/docs/howtos/login/debugging-access-tokens/">Debugging Access Tokens and Handling Errors</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello OAuth 2.0, Good-bye OAuth 1.0!]]></title>
    <link href="http://oauthjp.github.io/blog/2012/10/13/hello-oauth-20-good-bye-oauth-10/"/>
    <updated>2012-10-13T00:00:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2012/10/13/hello-oauth-20-good-bye-oauth-10</id>
    <content type="html"><![CDATA[<p>おっす、おらOAuthおにーさん！</p>


<h3>ついにOAuth 2.0 CoreとBearerがそれぞれRFCに！！！</h3>


<p><a href="http://tools.ietf.org/html/rfc6749">RFC 6749 - The OAuth 2.0 Authorization Framework</a></p>


<p><a href="http://tools.ietf.org/html/rfc6750">RFC 6750 - The OAuth 2.0 Authorization Framework: Bearer Token Usage</a></p>


<p>このブログができたころには既にOAuth 2.0のdraftが出てたのですが、そういえばOAuth.jpっていつできたんだっけ？と思ってみて見ると…</p>


<p><a href="http://oauthjp.github.io/blog/2010/07/04/oauthjp">OAuth.jpを立ち上げました。 - OAuth.jp</a></p>


<p>2010年7月！</p>


<p>そんな長い間やってたのか。。</p>


<p>FB Graph APIが出たのが2010年4月なので、OAuth 2.0の実装がでてからかれこれ2年半ほどでようやくRFCになった訳ですね。</p>


<h3>さて、RFC化された直後の国内の反応ですが..</h3>


<blockquote class="twitter-tweet">
<p>「Twitterさん、もう、OAuth 1.0古いっすよ。」って誰か言え！オレは言わない！</p>
<div><a href="https://twitter.com/ritou/status/256932933263294464">October 13, 2012</a></div>
</blockquote>


<blockquote class="twitter-tweet">
<p>twitterさん、もう OAuth 1.0 古いですよ。正式に deprecate されました。 RT @<a href="https://twitter.com/ritou">ritou</a>: 「Twitterさん、もう、OAuth 1.0古いっすよ。」って誰か言え！オレは言わない！</p>
<div><a href="https://twitter.com/_nat/status/256945174251442176">October 13, 2012</a></div>
</blockquote>


<blockquote class="twitter-tweet">
<p>OAuth 1.0はもぅ古いので、Twitterの関係者は至急おっおーっす学会長の私に連絡してください。日本語の分からない本国のバカどもは話にならないので、Twitter Japanの関係者に限ります。キリッ！ノブッ！</p>
<div><a href="https://twitter.com/IdentityNobuwo/status/256951736630132736">October 13, 2012</a></div>
</blockquote>


<p>そうなんです。OAuth 2.0 Coreには、こう書いてあるんですね。</p>


<blockquote class="posterous_short_quote">
<div>This specification replaces and obsoletes the OAuth 1.0 protocol described in RFC 5849.</div>
</blockquote>


<p>OAuth 1.0サポートしてるTwitter APIとかOpenSocial採用してるプラットフォーム各社とか、どうなるんでしょうね？</p>


<p>そういえばそれ以外にも @ritou がまたブログ記事書いてましたね。</p>


<p><a href="http://d.hatena.ne.jp/ritou/20121013/1350128492">RFCになったOAuth 2.0を使ってGoogleはどれだけパスワード入力を減らせるのか - r-weblife</a></p>


<p>OAuthおねーさんの次回作が気になるところです。</p>

]]></content>
  </entry>
  
</feed>
