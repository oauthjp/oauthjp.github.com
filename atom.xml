<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[OAuth.jp]]></title>
  <link href="http://oauthjp.github.io/atom.xml" rel="self"/>
  <link href="http://oauthjp.github.io/"/>
  <updated>2016-04-02T18:40:07+09:00</updated>
  <id>http://oauthjp.github.io/</id>
  <author>
    <name><![CDATA[Nov Matake]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Microsoft MVP Award を受賞しました]]></title>
    <link href="http://oauthjp.github.io/blog/2016/04/02/microsoft-mvp/"/>
    <updated>2016-04-02T18:02:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/04/02/microsoft-mvp</id>
    <content type="html"><![CDATA[<p>2016年度の Microsoft MVP Award を受賞させていただきました。</p>

<p>これもひとえにあんどーパパのおかげです。パパは(2007年4月 Microsoft 入社)[<a href="https://blogs.technet.microsoft.com/junichia/2016/04/01/%E5%98%98%E3%81%AE%E3%82%88%E3%81%86%E3%81%AA%E6%9C%AA%E6%9D%A5%E3%81%AE%E5%A7%8B%E3%81%BE%E3%82%8A%E3%81%A7%E3%81%99%EF%BC%81/">https://blogs.technet.microsoft.com/junichia/2016/04/01/%E5%98%98%E3%81%AE%E3%82%88%E3%81%86%E3%81%AA%E6%9C%AA%E6%9D%A5%E3%81%AE%E5%A7%8B%E3%81%BE%E3%82%8A%E3%81%A7%E3%81%99%EF%BC%81/</a>]ということなので、僕が新卒になったころからの MS エバンジェリストってことっすよ。</p>

<p>通常であればにいさんと呼びたいところですが、今回新たな MVP も産んだことですし、Identity 業界の慣習にならって積極的にパパ呼ばわりしていきたいとおもいます。</p>

<p>また、Award のカテゴリーは &ldquo;Enterprise Mobility&rdquo; ってなってたので、ふぁらおぅにぃさんが本当のにぃさんになった感じですよね。(年齢的な意味ではなく)</p>

<p>AzureAD &amp; ADFS の Connect サポート、Graph API、Windows 10 の FIDO サポートあたりが興味あるとこなんで、その辺りでいろいろ遊びながらこのブログとかで記事書いていければいいなと思います。</p>

<p><a href="https://code.visualstudio.com/">Visual Studio Code</a> で。</p>

<p>とりあえず Microsoft Edge の FIDO 実装で遊ぶためにも、Surface Pro4 を買わないとですね！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[独立 & YAuth.jp 設立]]></title>
    <link href="http://oauthjp.github.io/blog/2016/03/26/yauth-dot-jp-founded/"/>
    <updated>2016-03-26T12:27:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/03/26/yauth-dot-jp-founded</id>
    <content type="html"><![CDATA[<p>昨日を最終出社日として、GREE 正社員生活を終えました。4月からは独り会社作って独立します。</p>

<p>転職じゃなくて独立で、契約形態変えて GREE さんともお仕事する可能性十分あるので、あまり退職っていう実感はないのですが、これもまぁ一応退職エントリー&hellip;ですかね？</p>

<p>新会社での業務内容としては、Identity まわりのコンサルとか技術支援とかをメインでやる予定。</p>

<p>ありがたいことにすでに数件4月以降の仕事依頼もいただいており、気軽に新しい案件受けづらい状況なのですが、もし興味あれば<a href="mailto:nov@yauth.jp">ご連絡いただければ</a>と思います。</p>

<p>ID の専門家として仕事しつづけるとしたら、1社に閉じるより数社の仕事同時にこなす方がいいんじゃないかとか、そういう流動的に動ける人もこの国に数人いたほうがいいんじゃないかとか、そういうのが独立のきっかけとしてあるので、いろんな会社のお話聞いてみたいです。</p>

<!-- more -->


<p>ちなみに、新しく作る会社は <a href="http://yauth.jp">YAuth.jp 合同会社</a> という名前です。「本当にその名前でやるの？」とか言われたりもしましたが、結構響きも好きなんですよ。YAuth.jp、いい名前でしょ？</p>

<p>現在絶賛法人登記手続き中ですが、きっと来週頭には法人番号がもらえるはず！来週中は法務局とか税務署とかいろいろ行く予定！税務署ってどこにあるんすか、いったい！</p>

<p>ということで、今後は OAuth.jp 共々、<a href="http://yauth.jp">YAuth.jp</a> もよろしくお願い致しますm<em> </em>m</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[「OAuth 認証」を定義しよう]]></title>
    <link href="http://oauthjp.github.io/blog/2016/02/25/oauth-authentication/"/>
    <updated>2016-02-25T11:27:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/02/25/oauth-authentication</id>
    <content type="html"><![CDATA[<p>「OAuth 認証」って言葉が出てくると、「認証と認可は違う」とか言い出す人が出てきて、大体の場合「OAuth 認証」言ってた人たちがやりたいことの話とはズレた議論が始まるので、もういっその事「OAuth 認証」とは何かを定義してみましょうかね。</p>

<h2>「OAuth 認証」で Relying Party (RP) がやりたかったこと</h2>

<p>RP (OAuth Client) は、ブラウザの前にいる人を、認証したかったんですよね？</p>

<p>もう少し正確にいうと、ブラウザの前にいる Entity が、RP 側で把握しているどの Identity と紐付いているか、というのを知りたかったんですよね？</p>

<p>いきなり Entity とか Identity とかいう専門用語が出てきてアレですが、そのあたりのことは先日の OpenID TechNight #13 でもお話ししたので、以下のスライドの Entity・Identity・Authentication・Authorization のあたりのページを見てください。</p>

<iframe src="http://oauthjp.github.io//www.slideshare.net/slideshow/embed_code/key/Lw5OsZp5n6qwXb" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>


<p>で、あるサービスが End-User を認証したいって思った時って、普通は当該サービスが事前に当該 Entity に対して ID と Password を登録させて Identity Record (「サービスアカウント」と言ってもいい) を作成し、後日当該 Entity が当該サービスに訪れた際は登録済みの ID と Password を提示させて当該 Entity に紐づく Identity を確定するわけです。</p>

<p>でも Identity Federation (上記スライドでは「ID 連携」と表現している) という手法を使うと、外部のサービス (Identity Provider, IdP) の Identity を当該サービス (Relying Party, RP)の Identity と紐付けて管理することで、End-User から直接パスワードを預からなくても、ブラウザの前にいる Entity (= End-User) に紐づく IdP 側の Identity に紐付いた RP 側の Identity を確定できるので、結果として End-User に紐づく RP 側の Identity を確定することができます。</p>

<p>で、どうやって IdP と RP がそれぞれに管理している Identity を紐付けるのか、というのが、Federation Protocol の肝なわけですが、「OAuth 認証」というのはその一種です。</p>

<!-- more -->


<h2>「OAuth 認証」とは</h2>

<p>OAuth 自体は「End-User が OAuth Server に管理を委託している Resource に対して、OAuth Client がアクセスすることを許可する方法」を標準化した OAuth Core (RFC 6749) と、「End-User の許可を得た OAuth Client が実際に OAuth Server 上の Resource にアクセスする方法」を標準化した OAuth Bearer (RFC 6750) を核とした標準仕様群なので、Federation Protocol に必要な「IdP 上の Identity をどう表現し RP に伝えるか、という仕組み」は持っていません。</p>

<p>しかし、「IdP 上の Identity をどう表現し RP に伝えるか、という仕組み」は別に標準化されていなくてもいいんですよ。どうせみなさんほとんど Facebook Login しかしないんだから。</p>

<p>っていうことで、「IdP (OAuth Server) 上の Identity 情報にアクセスする API へのアクセス権だけを OAuth Protocol に従って RP (OAuth Client) に渡しましょう。Identity 情報にアクセスする API は、まぁ JSON に user_id とか含めりゃだいたい動くでしょ。」っていうノリでできあがったのが、「OAuth 認証」です。</p>

<p>標準化された方法ではないけども、Identity Federation はしてますね。</p>

<p>Identity 情報にアクセスする API って各 IdP で仕様バラバラなんですけど、みんな OAuth 使ってアクセス権やり取りするってところは共通です。</p>

<p>実際には Identity Federation に必要な多くの部分がそのバラバラな部分に依存したりしてるわけで、とても標準的な Federation Protocol とは呼べない代物ですけども。</p>

<p>ということで、「OAuth 認証」の定義としては、</p>

<p><b>「RP が、IdP の提供する任意の Identity 情報取得 API に対して OAuth Protocol に従ってアクセスすることで、Identity Federation を行う方法の総称」</b></p>

<p>とかでいかがでしょうか？</p>

<p>ちなみに、OpenID Connect においては、UserInfo API ってのが標準化された Identity 情報取得 API で、Identity 情報に加えて IdP 側の認証セッション情報をやり取りする手段が ID Token です。</p>

<p>Identity Federation に必要な情報の多くの部分は実は IdP 側の認証セッションに関する情報だったりするわけですが、その辺の話は、また今度にしましょう。</p>

<h2>補足) 結局「認証か認可か」という議論は何だったのか？</h2>

<p>さて、OAuth は「End-User が OAuth Server に管理を委託している Resource に対して、OAuth Client がアクセスすることを許可する方法」でしたね。</p>

<p>「End-User が OAuth Client 上の Resource へのアクセス権を持つかどうかを、OAuth Client が判断する方法」ではなくて。</p>

<p>普通「認証か認可か」について議論するときって、以下のように主語と目的語が揃っていて、動詞だけが違う条件の元で議論すると思うんですよ。</p>

<ul>
<li>IdP authenticates End-User</li>
<li>IdP authorizes End-User&rsquo;s access (to Resource on IdP)</li>
</ul>


<p>でも「OAuth を利用した認証」と「OAuth における認可」っていう比較をする時って、以下の2つを比較してませんか？</p>

<ul>
<li>RP authenticates End-User (relying on IdP&rsquo;s help)</li>
<li>End-User authorizes RP&rsquo;s access (to Resource on IdP) / IdP authorizes RP&rsquo;s access (to Resource on IdP, on behalf of End-User)</li>
</ul>


<p>いや、それ比較してもいいんですよ。いいんですけど、よほどの前提知識がない限り、主語と目的語と動詞が全部違う2つのコンテキストを比較して、意味のある結論を導き出すことは困難なんじゃないかと思うんです。</p>

<p>本当に「認証か認可か」って比較をするのであれば、以下のコンテキストで比較して意義ある答えにたどり着くようなコンテキストで議論したほうがいいよなぁ、と。</p>

<ul>
<li>Service X authenticates End-User Y</li>
<li>Service X authorizes End-User Y&rsquo;s access (to Resource Z)</li>
</ul>


<p>なので、「OAuth と OpenID Connect」の比較の流れで出てくる「認証と認可」っていう議論に関しては、生暖かく見守っております :p</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenID Connectはそんなに大変かね？]]></title>
    <link href="http://oauthjp.github.io/blog/2016/02/24/is-openid-connect-far-from-oauth2/"/>
    <updated>2016-02-24T11:14:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/02/24/is-openid-connect-far-from-oauth2</id>
    <content type="html"><![CDATA[<p><a href="http://qiita.com/TakahikoKawasaki/items/f2a0d25a4f05790b3baa">OAuth 2.0 + OpenID Connect のフルスクラッチ実装者が知見を語る &ndash; Qiita</a> ってのになんかフォローアップしろよ的なのが来たので。</p>

<p>ざっと読んだ感想としては、「OpenID Connect の OPTIONAL な機能全部実装したら、そら大変ですね」という感じ。（Authlete に関しては、OpenAM みたいな感じで使われる、OpenAM よりはるかに簡単に使える代わりに有料の何かなんだろうな、というイメージです）</p>

<h2>OAuth は必要なのか？</h2>

<ul>
<li>Basic 認証は死んだ。</li>
<li>ユーザー単位での API のアクセスコントロールがしたいです。</li>
</ul>


<p>っていう前提で話すると、OAuth 以外まともな選択肢が無いんじゃないでしょうか。</p>

<p>OAuth の各種 Extension (RFC 6749 &amp; 6750 以外にいろいろある) に関しては、適宜必要なのを実装すればいいんだけど、どれが必要なのかを選ぶのが大変なのは事実で、そこのベストプラクティスとかユースケースごとのガイドラインは今後の課題。IETF OAuth WG の中の人たちも、それは認識している。</p>

<h2>「OAuth 認証」とは</h2>

<p>OAuth は「End-User (に信頼された OAuth Server) が OAuth Client のアクセス権限をコントロールする」というコンテキストにおいての標準化されたプロトコルであって、「Identity Provider (IdP) が End-User を認証した結果を受け取って、Relying Party (RP) が (IdP への信頼を元に) End-User を認証する」というコンテキストで OAuth を使うユースケースが「OAuth 認証」と呼ばれるやつです。</p>

<p>後者のコンテキストで、OAuth は何も標準的な仕様を定めてはいません。</p>

<p>IdP が End-User を認証した結果を RP に伝える方法 (ID Token 相当) や、そのコンテキストで求められることが多い認証されたユーザー属性情報の取得方法 (UserInfo 相当) については、完全に各 Platform が独自に API を提供してるだけなので、そういう意味では「OAuth 認証」ってのは「オレオレ Connect」みたいなもんですね。</p>

<p>まぁでも「オレオレ OAuth」の上で「オレオレ Connect」やる「JWT 認証」よりはマシなんじゃないかなっていう気はします。</p>

<!-- more -->


<h2>OpenID Connect 関連仕様、多すぎ問題</h2>

<p>うん、OpenID Connect の仕様群は、全部読むと大変ですね。</p>

<p>Authlete の人も Dynamic Client Registration は読む必要無かったと思うけど、読む必要あるかどうかを判断するのがまず大変。</p>

<p>そして、そこは OAuth の各種 Extension を全部理解して使いこなすのも、同じように大変。</p>

<p>OAuth の各種 Extension を読まずに OAuth 実装して、その状態から OpenID Connect 仕様を全部実装しようとしたら、一回全部作り直しになってもしょうがないかなとは思います。</p>

<p>でも、自分で IdP 実装する人は、基本 <a href="http://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect Core 1.0</a> だけ読めば十分ですよ。それでも十分大変だけど。</p>

<p>RP 実装する人は、その RP が Web サイトなら <a href="http://openid.net/specs/openid-connect-basic-1_0.html">OpenID Connect Basic Client Implementer&rsquo;s Guide 1.0</a> だけで十分。</p>

<p>Native アプリなら&hellip;Native アプリのケースって Backend Server 含めると 4-party ですし、3-party を想定して策定されてる OAuth や OpenID Connect の範囲を超えているので、今後の課題ですかね。（そういや <a href="http://labs.gree.jp/blog/2015/12/14831/">OAuth for Native Apps</a> てのを先日書きました）</p>

<p>で、ちょっと話がそれましたが、結論としては、IdP 作るのは RP より大変で、Authlete みたいなの作るのは IdP 作るよりさらに大変、というだけのことなのではないでしょうか。</p>

<p>必要な Extension については具体的なユースケース聞かない限りなんとも言えないので、そこは Authlete 的に「とりあえず実装する」という方針だと、Authlete が大変なのはよくわかります。</p>

<p>一方で、ほとんどの IdP 実装は、既存 OAuth 実装に scope=openid と ID Token だけ追加実装すれば十分じゃね？とも思います。</p>

<p>具体的なユースケース聞かない限りなんとも言えないのですが。</p>

<h2>response_type 増えてる問題</h2>

<p>これはまぁ RFC 6749 策定時には「実装はあるけどまだ標準化するレベルになかった」ものが、OpenID Connect の時代には標準化レベルに達していて、OpenID Foundation が Connect 策定するついでに <a href="http://openid.net/specs/oauth-v2-multiple-response-types-1_0.html">OAuth 2.0 Multiple Response Type Encoding Practices</a> にまとめた、っていうのが実際のところ。</p>

<p>「現実の OAuth がとっくに RFC 6749 を超えていたのだよ」という感じでしょうか。</p>

<p>みんなが当時 IETF OAuth WG のスピード感に満足していれば、<a href="http://openid.net/specs/oauth-v2-multiple-response-types-1_0.html">OAuth 2.0 Multiple Response Type Encoding Practices</a> は IETF 側でまとめられていたよね、というのもあるし、RFC 6749 があそこまで時間かかるんだったら、response_type=code+token は Core に入れられたよね、ってのもあるにはあるけど、いまさら言ってもしゃーないすね。</p>

<h2>クライアントアプリケーションのメタ情報、多すぎ問題</h2>

<p>えっと、そもそも、Dynamic Client Registration、きっと使わないです。</p>

<p>Dynamic Client Registration を検討してるって人がもしいたら、まずは <a href="https://tools.ietf.org/html/rfc7636">OAuth PKCE</a> ってので代用できないか検討するがいいかと思います。</p>

<p>Dynamic Client Registration をセキュアにやる方法は、OAuth WG と OpenID Connect の関連仕様を全部読んでもまだ足りないはず。</p>

<p>それでも Dynamic Client Registration したいんだ！って人は&hellip;PKI まわりの技術一通り把握したら、使いこなせる&hellip;のかな&hellip;？</p>

<p>という前提の元で Dynamic Client Registration で登録された Client を Public / Confidential どちらにするかという話をすると、grant_types に implicit 以外が含まれてたら Confidential ですね。</p>

<p>そもそも Dynamic Client Registration で Public Client 登録する意義がよくわかんないですけど。</p>

<h2>Unsigned JWT 作れない問題</h2>

<p>UserInfo Response を Unsigned JWT にするってのも、きっと使わないです。</p>

<p>署名の無い URL-safe Base64 Encoded な JSON (= Unsigned JWT) とか、素の JSON より decode がちょっとめんどいっていう以外に、どんな意義があるというのでしょうか？</p>

<p>UserInfo Response を Singed and/or Encrypted JWT にするってのも、まず使わないでしょう。</p>

<p>「Aggregated Claims が使いたいんだ！」っていう人は検討してもいいですが、「Aggregated Claims って何？」っていう人は、きっと Aggregated Claims も使うこと無いでしょう。</p>

<h2>redirect_uri は必須か？</h2>

<p>これに関しては、<a href="http://openid.net/specs/openid-connect-core-1_0.html#TokenRequestValidation">Token Request Validation</a> では redirect_uri の省略を許しつつも Authentication Request の Section では REQUIRED としか書いてない Connect Core が、読みづらいですね。</p>

<p>Connect でも OAuth との整合性を保つため redirect_uri が1つの場合は省略可能としてもいいですが、OAuth Server のポリシーとして Authorization Request に redirect_uri を必須にしても良いです。</p>

<p>scope=openid の有無でそこが切り替わるっていう実装が、一番わかりづらいんじゃないでしょうか？</p>

<h2>さいごに</h2>

<p>OpenID Connect にしろ OAuth にしろ、何が大変って IdP / Server 向けのオフィシャルなガイドラインが皆無なことですよね。（最近の Google Identity Platform のドキュメント群はなかなかいい感じだと思うけど）</p>

<p>その影響で、関連仕様全部読んで必要なのだけピックアップする仕様理解力か、Core だけ読んで他全部無視するスルー力のどちらかが必要になる。</p>

<p>Qiita の記事を読む限り、Authlete では RP が幅広い OPTIONAL な機能を選択できるようなので、Authlete 実装者は関連仕様全部読む必要あるでしょうし、それら全部実装して Authlete 利用者が必要な機能選択してるんだとしたら、Authlete 利用者にもなかなか高度な仕様理解を求められそうです。</p>

<p>どういうユースケースの場合はどういう OPTIONAL が選択された、っていうノウハウが Authlete に溜まっていくと、そこは Authlete の強みになるんでしょうね。</p>

<p>特に Consumer 向けサービスやってる事業者さん向けには、そういうニーズはありそうな気がします。</p>

<p>OpenID Foundation にもそういうユースケース集作るモチベーションはあると思うので、そういうところで Authlete が活動するメリットを見出せると良いのでしょうね。</p>

<p>あと、どこかのタイミングで「Authlete では結局一度も選択されなかった機能一覧」とか提供してもらって、それらがどういうときに使われるのかを議論するのとかおもしろそう :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth IdP Mix-up Attack - part II]]></title>
    <link href="http://oauthjp.github.io/blog/2016/01/25/oauth-idp-mix-up-attack-part-ii/"/>
    <updated>2016-01-25T15:59:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/01/25/oauth-idp-mix-up-attack-part-ii</id>
    <content type="html"><![CDATA[<p><a href="http://oauth.jp/blog/2016/01/12/oauth-idp-mix-up-attack/">OAuth IdP Mix-Up Attack とは？</a> のつづき。</p>

<p>OAuth ML上で、以下のどちらを採用すべきかについての議論が収まる気配のない昨今です。</p>

<ul>
<li><a href="http://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation">http://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation</a></li>
<li><a href="http://tools.ietf.org/html/draft-sakimura-oauth-meta">http://tools.ietf.org/html/draft-sakimura-oauth-meta</a></li>
</ul>


<p>そんななか、もうちょっとややこしいというか致命的なケースが出て来ました。</p>

<ul>
<li><a href="http://nat.sakimura.org/2016/01/22/code-phishing-attack-on-oauth-2-0-rfc6749/">Code phishing attack on OAuth 2.0 [RFC6749] | .Nat Zone</a></li>
</ul>


<p>&ldquo;Mix-up Attack&rdquo; っていうやつの話をしてたはずが、いつのまにか &ldquo;Code Phishing Attack&rdquo; って名前になっててもはや2つの違いがよく分かんなくなってきますが、ブログ記事中では「フィッシングメールをRP Developerに送って、Client DeveloperにToken Endpointを書き変えさせる」というパターンが例示されています。</p>

<p>いや、そんなんに騙されるやつおらへんやろ〜、ってのがだいたいの反応かとは思いますし、RP Developerのみなさんがちゃんと注意しれてばそれで十分な話ではあるかと思います。</p>

<p>が、IdP視点でいうと、アホなRPからユーザーさんのTokenとかそのRPのclient_secretとかがだだ漏れになっちゃうとIdPのレピュテーションにひびいたりするので、なかなかつらいところです。</p>

<p>もはやここまで騙されてる状況では、Authorization Response以外何も信用できない訳で、Authorization Endpointにiss含んでも、issに紐付いたIdP Configがstaticにhard-codeされてるなら、そのhard-codeされてるconfig自体信用できないということになります。</p>

<p>「IdPごとに別のredirect_uriを使う」なんてのも、もはや無意味ですね。</p>

<p>response_type=code+id_tokenとして、fragmentについてきたID Tokenをチェックしても、Discovery無しだとダメでしょう。</p>

<p>そのため、IdPが取れる対応策は以下の2つのどちらかになるでしょう。</p>

<ul>
<li>issを返しつつ、OAuth Discoveryをサポートする</li>
<li>OAuth MetaのようにToken Endpoint URLをAuthZ Responseに含める</li>
</ul>


<p>前者は <a href="http://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation">http://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation</a> をより厳しくしたもので、後者は <a href="http://tools.ietf.org/html/draft-sakimura-oauth-meta">http://tools.ietf.org/html/draft-sakimura-oauth-meta</a> そのものです。</p>

<p>個人的にはOAuth Discoveryが必須になるとHTTP Requestが増えるので、IdP的にはあまり嬉しくないなぁと思います。</p>

<p>ps.</p>

<p>Implicit FlowにおいてResource Endpointが書き換えられていることを想定したケースでは、AuthZ ResponseにResource Endpoint(s) を含めることになって、Code Flowよりさらにややこしい話になるわけですが、それはまた別の機会に&hellip;書く&hellip;かも。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth IdP Mix-Up Attack とは？]]></title>
    <link href="http://oauthjp.github.io/blog/2016/01/12/oauth-idp-mix-up-attack/"/>
    <updated>2016-01-12T15:51:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/01/12/oauth-idp-mix-up-attack</id>
    <content type="html"><![CDATA[<p>成人式を迎えられたID厨の皆様におかれましては、大変おめでとうございます。成人前からID厨とか、キモカワですね。</p>

<p>さて、今日は、成人式直前にOAuth MLに投下された以下のpostで「OAuth 2.0の脆弱性」として紹介されている &ldquo;IdP Mix-Up Attack&rdquo; について紹介します。</p>

<p><a href="https://mailarchive.ietf.org/arch/msg/oauth/JIVxFBGsJBVtm7ljwJhPUm3Fr-w">[OAUTH-WG] OAuth Security Advisory: Authorization Server Mix-Up</a></p>

<h2>前提条件</h2>

<ul>
<li>End-UserとRPの間の (TLS-protectedでない) HTTP Request/ResponseをAttackerがproxy可能。</li>
<li>RPが2つ以上のOAuth Server (IdP) と接続しており、そのいずれかが攻撃者の管理下にある。(IdPの中の人が実は攻撃者だった etc.)</li>
<li>RPは複数のIdPに対して共通のredirect_uriを利用しており、そこへのcallbackを受け取った時にstate値を元にIdPを特定する。

<ul>
<li>ただしIdP側のredirect_uri検証が「事前登録済の値との完全一致」でない場合は、この通りではない。</li>
</ul>
</li>
</ul>


<h2>攻撃フロー</h2>

<p>以下、Attackerの管理下にあるIdPをAIdP (Attacker IdP)、その他の悪意ないIdPをHIdP (Honest IdP) と呼ぶことにします。</p>

<p><img src="http://oauthjp.github.io/images/posts/oauth-idp-mixup.png" alt="OAuth IdP Mix-Up Attack" /></p>

<ol>
<li>End-UserはRPの任意のページから「HIdPでログイン」ボタンをクリック。</li>
<li>Browser->RPへの (TLS-protectedでない) リクエストをProxyしたAttackerは、RPに「AIdPでログイン」するリクエストを送信し、AIdPのAuthorization EndpointへのRedirect Responseを受け取る。</li>
<li>AttackerはBrowserにHIdPのAuthorization EndpointへのRedirect Responseを返す。ただしstate値は2で受け取った「AIdP向けのAuthorization Requestとひもづいた」値を利用する。(これ以降全リクエストはTLS-protectedであるためAttackerのProxyは介入不可)</li>
<li>End-UserはHIdPでApproveボタンをクリック。</li>
<li>HIdPはstateとcode/tokenをquery/fragmentにつけた状態で、End-UserをRPのredirect_uriに戻す。</li>
<li>code/tokenを受け取ったRPは、state値を元に受け取ったAuthorization ResponseがAIdPからのものだと判断する。</li>
<li>RPはAIdPのToken EndpointやAPI Endpointにcodeやtokenを送りつけてしまい、HIdPのcodeやtokenがAIdP (攻撃者) の手に渡る。</li>
</ol>


<!-- more -->


<h2>対策方法</h2>

<h3>対策方法1</h3>

<p>AIdP向けのredirect_uriとHIdP向けのredirect_uriを分ける。ただしこれが効果を発揮するためには、HIdPがRPからAIdP向けのredirect_uriを受け取った際にエラーになる必要がある。</p>

<h3>対策方法2</h3>

<p>Authorization Responseにcode/token発行者のIdentity情報を含める。</p>

<p>いまOAuth WGで提案されている対応策は、以下の2つです。なんか似たようなのが2つ出てきててカオスですね。</p>

<ul>
<li><a href="http://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation">http://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation</a></li>
<li><a href="http://tools.ietf.org/html/draft-sakimura-oauth-meta">http://tools.ietf.org/html/draft-sakimura-oauth-meta</a></li>
</ul>


<h3>対策方法3</h3>

<p>悪意のある可能性があるIdPを採用しない。(まぁ、普通は採用してないですよね&hellip;)</p>

<h3>どの対応策を採用すべき？</h3>

<p>RPは以上の3つのうちいづれかを採用すれば良いですが、IdPが採用できるのは2しかないですね。</p>

<h2>Malicious Endpoint Attackってのは？</h2>

<p><a href="http://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation">OAuth 2.0 Mix-Up Mitigation &ndash; draft-jones-oauth-mix-up-mitigation-00</a> には、&#8221;IdP Mix-Up Attack&#8221; とは別に &ldquo;Malicious Endpoint Attack&rdquo; ってのが出てきます。</p>

<p>これは、Discovery &amp; Dynamic Client Registrationを前提とした状況で発生する攻撃パターンです。</p>

<p>Dynamic Registrationを前提とすると、「信頼できないIdPを採用しない」という選択肢が取りづらくなるため、より問題が大きくなります。</p>

<p>が、そもそもみなさんそんなDynamic Client Registrationとか使ってないでしょうし、これについての解説はまた機会があればということで&hellip;</p>

<h2>最後に</h2>

<p>ID厨で本当に今年成人式を迎えられたあなた！次回の <a href="http://idcon.org">#idcon</a> の懇親会タダにするんでご容赦くださいm<em> </em>m</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[PR] OpenID Summit Tokyo 2015 やります！]]></title>
    <link href="http://oauthjp.github.io/blog/2015/10/19/openid-summit-tokyo-2015/"/>
    <updated>2015-10-19T11:58:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2015/10/19/openid-summit-tokyo-2015</id>
    <content type="html"><![CDATA[<p>Identity 界隈の皆様は、11/10 に <a href="https://openid.or.jp/summit/2015/index.html">OpenID Summit 2015</a> が開催されることはすでにご存知かと思いますが、OAuth / JWT 愛なみなさまの中にはまだご存知ない方もおられるかもしれないので、こちらでも告知しておきますね。</p>

<p>はい、やります！</p>

<p><a href="https://openid.or.jp/summit/2015/index.html#schedule-timetable">タイムスケジュール</a> みていただいてもおわかりのように、IETF 横浜の翌週というタイミングで、かつ OpenID Foundation (Global の方) の全面協力もあり、OpenID Foundation から主要な外タレ勢揃いな感じでございます。JWT Love なみなさんは、もちろん Mike Jones への愛を忘れたことはないでしょうし、強面やのになぜかプーさんキャラな John Bradley は IETF OAuth WG の各種最新 RFC および draft の解説をしてくれます。</p>

<p>もちろんメインホールでは日本語のセッションもやっとります。日本語セッションは、Identity 技術活用事例とか FINTECH とかマイナンバーとか IDaaS とか&hellip;</p>

<p>あと、毎度おなじみエバ企画、今回は OpenID Connect Certification の体験 Hands-on です。</p>

<ul>
<li>OpenID Connect IdP を実装したけど、本当に自分の実装が OpenID Connect 仕様に準拠してるのか確認したい方</li>
<li>OpenID Connect ライブラリを実装したけど、Connect 準拠の IdP を作るのに事足りるライブラリになってるか確認したい方</li>
<li>なんちゃって Connect 実装とか、なんちゃって OAuth 認証実装したけど、あとどれくらいで Connect 準拠になるのか知りたい方</li>
</ul>


<p>そんな方々に、IdP 実装の Connect 準拠具合をテストするためのツールがあります。</p>

<p>OpenID Connect Certification Hands-on では、テストツールの使い方を紹介後、実際みなさんの実装に対してテストを実行していただき、テストが失敗したものに関する Debug のお手伝い等もさせていただきます。</p>

<p>Global の方の OpenID Foundation からも、Mike Jones が Hands-on 会場に来てくれるようなので、Mike の OpenID Connect Certification のセッションをみた後、そのまま Hands-on に参加すると良いと思います！</p>

<p>ということで、<a href="https://openid.or.jp/summit/2015/index.html">申し込みはこちら</a>！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IETF JOSE WG と OAuth WG から一気に9本の RFC が！]]></title>
    <link href="http://oauthjp.github.io/blog/2015/05/20/jose-and-oauth-assertion-rfcs/"/>
    <updated>2015-05-20T21:05:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2015/05/20/jose-and-oauth-assertion-rfcs</id>
    <content type="html"><![CDATA[<p>一気に出ましたね。すでに過去にもいくつかは紹介したり翻訳したりしていますが、それぞれを簡単に紹介しておきます。</p>

<h3>JOSE WG</h3>

<ul>
<li><a href="http://tools.ietf.org/html/rfc7515">RFC 7515</a> &ndash; JSON Web Signature (JWS)</li>
<li><a href="http://tools.ietf.org/html/rfc7516">RFC 7516</a> &ndash; JSON Web Encryption (JWE)</li>
<li><a href="http://tools.ietf.org/html/rfc7517">RFC 7517</a> &ndash; JSON Web Key (JWK)</li>
<li><a href="http://tools.ietf.org/html/rfc7518">RFC 7518</a> &ndash; JSON Web Algorithms (JWA)</li>
<li><a href="http://tools.ietf.org/html/rfc7520">RFC 7520</a> &ndash; Examples of Protecting Content Using JSON Object Signing and Encryption (JOSE)</li>
</ul>


<p>JWS は署名付きのデータを JSON (の Base64 URL Encode) 形式で表現するための仕様で、多くの場合は JSON Payload に対して署名するケースで利用されます。JSON じゃないデータに対して署名して、署名結果を JSON (の Base64 URL Encode) 形式で表現することもできますが&hellip;まぁ、細かい話は置いときましょう。OpenID Connect の ID Token とかは、JWS 仕様に従って署名されています。</p>

<p>JWE は暗号化されたデータを JSON (の Base64 URL Encode) 形式で表現するための仕様です。現状では JWS よりは利用頻度低いかとは思いますが、SAML Assertion を暗号化してるようなユースケースを Connect に移行する時なんかには使うでしょう。</p>

<p>JWK は JWS や JWE などで利用する鍵を JSON 形式で表現するための仕様です。上記2つとよくセットで利用されます。OpenID Connect でも、OpenID Connect Discovery をサポートしているような IdP では大体公開鍵を JWK Set 形式で公開していますね。</p>

<p>JWA は、JWS や JWE で利用される各アルゴリズムおよびそれらの識別子を定義している仕様です。JWT, JWS, JWE をライブラリを通じて利用しているケースでは、あまり気にすることはないでしょうが、JOSE ライブラリ作者は読むことになるでしょう。</p>

<p>最後のは、サンプルリストですね。これはまぁライブラリ作者が読むくらいでしょう。</p>

<h3>OAuth WG</h3>

<ul>
<li><a href="http://tools.ietf.org/html/rfc7519">RFC 7519</a> &ndash; JSON Web Token (JWT)</li>
<li><a href="http://tools.ietf.org/html/rfc7521">RFC 7521</a> &ndash; Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants</li>
<li><a href="http://tools.ietf.org/html/rfc7522">RFC 7522</a> &ndash; Security Assertion Markup Language (SAML) 2.0 Profile for OAuth 2.0 Client Authentication and Authorization Grants</li>
<li><a href="http://tools.ietf.org/html/rfc7523">RFC 7523</a> &ndash; JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants</li>
</ul>


<p>JWT は JSON (の Base64 URL Encode) 形式で Assertion を生成するための仕様です。OpenID Connect の ID Token などで利用されています。大抵は署名 (= JWS) とセットで利用されるでしょう。</p>

<p>Assertion Framework for OAuth 2.0 (ry) は、任意の Assertion を OAuth 2.0 の Client Authentication で Client Credentials として使ったり、Authorization Grant として利用して Assertion を Access Token と交換するための仕様です。これ単体では利用できず、後の2つのサブ仕様の共通部分を抽象化した仕様になっています。</p>

<p>SAML 2.0 Profile for OAuth 2.0 (ry) は、SAML Assertion を RFC 7521 の Assertion として利用するための仕様です。既存の SAML SP が持っている SAML Assertion を OAuth 2.0 の Access Token と交換して API Access させたいとか、そういう時に使います。「あぁ、それは SAML 単体じゃ無理なんで、ID-WSF 必要ですねぇ〜」って言われたら、多分 ID-WSF 無視してこれ使えば、OAuth 2.0 使えるようになるはずです。</p>

<p>JWT Profile for OAuth 2.0 (ry) は、JWT を RFC 7521 の Assertion として利用するための仕様です。Client Authentication 目的で利用するケースは、ADFS / Azure AD とかであるはずですが、Authorization Grant として利用するケースは&hellip;あったかな？</p>

<h3>Links</h3>

<ul>
<li><a href="http://oauthjp.github.io/blog/2012/10/26/json-web-token-jwt/">JSON Web Token (JWT) &ndash; OAuth.jp</a>

<ul>
<li>もうこの記事書いてから、2年半経ってるんですね〜。感慨深い。</li>
</ul>
</li>
<li><a href="http://oauthjp.github.io/blog/2015/03/16/common-jws-implementation-vulnerability/">JWS 実装時に作りがちな脆弱性パターン &ndash; OAuth.jp</a>

<ul>
<li>すでに JOSE ライブラリは大体出揃ってるので、今後新しく作ることはあまりないかもしれませんが、もし自分で JWS 実装する時は、これ注意してくださいね。</li>
</ul>
</li>
<li><a href="http://openid-foundation-japan.github.io">翻訳ドキュメント一覧 &ndash; OpenID Foundation Japan 翻訳 WG</a>

<ul>
<li>Draft 版の JOSE 仕様群は、こちらに翻訳版あります。</li>
</ul>
</li>
<li><a href="http://www.sakimura.org/2015/05/2997/">JWSとJWTがRFCになりました！ &ndash; @_Nat Zone</a>

<ul>
<li>Nat さんはじめ、みなさんおつかれさまでした！</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[個人情報保護法改正案に見る第三者提供記録義務と越境問題]]></title>
    <link href="http://oauthjp.github.io/blog/2015/03/30/traceability-and-cross-border-data-transportation/"/>
    <updated>2015-03-30T14:19:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2015/03/30/traceability-and-cross-border-data-transportation</id>
    <content type="html"><![CDATA[<p>先日の「<a href="http://oauth.jp/blog/2015/02/28/traceability-on-each-attributes/">属性単位のトレーサビリティについて</a>」という記事でも取り上げましたが、<a href="http://www.cas.go.jp/jp/houan/150310/siryou3.pdf">個人情報保護法改正案</a>では、第二十五条に「第三者提供に係る記録の作成等」という規定が設けられ、第三者提供時に提供者受療者双方に記録義務が発生することとなっています。</p>

<p>また土曜日に行われた情報法制研究会第1回シンポジウムこの提供記録義務と、同じく改正案第二十四条の「外国にある第三者への提供の制限」を組み合わせると、AWSにデータ保存 (委託行為？) するだけで、第三者提供扱いとなり、記録義務が発生してしまうのではという指摘がありました。(まとめからのリンク先、板倉先生の資料参照。パスワードは空気読んで頑張って探してください。)</p>

<p><a href="http://togetter.com/li/801181?page=1">20150328情報法制研究会 第1回シンポジウム「改正個人情報保護法の内容と今後の課題」関連まとめ(私家版)</a></p>

<p>確かに第二十四条では、認定国もしくは認定事業者以外の外国事業者に対するデータ提供の場合は、下記のように第二十三条の例外規定 (委託や共同利用を第三者提供として扱わないという規定含む) を適用しないと明記しているので、委託の場合でも第三者提供扱いとなり、記録義務が発生することになりそうです。</p>

<blockquote>この場合においては、同条の規定は、適用しない。</blockquote>


<p>さらに外国事業者への提供時には、通常の同意とは別に外国事業者への提供であることを明記した上での同意を取得する必要があるため、海外のRPを相手にする国内IdPは、</p>

<ul>
<li>RPが国内事業者であるか否か</li>
<li>RPが海外事業者である場合には認定国の事業者であるか否か</li>
<li>RPが非認定国の事業者である場合には認定事業者であるか否か</li>
</ul>


<p>を判断した上で、いずれにも当てはまらない場合は通常とは別の同意文言を提示する必要が出てきそうです。</p>

<p>いやぁ〜、Dynamic Registrationとかしてる場合じゃないっすね！</p>

<p>どうしましょか、これ？w (ノーアイデァなぅ)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JWS 実装時に作りがちな脆弱性パターン]]></title>
    <link href="http://oauthjp.github.io/blog/2015/03/16/common-jws-implementation-vulnerability/"/>
    <updated>2015-03-16T11:45:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2015/03/16/common-jws-implementation-vulnerability</id>
    <content type="html"><![CDATA[<p>JOSE (Javascript Object Signing and Encryption) 愛で満ち溢れる ID 厨界隈において、燦々と輝く JWS (JSON Web Signature)、美しいですよね！</p>

<p>JWT がジャニーズなら、JWE は EXILE、JWS は石原さとみと言ったところでしょうか？</p>

<p>と、冗談はさておき、JWT をお使いの皆さんは、当然署名付けてますよね？署名検証しますよね？</p>

<p>そんなあなたに一言いいたい！</p>

<p>まだ HMAC で消耗してるの？</p>

<p>いや、決して HMAC オワコンとかは言ってないですよ？スマホアプリでの署名検証のために、アプリに共通鍵埋め込むのはナンセンスってだけで。</p>

<p>ということで、今日は JWS をお使いのみなさんに、実装時に作りがちな脆弱性パターンを2つご紹介します。</p>

<p>今日紹介する脆弱性の2つのうち、1つめは HMAC, RSA, ECDSA のどれを使っても対象になるパターン、2つめは公開鍵暗号 (RSA / ECDSA) を使っている場合にのみ対象になるパターンです。</p>

<p>では、さっそく行ってみましょう。</p>

<!-- more -->


<h2>JWS Header の alg を &ldquo;none&rdquo; に改ざん</h2>

<p>JWS Header には、alg とか typ とか kid とかが入ってるわけですが、この攻撃では alg を &ldquo;none&rdquo; に書き換えます。そして、署名部分をごっそり取り除きます。</p>

<p>例えばこんな JWT を</p>

<pre>
Raw: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQifQ.eyJmb28iOiJiYXIifQ.lmsUbhkgf5KpheRpXwc-pbG_HhYr9Grw1301d0sVzxI
Header: {typ: "JWT", alg: "HS256", kid: "default"}
</pre>


<p>こんな風に</p>

<pre>
Raw: eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIiwia2lkIjoiZGVmYXVsdCJ9.eyJmb28iOiJiYXIifQ.
Header: {typ: "JWT", alg: "none", kid: "default"}
</pre>


<p>これだけで、あとはもう Payload を改ざんし放題。</p>

<p>こういう JWT を受け入れてしまう実装が、意外に多いらしいです。</p>

<p>えぇ、かつて JSON::JWT Gem もそうでした、随分と昔の話ですが。</p>

<p>署名検証する場所では、alg=none な JWT が送られてきたときにちゃんとエラーになるかどうか、確認しましょう。</p>

<h2>JWS Header の alg を &ldquo;HMAC-SHA*&rdquo; に改ざん</h2>

<p>こちらも JWS Header の alg を改ざんするんですが、こちらのケースでは署名はちゃんとついています。</p>

<p>このケースでは、alg を公開鍵暗号方式 (RSA / ECDSA) から共通鍵暗号方式 (HMAC) に差し替え、「公開鍵文字列を共通鍵として利用して」署名を生成します。</p>

<p>前提として、攻撃者が公開鍵を取得できることが必要ですが、まぁ公開鍵は割と誰にでも手に入りそうです。(当社比)</p>

<p>で、今度は Ruby のサンプルコードで説明すると、</p>

<pre>
private_pem = <<-PEM
-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEArUeGng6YrNJT/YbxgWVfJPHtv8tVXNugsuPEt10af+OyCeyk
 :
-----END RSA PRIVATE KEY-----
PEM
private_key = OpenSSL::PKey::RSA.new private_pem

jwt = JSON::JWT.new(foo: :bar)
jws = jwt.sign(private_key, :RS256)
</pre>


<p>だったのを</p>

<pre>
public_pem = <<-PEM
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArUeGng6YrNJT/YbxgWVf
 :
-----END PUBLIC KEY-----
PEM

jwt = JSON::JWT.new(malformed: "something attacker added")
jws = jwt.sign(public_pem, :HS256)
</pre>


<p>にする感じです。</p>

<p>公開鍵をどのようなフォーマットで保存しているかは実装依存でしょうが、その辺は空気読んでいただくとして。</p>

<p>こちらも Payload は改ざんし放題です。</p>

<p>こちらの脆弱性は、JSON::JWT のように公開鍵を鍵オブジェクトとして扱う環境ではエラーになったりしますが、公開鍵を文字列として扱うような環境では以外に署名検証を通過したりしてしまうようです。</p>

<p>例えば PHP とか。</p>

<p>署名検証時に署名アルゴリズムを明示的にチェックするなどの対策が必要でしょう。</p>

<h2>まとめ</h2>

<p>僕らの JOSE 愛は、こんなことじゃめげないですよ！</p>

<p>でも、気をつけましょうね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[PR] 属性単位のトレーサビリティについて]]></title>
    <link href="http://oauthjp.github.io/blog/2015/02/28/traceability-on-each-attributes/"/>
    <updated>2015-02-28T23:10:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2015/02/28/traceability-on-each-attributes</id>
    <content type="html"><![CDATA[<p>来週月曜 (2015/03/02) <a href="http://www.openid.or.jp/news/2015/02/OpenIDBizDay-8.html">OpenID BizDay vol.8</a> が開催され、ひろみちゅせんせ・まさともせんせ・Nat さんの3名を中心に、個人情報改正を控え、「炎上レスでパーソナルデータ活用ビジネスを進めるためにどこまでが許容範囲なのか、個人情報保護法改正に関して現時点で何をどこまで気にしておけば良いか」といった内容についてみんなで考える機会が設けられます。</p>

<p>なんと、いつもは OpenID Foundation Japan 会員限定の BizDay が、今回は 5,000 円さえ払えば非会員でも参加できるんです！！</p>

<p>こらぁ上司の承認とか後回しで、<a href="http://www.openid.or.jp/seminar/entry.html">いますぐ申し込まないとダメですね</a>！！！</p>

<p>と、前置きはこれくらいにして、個人情報保護法改正項目の中でも、今日は「第三者提供時に提供元 &amp; 提供先双方でその記録義務が追加される」という点について、OpenID Connect や Facebook Connect などの「外部 ID 連携」時の影響範囲について、考えてみましょう。</p>

<p>僕の感覚だと、普通に外部 ID 連携した場合、属性も IdP から引っ張ってくるけど、引っ張ってきた属性 (氏名とかメアドとか) はユーザーが後から編集可能な状況になっていると思います。</p>

<p>そんな状況で、任意の時点でユーザーから「この氏名データ、どこから来たの？」って聞かれたら答えられるトレーサビリティを確保する&hellip;</p>

<p>一つのアカウントに複数 IdP が紐づけ可能で、任意の IdP との紐づけを任意のタイミングで解除できる、そんな状況でもトレーサビリティを確保する&hellip;</p>

<p>すでにそれが可能な実装にしているものだけが、SAMLer に石を投げなさい。</p>

<p>これ、実装どうするかって話もあるんですが、そもそもそんなケースでもトレーサビリティ必要なんでしたっけ？って疑問が湧きますよね。</p>

<!-- more -->


<p>こういうケースって、散財情報扱いなんでしょうか？</p>

<p>ユーザーが明示的に書き換えた情報に関してまで、トレーサビリティはいらないですよね？</p>

<p>ユーザーが明示的に紐づけた IdP から、明示的に同意を取った scope に紐づく属性を取得した時に、それをトレースする義務はユーザーに負わせることはできないのでしょうか？</p>

<p>とまぁ、気になってるけど調べきれてないことも、きっと BizDay なら先生方に直に聞ける！</p>

<p>プライバシーフリークカフェでおなじみ、ひろみちゅせんせ・まさともせんせ・切込隊長による <a href="http://www.shoeisha.co.jp/book/detail/9784798139760">ニッポンの個人情報</a> の即席サイン会にだって参加できる！</p>

<p>あぁそうさ、要するに <a href="http://www.openid.or.jp/news/2015/02/OpenIDBizDay-8.html">OpenID BizDay #8</a> 来いよってことさ！</p>

<p>もし BizDay のこと初めて聞いたって方がおられましたら、いまさら遅せーよとか言わないでくださいごめんなさい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google OpenID 2.0 のサポート終了、OpenID Connect への移行はお早めに]]></title>
    <link href="http://oauthjp.github.io/blog/2015/01/07/google-openid2-termination/"/>
    <updated>2015-01-07T13:20:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2015/01/07/google-openid2-termination</id>
    <content type="html"><![CDATA[<p>今朝こちらの Tweet みて気がついたんですが、Google が OpenID 2.0 のサポートを2015年4月20日で終了するようです。</p>

<blockquote class="twitter-tweet" lang="en">
    <p>Developers beware! Google has published its timeline for deprecation of OpenID 2.0:<a href="http://t.co/84cIS0wR1D">http://t.co/84cIS0wR1D</a></p>
    &mdash; Gluu (@GluuFederation)
    <a href="https://twitter.com/GluuFederation/status/552615928014577665">January 7, 2015</a>
</blockquote>


<script async src="http://oauthjp.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>本当にそんな短期間で OpenID 2.0 止めて大丈夫なのかって気がしますが、<a href="https://developers.google.com/accounts/docs/OpenID#shutdown-timetable">Google OpenID 2.0 Shutdown Timetable</a> によると、4/20で全てが止まるようです。</p>

<p>僕が把握しているところでは、以下のサイトは現時点でまだ Google OpenID 2.0 を使っています。他にもいっぱいあるんでしょうが、僕は把握してません。他に知ってるのあれば教えてください。</p>

<ul>
<li><a href="http://iknow.jp">iKnow!</a></li>
<li><a href="http://chatwork.com">ChatWork</a></li>
<li><a href="http://atnd.org">ATND</a></li>
</ul>


<p>OpenID 2.0 停止により、上記のようなサイトでは、いままで Google Account でログインしてきたユーザー達はログインできなくなります。</p>

<p>これらのサイトは、4/20までに OpenID Connect (Google+ Signin) への移行が必要です。</p>

<!--more-->


<p>移行方法は <a href="https://developers.google.com/accounts/docs/OpenID">Google OpenID 2.0 Migration</a> にあります。</p>

<p>なんだかユースケースごとに4通りの移行方法が紹介されてますが、基本は <a href="https://developers.google.com/accounts/docs/OpenID#update-to-plus">Migrating to Google+ Sign-In</a> に従えば良さそうです。</p>

<p>細かいステップは <a href="https://developers.google.com/+/api/auth-migration#oid2">Migrate from OpenID 2.0 or OpenID+OAuth hybrid to Google+ Sign-In</a> を読んでいただくとして、大雑把な Step は以下の通りです。</p>

<ol>
<li>Authorization Request に OpenID 2.0 時代に使っていた realm を含める。</li>
<li>ID Token に OpenID 2.0 時代の Claimed Identifier が &ldquo;openid_id&rdquo; という名前で含まれて帰って来る。</li>
<li>&ldquo;openid_id&rdquo; をキーに既存ユーザーを探して、該当ユーザーの識別子を &ldquo;sub&rdquo; に置換する。</li>
</ol>


<p>あと、Attribute Exchange 使ってプロフィール情報を取得してた場合は、UserInfo API 叩くように変更しましょう。</p>

<p>ま、これだけっちゃこれだけなんですが、4/20までって言われると、焦りますね。</p>

<p>みんな realm が何かとか把握してるんでしょうか？</p>

<p>ってことで、自分が使ってるサービスが Google OpenID 2.0 使い続けてる場合は、サービス運営者に移行予定を問い合わせるなりしたほうが良いですね。</p>

<p>国内サービスの場合は、このブログのコメント欄にサービス名列挙していただけると、こちらでも対応可能かもしれません。(たぶん OpenID Foundation Japan 経由で)</p>

<p>あと、自社サービスが Google OpenID 2.0 使ってて移行ムリゲーとかいう事業者の方は、<a href="http://openid.or.jp/inquiry/">OpenID Foundation Japan に問い合わせ</a> いただいけるといいかもですね。</p>

<p>要望が多ければ、OpenID Foundation Japan のエヴァンジェリスト達で Migration Handson なり Hackathon なり企画してもいいかなと思っています。</p>

<p>いや、何も<a href="http://openid.or.jp/about/index.html#op-about-joining">いますぐ Foundation に加盟</a>しろなんていいませんよ？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth 2.0 の Response Type 全パターン]]></title>
    <link href="http://oauthjp.github.io/blog/2015/01/06/oauth2-multiple-response-type/"/>
    <updated>2015-01-06T20:15:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2015/01/06/oauth2-multiple-response-type</id>
    <content type="html"><![CDATA[<p>特に新しい話題ではないですが、定期的に質問されてる気がするので記事にしときます。</p>

<p>OAuth 2.0 の Core には、&#8221;code&#8221; と &ldquo;token&rdquo; という2つの response_type が定義されています。</p>

<p>それぞれ &ldquo;Code Grant&rdquo; と &ldquo;Implicit Grant&rdquo; と呼ばれることもありますし、歴史的経緯により &ldquo;Code Flow&rdquo; と &ldquo;Implicit Flow&rdquo; と呼ぶこともあります。</p>

<p>ほとんどのケースでは、この2つの response_type のどちらかを使っているかと思いますが、実はこれ以外にも以下の response_type のパターンが存在します。
(<a href="http://openid.net/specs/oauth-v2-multiple-response-types-1_0.html">仕様はこちら</a>)</p>

<ul>
<li>none</li>
<li>code token</li>
<li>id_token</li>
<li>id_token code</li>
<li>id_token token</li>
<li>id_token code token</li>
</ul>


<p>id_token ってのが含まれてるのは、OpenID Connect で利用する response_type なので、OAuth 2.0 だけを実装する場合は無視して OK です。</p>

<p>でもこんなにいっぱいあると、Server 側 (OP 側) もどこまで実装したらいいかわかんないし、Client 側 (RP 側) もどれ使うのが一番いいのかわかんないですよね。特に OpenID Connect 使う場合は。</p>

<p>そんなこんなで、「どれ実装したらいいの？」とか、「どれ使えばいいの？」っていう質問を、Server 側の人にも Client 側の人にも、半年に一回くらいされる気がします。</p>

<p>この機会に、それぞれの response_type で想定される Use-Case をまとめておきましょう。</p>

<!-- more -->


<h3>none</h3>

<p>「Approve はするけど、access_token (と id_token) は今はいらない」って時に使います。</p>

<p>はい、「それいつやねん」って思ったそこのあなた、あなたはきっとこれ使う事ないです。</p>

<p>世の中のごく一部には、これが必要な人もいるようですが、僕もいままで使ったことないです。</p>

<h3>code token</h3>

<p>Native App で access_token 使うんだけど、Native App の Backend Server 側でも access_token (と id_token) が欲しい時に使います。</p>

<p>fragment に code と access_token がついて返って来るので、access_token はそのまま Native App が内部に保持して、code だけを Native App から Backend Server に渡します。</p>

<p>Backend Server はその code を Token Endpoint に送って access_token (と id_token) を取得します。</p>

<p>もしかしたら Native App から access_token を Backend Server に送るような実装してる人もいるかもしれませんが、そうすると以下のようなデメリットがあります。</p>

<ul>
<li>Token Replace Attack に対して脆弱になりがち</li>
<li>Backend Server でも refresh_token を取得できない</li>
<li>Implicit Flow 経由で発行される access_token は lifetime が短くなりがち (Server 側の実装依存)</li>
</ul>


<h3>id_token</h3>

<p>access_token が不要な時に使います。</p>

<p>Web App / Native App どちらでも使われうるかと思います。</p>

<p>ただしこれ使うと fragment に id_token ついて返ってくるので、Web App からは扱いづらいかもしれません。</p>

<p>「response_type=code 使って access_token 捨てればいいやん」って言われたら、「その通りですね」とお返しします。</p>

<p>また、Native App 側で id_token 使ってユーザー認証するケースって、そんなに多くはなさそうです。</p>

<p>この response_type は、あまり使う機会なさそうです。</p>

<h3>id_token code</h3>

<p>Native App で id_token 使うんだけど、Native App の　Backend Server 側でも access_token (と id_token) が欲しい時に使います。</p>

<p>fragment に code と id_token ついて返ってくるので、id_token はそのまま Native App が内部に保持して、code だけを Native App から Backend Server に渡します。</p>

<p>Backend Server はその code を Token Endpoint に送って access_token (と id_token) を取得します。</p>

<p>ただこの response_type も、Native App 側で id_token が必要ってケースなんで、あまり使う機会なさそうです。</p>

<p>※ なぜか YConnect だけはこれを response_type=code 相当の response_type として利用しないといけないのですが、あれは YConnect の Bug です。</p>

<h3>id_token token</h3>

<p>Backend Server に code 渡す必要なくて、Native App 側だけで id_token と access_token 使えればそれで OK ってときに使います。</p>

<p>fragment に access_token と id_token ついて返ってきます。</p>

<p>この response_type も、Native App 側で id_token が必要ってケースなんで、あまり使う機会なさそうです。</p>

<h3>id_token code token</h3>

<p>Native App 側でも Backend Server 側でも id_token と access_token 両方必要な時に使います。</p>

<p>fragment に access_token と code と id_token ついて返ってくるので、access_token と　id_token はそのまま Native App が内部に保持して、code だけを Native App から Backend Server に渡します。</p>

<p>Backend Server はその code を Token Endpoint に送って access_token (と id_token) を取得します。</p>

<p>この response_type も、Native App 側で id_token が必要ってケースなんで、あまり使う機会なさそうです。</p>

<h3>まとめ</h3>

<p>Server 側は、とりあえず以下の3つさえサポートしてれば、大抵の Use Case はサポートできそうです。</p>

<ul>
<li>code</li>
<li>token</li>
<li>code token</li>
</ul>


<p>Client 側も、基本は以下のような基準で response_type 選べば良さそうです。</p>

<ul>
<li>Web App なら code</li>
<li>Backend Server なしの Native App なら token</li>
<li>Backend Server ありの Native App なら code token</li>
</ul>


<h3>補足</h3>

<p>本記事全体として、Native App を JS App に置き換えても同様です。</p>

<p>また、広く公開される IdP を作る場合は、以下のようなケースも考慮しましょう。</p>

<h4>Native App 側で id_token が必要なケース</h4>

<p>Native App 側でマルチアカウント対応してるような場合は、Native App 側で id_token が必要になるケースはあるかもしれません。</p>

<p>そういう Client にも対応したい Server は、(none 以外) 全部サポートしましょう。</p>

<h4>Native App 側で code を使うケース</h4>

<p>Native App から Token Endpoint に code を送るケースもあります。</p>

<p>この場合は、Native App 側で refresh_token を取得したいケースが多いです。</p>

<p>access_token の lifetime が短く、Native App で頻繁に AuthZ Request を送りたくない場合などには、Native App でも refresh_token が必要になるのです。</p>

<p>ただしこの場合、Token Endpoint での Client Authentication を OPTIONAL にする必要があるので注意してください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FIDO Alliance]]></title>
    <link href="http://oauthjp.github.io/blog/2014/10/15/fido-alliance/"/>
    <updated>2014-10-15T11:28:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/10/15/fido-alliance</id>
    <content type="html"><![CDATA[<p>先週末、FIDO Alliance　のメンバーが来日して、<a href="http://www.dds.co.jp/fido_tokyoseminar/">FIDO Alliance Tokyo Seminar</a> というセミナーが開催されていました。僕も今春の <a href="http://idcon.doorkeeper.jp/events/10195">#idcon vol.18</a> で <a href="http://www.slideshare.net/matake/fido-alliance">FIDO Alliance について紹介した</a> 時にまだいろいろ不明点が多かったのもあって、このセミナーに参加してきました。</p>

<p>で、参加してみて分かった事。</p>

<h2>生体認証押し</h2>

<p>まぁ、これは FIDO Alliance のサイト見ても、元々そうっちゃそうなんですが。</p>

<p>FIDO は仕様的には特に生体認証センサーとか必要ないし、FIDO に準拠してない Apple TouchID みたいなセンサーモジュールと連携したソフトウェアモジュールさえ積んでればFIDO 仕様に沿った実装は可能です。</p>

<p>ひとことで言うと、エンドユーザーが「端末のセキュア領域に保存されている秘密鍵にアクセスして assertion に署名できる存在」であることを認証しているに過ぎないので、その秘密鍵のロック解除に指紋使ってもいいし、PIN Code 使ってもいいはずです。</p>

<p>が、やはり Alliance Member には生体認証ハードウェアモジュールのベンダーが多い事もあってか、発表ではヤケに生体認証を押していました。</p>

<p>その影響か、Twitter とか現地での Q&amp;A でも、生体認証のセキュリティについての質問が多かったように思います。</p>

<!-- more -->


<h2>UAF と U2F は完全に別物</h2>

<p>FIDO Alliance では、パスワードレスな認証の実現を目指す Universal Authentication Framework (UAF) と、2要素認証の UX 改善を目指す Universal Second Factor (U2F) という2つの Working Group が、それぞれに仕様策定を進めています。</p>

<p>僕の #idcon vol.18 時点の理解では、U2F は UAF とほぼ同じで、JS API や Android SDK などでの利用を想定した仕様策定がそれにプラスαで進んでいるのだと思っていたのですが、懇親会で Google の Dirk Balfanz さんに聞いたところでは、U2F は「JS API (と Android SDK)」のみの標準化を行っているそうです。</p>

<p>UAF では、センサーモジュールと Client App、Client App と Backend Server などの間でのやりとりが規定されているのですが、U2F ではその辺りのやり取りは「各実装が自由にやれ」という姿勢とのこと。</p>

<p>UAF 側の Rolf Lindemann (Nok Nok Labs) に別途聞いたところでは U2F Working Group に UAF で策定した仕様を取り込むよう働きかけているとのことでしたが、2つの WG の間の連携は、それほど強くないのかもしれません。</p>

<h2>Discovery は貧弱</h2>

<p>FIDO UAF Protocol では、FIDO Alliance が FIDO Ready な製品を作る Vendor に Vendor ID を発行し、FIDO Ready な Product を Metadata Service (?) に登録したりするというようなことが書かれているのですが、現状は Vendor ID の発行にとどまっており、Metadata は必要に応じて RP が「ダウンロード」している状況のようです。</p>

<p>この部分がマニュアルだと、結局デバイスメーカーやアプリベンダーは、OAuth のクライアント登録的なマニュアル作業から抜け出せないように思います。</p>

<p>ま、もろもろまだまだ、って感じでしょうか。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Twitter Login にも CSRF 脆弱性ができやすい罠が!?]]></title>
    <link href="http://oauthjp.github.io/blog/2014/06/23/csrf-on-twitter-login/"/>
    <updated>2014-06-23T10:46:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/06/23/csrf-on-twitter-login</id>
    <content type="html"><![CDATA[<p>OAuth 2.0 では state パラメータってのがあって、それをちゃんと使わないと CSRF 脆弱性ができちゃうよって話は、<a href="http://www.slideshare.net/ritou/idcon17-oauth2-csrfprotectionritou">@ritou 先生のスライド</a>などでみなさん勉強したんではないでしょうか。state パラメータは RFC 6749 では RECOMMENDED 扱いで、REQUIRED ではありませんが、OAuth 2.0 をログインに使う場合は REQUIRED にすべきでしょう。OAuth 2.0 をログインに使うの、Token 置換攻撃とか Covert Redirect + Code 置換攻撃とか、いろんな罠がありますねぇ〜。</p>

<p>OAuth 1.0 ならそんなことないのに&hellip;</p>

<p>そう思ってた時期が、僕にもありました。</p>

<p>でも @ritou 先生よく言ってるじゃないですか。「Twitter の OAuth 実装クソや」って。でね、ほんとにクソやったんすよ、コレが。</p>

<!-- more -->


<p>さて、Developer の皆様におかれましては、もうずいぶん「Twitter ID でログイン」の実装なんて放置してて詳細忘れ去ってるころかと思いますので、まずは OAuth 1.0 の Access Token 取得までのフローを復習しましょう。</p>

<p><img src="http://oauthjp.github.io/images/posts/oauth1_flow.png" alt="OAuth 1.0 Flow" /></p>

<p>思い出しましたか？</p>

<p>思い出せない方には<a href="http://openid-foundation-japan.github.io/rfc5849.ja.html">仕様を読み直していただく</a>として、先に進みましょう。</p>

<p>OAuth 1.0 には Request Token + Request Token Secret というのがありました。RFC 5849 では Temporary Credentials とか言われたりもしますが、Request Token という呼び名の方が一般的でしょう。</p>

<p>で、この Request Token Secret、Access Token 取得時のリクエストに署名するために必要になります。「Consumer Secret と Request Token Secret の2つを連結させたものを HMAC 鍵として利用する」って、習いましたよね？</p>

<p>で、一般的にはこの Request Token Secret を Session と紐づけて保存すると思うんですが、これが認可レスポンスが返される箇所 (Callback URL) への CSRF 対策として作用していたんです。</p>

<p>認可リクエストを送った Browser と認可レスポンスを返してきた Browser が異なれば、当然認可レスポンスを返してきたブラウザでは Session と紐づく Request Token Secret が取得できないので、Access Token が取得できない。よって CSRF 対策ができている。</p>

<p><strong>が、ここで罠があるんです。</strong></p>

<p>実は Twitter は、Access Token 取得時のリクエストの署名に、<strong>Request Token Secret を使わなくてもいい</strong>んです。なので Session に紐づいた Request Token Secret が空の場合にそれをそのまま空文字列として処理してしまう RP は、<strong>正常に Access Token を受け取れてしまいます</strong>。</p>

<p>つまり、攻撃者が被害者にこんな URL を踏ませると、被害者は攻撃者の Twitter アカウントを使ってあなたのサイトにログインできてしまう可能性があるのです。</p>

<pre>
https://client.example.com/callback?
  oauth_token=&lt;request-token-authorized-by-attacker&gt;&
  oauth_verifier=&lt;valid-oauth-verifier&gt;
</pre>


<p>このパターン、すでにいくつかの「Twitter ID でログイン」を実装してるサイトでは確認してます。</p>

<p>この脆弱性によるリスクは <a href="http://www.slideshare.net/ritou/idcon17-oauth2-csrfprotectionritou">@ritou 先生のスライド</a> に書いてあるのでそちらにゆずります。</p>

<p>Twitter が Request Token Secret を必須にしてないことは以下のコードで確認できます。</p>

<script src="https://gist.github.com/nov/5e99d1999bea0e16bb74.js"></script>


<p>ちなみに Twitter 側はこのバグは認識してるらしいのですが、直すと多くのサイトが動かなくなるのも把握しているのか、修正できないでいるようで、みなさんが個別に対策するしかないわけです。</p>

<p>とりあえず <strong>Session に紐づいた Request Token Secret が無かったら、エラーにしちゃえば OK</strong> です。</p>

<p>そもそも Request Token Secret が Session に紐づいてなかったり、Request Token Secret 一切使ってないなんて人は、アウトです。まぁいまから再び Twitter ID でログインとか自分で実装するよりは、人気のライブラリ探した方が良いでしょう。Rails だといまでも omniauth-twitter とかが人気なんでしょうか。</p>

<p>ちなみに omniauth-twitter (というか omniauth-oauth) は Callback URL で Session に Request Token Secret が入ってなければエラーになるので Safe です。Gunosy とか Doorkeeper は omniauth-twitter 使ってるのか、Safe でした。</p>

<p>そういや最近<a href="https://twitter.com/TSJ2010">日本ツイッター学会</a>って何してんすかね？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth 2.0 の code は漏れても大丈夫ってホント!?]]></title>
    <link href="http://oauthjp.github.io/blog/2014/05/09/what-happens-when-oauth2-code-leaked/"/>
    <updated>2014-05-09T09:59:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/05/09/what-happens-when-oauth2-code-leaked</id>
    <content type="html"><![CDATA[<p>昨日の<a href="http://oauthjp.github.io/blog/2014/05/08/covert-redirect-and-non-30x-redirects/">Covert Redirect で Query 漏れるケースもある!?</a>や<a href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect/">OAuth 2.0 の脆弱性 (!?) &ldquo;Covert Redirect&rdquo; とは</a>にあるように、OAuth 2.0 の code が漏れちゃうことも、ありえます。</p>

<p>漏れないためにやるべきことは、上記の記事や<a href="http://oauthjp.github.io/blog/2014/05/08/facebook-login-and-covert-redirect/">Facebook Login で Covert Redirect を防止する</a>なんかでも紹介してるので、そちら読んでください。</p>

<p>で、今回の内容は<strong>「code が漏れたら何がまずいのか」</strong>についてです。</p>

<h3>「code は漏れても大丈夫」説</h3>

<p><a href="http://www.openid.or.jp/blog/2014/05/covert-redirect-and-its-real-impact-on-oauth-and-openid-connect.html">「Covert Redirect」についての John Bradley 氏の解説（追記あり）</a>にも、こうありましたね。</p>

<blockquote>
OAuth と OpenID Connect には複数の response_type があるんだけど、さきのリポートの著者は、最も一般的な response_type が &#8220;code&#8221; であることに触れず、またクライアント・クレデンシャルを使ってもう一度呼び出しを行わないとアクセス・トークンは手に入らないってことも無視してる。つまり、たしかに &#8220;code&#8221; がオープン・リダイレクターを経由して漏洩するかもしれない、という点については彼が正しい。けど、その code を使って攻撃者がなにかできるわけではないよ。これこそまさに、&#8221;code&#8221; response_type を使うことで得られる効果的な緩和策だね。
</blockquote>


<p>あれ？code 漏れても問題なさそうですね？</p>

<p>ほんとでしょうか？</p>

<h4>[仕様策定者視点での答え]</h4>

<blockquote>
本当です。みんながちゃんと OAuth の仕様に沿って実装していれば。仕様に沿って実装してない場合は知らん。ちゃんとやれ。
</blockquote>


<h4>[OAuth Server 実装者視点での答え]</h4>

<blockquote>
本当です。Client がちゃんと client secret を漏洩させずに、OAuth の仕様に沿って実装していれば。client secret 漏らしたり仕様に沿って実装してない場合は、うちのユーザーに迷惑かかるかもしれんし、あなたのアプリ停止しちゃうね。
</blockquote>


<h4>[OAuth Client 実装者視点での答え]</h4>

<blockquote>
え？俺ちゃんと仕様に沿って実装できてんの？

&#8230;まぁ動いてるしできてる、よね！？

それに万が一 code 漏れても、うちに被害及ぶってより OAuth Server に被害及ぶはずやし、OAuth Server がちゃんと対策してれば、まぁなんとかなるよね？
</blockquote>


<p><strong>ゆとりか！(｀ヘ´#)</strong></p>

<p>OAuth Client 実装者がこういう考えだと、一瞬でやられちゃいそうですねぇ。</p>

<p>ってことで、ここでは<strong>「code が漏れたら OAuth Client 側でアカウント乗っ取りが発生する」</strong>ケースについて考えてみましょう。</p>

<!-- more -->


<h3>前提条件</h3>

<p>あなたのサイトは「Facebook ID でログイン」できるようになっています。(ちなみにここでは一番世に広まっている Facebook を挙げますが、問題の本質は Facebook に限定された話ではないので、ID Provider が GitHub や LinkedIn な場合でも同様です)</p>

<p>あなたのサイトからは client secret は漏れていませんし、Implicit Flow も使ってないので、「Token 置換攻撃 ※1」は受けません。</p>

<p>あなたのサイトには open redirector があり、被害者の code が攻撃者に漏洩しています。(or している可能性があります)</p>

<p>client secret は漏れていないので、攻撃者が漏洩した code を access token と交換することは、できません。</p>

<h3>攻撃例</h3>

<p>攻撃者は、あなたのサイトの正規の redirect_uri に、漏洩した code を送りつけます。</p>

<pre>
GET /facebook/callback?code=&lt;leaked-code&gt;
Host: client.example.com
</pre>


<p>ここであなたのサイトはこのリクエストを Facebook から正規のリダイレクトレスポンスとして処理します。通常、だいたいこんな処理を行うのではないでしょうか。</p>

<ol>
<li>Facebook の Token Endpoint に code を POST し、access token を取得する。</li>
<li>access token を使って <code>GET /me</code> にアクセスし、ユーザーの Facebook UserID を取得する。</li>
<li>取得した Facebook UserID と紐づくアカウントを特定し、local の session cookie を発行するなどしてログイン済にする。</li>
</ol>


<p>あれ？攻撃者が漏洩した code を使って、<strong>あなたのサイトに被害者のアカウントで</strong>ログインできてしまいましたね？</p>

<p>なんか Token 置換攻撃と同じような現象が起こっちゃいましたね？</p>

<p>こんなことが起こりえる以上、</p>

<blockquote>
万が一 code 漏れても、うちに被害及ぶってより OAuth Server に被害及ぶはずやし、OAuth Server がちゃんと対策してれば、まぁなんとかなるよね？
</blockquote>


<p>なんて悠長なことは、言ってられませんね。</p>

<h4>[捕捉]</h4>

<p>なお、code &lt;&ndash;> token 交換時には redirect_uri を Token Endpoint に送ることになるので、ここで Server 側がちゃんと code 発行時の redirect_uri とここで送られて来る redirect_uri を exact match で検証していれば、Step.1 でエラーになってこの攻撃は成立しないはずです。</p>

<p>実際 Facebook はこのタイミングでは exact match 必須なんで、正規の redirect_uri が open redirector になってない限りは上記の攻撃は Step.1 で失敗します。</p>

<p>が、残念ながら世の中には 某ithub みたいに (ry</p>

<h3>対策方法</h3>

<p>まず、この攻撃が発生してしまう根本原因は、ここです。</p>

<blockquote>
ここであなたのサイトはこのリクエストを Facebook から正規のリダイレクトレスポンスとして処理します。
</blockquote>


<p>これを防げれば OK です。</p>

<p>これを防ぐための一番簡単な方法は、<strong>被害者と攻撃者が異なる UserAgent を使っていることを検知する</strong>ことです。</p>

<p>いわゆる CSRF 対策ができてればいいんですね。</p>

<p>ここで @ritou 先生の<a href="http://d.hatena.ne.jp/ritou/20121008/1349695124">OAuth 2.0のstateとredirect_uriとOpenID ConnectのnonceとID Tokenについて</a>でも紹介されてる state パラメータってやつが登場するわけです。</p>

<p>この state パラメータについては、Client が任意であらゆる文字列を指定できてしまうので、前提知識の乏しい Developer にとってはいまいち何を指定すればいいか分からないかもしれません。</p>

<p>@ritou 先生の記事に従って、session ID のハッシュ値を指定してもいいですし、先日 John Bradley が出してきた<a href="http://tools.ietf.org/html/draft-bradley-jwt-encoded-oauth-state-00">こちらの OAuth 2.0 拡張仕様</a>を参考にしても良いでしょう。</p>

<h3>結論</h3>

<p>ちゃんと state 使ってない OAuth Client に関しては、<strong>「code なら漏れても大丈夫」なんてウソです</strong>。</p>

<p>OAuth Server には、code 置換攻撃を防ぐ手だてはありません。</p>

<p>OAuth Client がちゃんと実装するしかありません。</p>

<p>open redirector だらけで state パラメータもまともに使っていないような OAuth Client なんて、もう救いようが&hellip;(ry</p>

<p>まぁ、みんなちゃんとしましょう。</p>

<p>※1「Token 置換攻撃」については、これまでもたびたび書いてきたので、これらの記事をどうぞ。</p>

<ul>
<li><a href="http://www.atmarkit.co.jp/ait/articles/1209/10/news105_2.html">@IT &ndash; RFCとなった「OAuth 2.0」――その要点は？ (2/2)</a></li>
<li><a href="http://oauthjp.github.io/blog/2012/02/08/ios-sdk/">&ldquo;なんちゃら iOS SDK&rdquo; でありそうな被害例</a></li>
<li><a href="http://oauthjp.github.io/blog/2012/02/07/oauth-20-implicit-flow/">「OAuth 2.0 (Implicit Flow) でログイン」の被害例</a></li>
<li><a href="http://oauthjp.github.io/blog/2012/06/29/oauth-20-implicit-flow-78852/">OAuth 2.0 Implicit Flow で認証の問題点、再び。</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Covert Redirect で Query 漏れるケースもある!?]]></title>
    <link href="http://oauthjp.github.io/blog/2014/05/08/covert-redirect-and-non-30x-redirects/"/>
    <updated>2014-05-08T15:47:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/05/08/covert-redirect-and-non-30x-redirects</id>
    <content type="html"><![CDATA[<p>Covert Redirect 連載最後は、location.href とか &lt;meta http-equiv=&ldquo;Refresh&rdquo;&gt; とかだと referrer 通じて query に含まれる code とかも漏れるかもね！ってお話です。</p>

<p>古いサイトですが、こことか見れば大体いいんじゃないでしょうか => <a href="http://www.teria.com/~koseki/memo/referrer/">リファラ実験</a></p>

<p>で、こういうリダイレクトをしてる箇所が OAuth 2.0 の redirect_uri なり OpenID 2.0 の return_to なりに指定されていれば、query に付いた code なり email なりがリファラ経由で外部に漏れるよね、という。</p>

<p>はい、漏れますね！ (投げやり</p>

<p>さて、そんなに該当例多くはないと思うのですが、ここまで該当してしまったサービスは、どうしますかねぇ&hellip;</p>

<p>Facebook であれば、<a href="http://oauthjp.github.io/blog/2014/05/08/facebook-login-and-covert-redirect/">Facebook Login で Covert Redirect を防止する</a>にあるような方法で回避できますが、それ以外の OAuth Provider なり OpenID 2.0 Provider と連携してる場合は、困っちゃいますねぇ&hellip;</p>

<!-- more -->


<h3>被害例</h3>

<p><a href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect/">OAuth 2.0 の code が漏れた場合について</a>は既に書きました。</p>

<p>Client が redirect_uri 上で state パラメータのチェックを怠っていれば、code 置換攻撃が可能になるっていうアレです。</p>

<p>OpenID 2.0 のレスポンスパラメータが漏れた場合は、そのパラメータに email や name なんかが含まれてる場合があるので、そういった場合はそれらが外部に漏洩します。</p>

<p>また世の中には OpenID 2.0 の nonce を OAuth 2.0 の access token のように使って API アクセスさせる事業者があったりするんで、そういった場合は acccess token 相当のものが漏洩します。</p>

<p>それら access token 相当の nonce が漏れた場合の実害については、提供される API に依存するのでここでは未知です。</p>

<h3>対策方法</h3>

<p>リダイレクト方法変えろ、って以外の回避策を思いついたら、この下に書きます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Facebook Login で Covert Redirect を防止する]]></title>
    <link href="http://oauthjp.github.io/blog/2014/05/08/facebook-login-and-covert-redirect/"/>
    <updated>2014-05-08T14:16:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/05/08/facebook-login-and-covert-redirect</id>
    <content type="html"><![CDATA[<p><a href="http://oauth.jp/blog/2014/05/07/covert-redirect-in-implicit-flow/">OAuth 2.0 Implicit Flow では Covert Redirect 経由で access token が漏れる件</a>については既に紹介しましたが、ここではみなさん大好き Facebook Login で OAuth Client Developer ができる対策について紹介することにします。</p>

<h3>攻撃方法</h3>

<ol>
<li>攻撃対象となる OAuth Client の FB client_id を取得

<ul>
<li>client_id は FB Login ボタンさえクリックすればアドレスバーに表示される。</li>
</ul>
</li>
<li>Authorization Request URL を構築

<ul>
<li>対象 Client が通常 response_type=code を使ってる場合でも、問答無用で response_type=token にしてください。</li>
<li><a href="https://www.facebook.com/dialog/oauth?client_id=relace-me&amp;redirect_uri=relace-me&amp;response_type=token">https://www.facebook.com/dialog/oauth?client_id=<em>&lt;client_id></em>&amp;redirect_uri=<em>&lt;redirect-url></em>&amp;response_type=token</a></li>
</ul>
</li>
<li>被害者を2で作った URL にアクセスさせます

<ul>
<li>フィッシングがんばってください。</li>
</ul>
</li>
<li>redirect_uri に指定しておいた URL で fragment に付いて来る access token を待ち構えます。</li>
</ol>


<p>以上、巧いフィッシング方法さえ思いつけば簡単ですね。</p>

<h3>防御方法</h3>

<p>防御方法は、大きく分けて3つあります。</p>

<ol>
<li>open redirector を撤廃する</li>
<li>response_type=token を利用禁止にする</li>
<li>redirect_uri を完全一致しか認めさせなくする</li>
</ol>


<!-- more -->


<h4>open redirector を撤廃する</h4>

<p>まぁそらそれがベストですよね。</p>

<p>「あっ、はい」とか言う人いるけども。</p>

<p>まぁ、「それができれば最初っからやってるっちゅうねん」ってのは、ごもっとも。</p>

<h4>response_type=token を利用禁止にする</h4>

<p>FB にはそのためのオプション &ldquo;<a href="https://developers.facebook.com/docs/graph-api/securing-requests/">appsecret_proof</a>&rdquo; があります。</p>

<p>厳密には response_type=token を利用禁止にするのではなく、access token 単体で API Request をさせない、というオプションです。</p>

<p>このオプションを有効化すると、API Request に client_secret が必要になるため、client_secret が漏洩しない限りは、たとえ access token が漏洩してしまっても問題ありません。</p>

<p>え？client_secret が漏洩するかもって？</p>

<p>そんな、OAuth 1.0 じゃあるまいし、まさか Native App に client_secret 埋め込んだりしてないはずですよね？ね？？</p>

<p>なおこのオプションを有効にできるのは、client_secret を秘匿に保てる Client、つまりサーバーサイドで動作する Web App に限られます。</p>

<p>Client が Native App な場合や、Web App と Native App の両方で同じ client_id を使っている場合は、このオプションは選べません。</p>

<p>2014年5月現在では、このオプションは以下の URL から &ldquo;App Secret Proof for Server API calls&rdquo; というのを ON にすれば有効化されます。
<a href="https://developers.facebook.com/apps/:app_id/settings/advanced/">https://developers.facebook.com/apps/:app_id/settings/advanced/</a></p>

<h4>redirect_uri を完全一致しか認めさせなくする</h4>

<p>デフォルトでは redirect_uri の部分一致を許容する Facebook ですが、redirect_uri を完全一致のみ許可させるよう指定することもできます。</p>

<p>2014年5月現在では、このオプションは以下の URL から &ldquo;Valid OAuth redirect URIs&rdquo; というのを field に URL を指定すれば有効化されます。
<a href="https://developers.facebook.com/apps/:app_id/settings/advanced/">https://developers.facebook.com/apps/:app_id/settings/advanced/</a></p>

<p>Native App でも利用する client_id に関しては、このオプションを利用しましょう。</p>

<p>Web App でも、OAuth 2.0 の独自拡張である <a href="https://developers.facebook.com/docs/graph-api/securing-requests/">appsecret_proof</a> を利用するよりも、OAuth 2.0 の仕様に乗っ取った挙動になるこのオプションの方が、ライブラリをそのまま使えるとかいろいろメリット多そうですね。</p>

<p>みなさんのユースケースにあったオプションをお選びください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenID 2.0 における Covert Redirect と RP Discovery]]></title>
    <link href="http://oauthjp.github.io/blog/2014/05/08/covert-redirect-and-openid-2-dot-0/"/>
    <updated>2014-05-08T10:57:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/05/08/covert-redirect-and-openid-2-dot-0</id>
    <content type="html"><![CDATA[<p>さて、<a href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect-in-implicit-flow/">OAuth 2.0 &amp; OpenID Connect における Covert Redirect の問題</a> についてはまとめたので、次は OpenID 2.0 についてです。</p>

<p>いいですか、OpenID Connect ではなく、OpenID 2.0 ですよ。古い方です。懐かしいですね、<a href="http://openid.net/specs/openid-authentication-2_0.html">OpenID Authentication 2.0 &ndash; Final</a>。</p>

<p>そういえば、OpenID Foundation Japan の翻訳 WG を立ち上げて、一番最初に翻訳したのが <a href="http://openid-foundation-japan.github.io/openid-authentication.html">OpenID Authentication 2.0 の 日本語訳</a>でしたね&hellip;(遠い目</p>

<p>と、昔話はそれくらいにして、本題に入りましょう。</p>

<h3>まずは Covert Redirect 発生条件について</h3>

<p>OpenID 2.0 では、レスポンスパラメータは query に引っ付いてきます。fragment は使いません。</p>

<p>なので、open redirector のリダイレクト先には、通常はレスポンスパラメータは渡りません。</p>

<p>全ての query パラメータをリダイレクト先に引き継いでしまうという、奇妙な open redirector を用意してる場合にのみレスポンスパラメータが外部に漏洩します。</p>

<p>まずはこの時点でそんなに心配することはなさそうですね。</p>

<p>まぁでもせっかくなんで、話続けますね。</p>

<!-- more -->


<h3>RP Discovery ってのがあってだな</h3>

<p>さて、OpenID 2.0 には、<a href="http://openid.net/specs/openid-authentication-2_0.html#rp_discovery">RP Discovery というものが定義されていた</a> (<a href="http://openid-foundation-japan.github.io/openid-authentication.html#rp_discovery">翻訳版はこちら</a>) のを、おぼろげに覚えている方もおられるのではないでしょうか？</p>

<p>え、そんなの聞いた事が無い？でしょうね！w</p>

<p>OpenID 2.0 は OAuth とちがって、通常 RP が OP に対して事前登録を行うことはありません。</p>

<ul>
<li>RP: Relying Party, OAuth 2.0 の Client 相当</li>
<li>OP: OpenID Provider, OAuth 2.0 の Server 相当</li>
</ul>


<p>OP と RP の間では、動的に association というものを確立します。association って何？って人には、「最初に Temporary な共有秘密鍵をする」って言っちゃえばいいですかね。</p>

<p>association が確立されると、RP は各種リクエストパラメータと共に return_to (OAuth 2.0 の redirect_uri 相当) ってのを指定して、ユーザーを OP にリダイレクトさせます。</p>

<p>で、OP はユーザー認証とか同意取得とか OAuth と似たようなことしてから、最終的に各種レスポンスパラメータを添えてユーザーを指定された RP の return_to にリダイレクトして戻します。</p>

<p>で、ここまでが全部 dynamic なんで、事前登録された return_to との完全一致、なんてことがそもそもありえないんです。</p>

<h3>RP Discovery ってのがあってだな (part 2)</h3>

<p>まぁ既に RP Discovery についての記述を読んだみなさんには釈迦に説法、ネコに小判ですか？あれですね、日本語難しいですね。</p>

<p>まぁあれです、OpenID 2.0 の仕様だけで RP Discovery 理解しろとかムリゲーな気がします。Yadis ってのがあってだな&hellip;いや、やめよう。</p>

<p>実際に、これまた懐かしの iKnow! を例に、RP Discovery ってのを概観してみましょう。</p>

<p>まず iKnow! に OpenID でログインする際のリクエストパラメータを眺めると、&#8221;openid.realm=<a href="https://*.iknow.jp/open_ids">https://*.iknow.jp/open_ids</a>&#8221; ってのが含まれてるのが分かるかと思います。</p>

<p>iKnow! はちょっとレアケースで、サブドメインを許可する為に &ldquo;*.iknow.jp&rdquo; になってますが、そういう場合は &ldquo;*&rdquo; を &ldquo;www&rdquo; に置き換えて &ldquo;<a href="https://www.iknow.jp/open_ids">https://www.iknow.jp/open_ids</a>&rdquo; にアクセスします。</p>

<script src="https://gist.github.com/nov/c702782baa98c75702dc.js"></script>


<p>あ、リダイレクトしましたね。これは follow します。</p>

<script src="https://gist.github.com/nov/67c491166bed6f9cdb7e.js"></script>


<p>で、このレスポンスヘッダに注目です。</p>

<pre>X-XRDS-Location: https://iknow.jp/discovery.xrds</pre>


<p>XRDS ってのがありますね。これが、RP の metadata が記述されたドキュメントです。</p>

<p>で、今度はこの XRDS endpoint にアクセスします。</p>

<script src="https://gist.github.com/nov/b6173c3195fa49e1c668.js"></script>


<p>はい、return_to が指定されてますね。</p>

<pre>&lt;Service priority="0"&gt;
  &lt;Type>http://specs.openid.net/auth/2.0/return_to&lt;/Type&gt;
  &lt;URI>https://iknow.jp/open_ids?_method=GET&lt;/URI&gt;
&lt;/Service&gt;</pre>


<p>で、RP Discovery をサポートしてる OP は、RP の realm にアクセスしてみて、レスポンスヘッダに &ldquo;X-XRDS-Location&rdquo; ってのがあれば、return_to の検証を行う、ってのが一般的な実装かと思います。</p>

<h3>RP Discovery って必要なの？</h3>

<p>大概の OP では不要です。</p>

<p>てか RP 側の人たちはこれほとんど知らんかったんじゃないかと。</p>

<p>噂によると一部 OP では RP Discovery が必須なやつもいるらしいですが、Gooogle, Yahoo! Japan, mixi はじめ、ほぼ全ての主要 OP では RP Discovery は OPTIONAL です。</p>

<p>また XRDS 中の return_to に指定されている URL とリクエストパラメータに含まれる return_to のマッチングルールも、完全一致だったり部分一致だったりは OP ごとに違うようです。</p>

<p>さらには RP 側が &ldquo;X-XRDS-Location&rdquo; を返さない限り、OP 側では RP Discovery をスキップします。</p>

<p>よって、RP Discovery を実装していない RP に open redirector が存在する場合は、それが悪用されるケースはあり得ます。(まぁこの記事の先頭で紹介した発生条件を満たす open redirector が存在するケースは稀ですが)</p>

<h3>対策</h3>

<p>まず query を全部引き継いでリダイレクトするのやめましょう。いや、そもそもみなさんはそんなことしてないと思いますけど。</p>

<p>RP Discovery は、まぁ頑張ってやってみてもいいかもしれないけど、結構複雑なのであまり気軽に実装できる気はしません。</p>

<p>&hellip;懐かしかったですね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implicit Flow では Covert Redirect で Token 漏れるね]]></title>
    <link href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect-in-implicit-flow/"/>
    <updated>2014-05-07T18:41:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/05/07/covert-redirect-in-implicit-flow</id>
    <content type="html"><![CDATA[<p>この記事は、<a href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect">先ほど書いたこちらの記事</a>の訂正版です。</p>

<p><strong>記事に入る前に、まずは全シンガポールにお詫び申し上げますm<em> </em>m</strong></p>

<p>さて、Covert Redirect についての説明は&hellip;超絶取り消し線はいりまくってる前の記事を読んでください、でいいでしょうか？</p>

<p>で、訂正分だけ以下に。</p>

<h3>Fragment Handling in Redirect</h3>

<p><a href="http://weblog.bulknews.net/post/85008516879/covert-redirect-vulnerability-with-oauth-2">宮川さんが記事にしてますね</a>。</p>

<p>英語だけど。</p>

<p>で、まぁ要するに、(Modern Browser は) 30x リダイレクト時に<strong>リダイレクト元に付いてた URL fragment をリダイレクト先にも引っ付ける</strong>、と。</p>

<p>fragment は server-side には送られないけど、クライアントサイドではリダイレクト先に引き継がれる、と。</p>

<p>試しに <a href="http://www.idcon.org/#foobar">http://www.idcon.org/#foobar</a> にアクセスすると、<a href="http://idcon.org/#foobar">http://idcon.org/#foobar</a> にリダイレクトされるかと思います。</p>

<p>www.idcon.org のサーバーには <strong>#foobar</strong> の部分は送られませんが、<a href="http://idcon.org/">http://idcon.org/</a> に load される client-side の JS からは、<strong>#foobar</strong> にアクセスできます。</p>

<p>なので、Covert Redirect のケースでも、open redirector をつかって最終的に被害者がリダイレクトしてくる endpoint に攻撃者が JS を仕込んでそれを自分のサーバーにでも送るようにしておけば、<strong>access token が漏洩します</strong>。</p>

<p>もちろん<a href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect">先ほどの記事にあるように</a>、Authorization Code が漏洩するケースもありますが、open redirector の実装詳細に依存しない分、Implicit Flow において fragment に含まれる access token が漏洩する方が可能性としては高いでしょう。</p>

<!-- more -->


<h3>仕様のバグではないが&hellip;</h3>

<p><a href="http://weblog.bulknews.net/post/85008516879/covert-redirect-vulnerability-with-oauth-2">宮川さんが記事</a>にもあるように、<a href="http://tools.ietf.org/html/rfc6819">RFC6819 &ndash; OAuth 2.0 Threat Model and Security Considerations</a> の <a href="http://tools.ietf.org/html/rfc6819#section-4.2.4">Section 4.2.4</a>, <a href="http://tools.ietf.org/html/rfc6819#section-5.2.3.5">Section 5.2.3.5</a> あたりにはこの問題が指摘されています。(<a href="http://openid-foundation-japan.github.io/rfc6819.ja.html">RFC6819 翻訳版はこちら</a>)</p>

<p>また <a href="http://tools.ietf.org/html/rfc6749">RFC6749 &ndash; The OAuth 2.0 Authorization Framework</a> の <a href="http://tools.ietf.org/html/rfc6749#section-3.1.2.2">Section 3.2.2.1</a> では redirect_uri の<strong>部分一致は query にしか</strong>認められていません。domain のみのマッチングや path の一部のみの一致で OK にしてしまうのは、実装上のバグと言えるでしょう。(<a href="http://openid-foundation-japan.github.io/rfc6749.ja.html">RFC6749 翻訳版はこちら</a>)</p>

<p>OpenID Connect では、query も含めて <strong>redirect_uri の部分一致を認めていません</strong>。(<a href="http://openid.net/specs/openid-connect-core-1_0.html#ImplicitAuthRequest">OpenID Connect Core Section 3.2.2.1</a> 参照, <a href="http://openid-foundation-japan.github.io/openid-connect-core-1_0.ja.html#ImplicitAuthRequest">日本語版はこちら</a>)</p>

<p>OAuth 1.0 では Refresh Token Secret が漏れない限り Access Token が Covert Redirect 経由で漏洩することは無いですし、OpenID 2.0 でも RP Discovery というのをきちんとやっていれば、redirect_uri の exact match 相当のことができます。</p>

<p>なので、特に Covert Redirect がこれらの仕様のバグであるということではありません。</p>

<p>が、まずい実装は結構ある、というのが、<a href="http://tetraph.com/covert_redirect/oauth2_openid_covert_redirect.html">元記事</a>の Provider List が伝えたかったことなのでしょう。</p>

<p>まぁ確かに redirect_uri の部分一致認めてる OAuth Server なんてそこら中にあるし、OpenID 2.0 に至っては RP Discovery 必須な OP ってどこよ？、みたいな状態ですし、OpenID Connect 実装って言っても完全に OpenID Connect の仕様に準拠してるかどうかあやしいですし&hellip;</p>

<p>いや、Google の Connect 実装は exact match ですよ。でも元記事見る限り、Google のは OpenID 2.0 実装が問題にされてますね。</p>

<p>Y!J の OpenID Connect も redirect_uri の部分一致は認められていないので、大丈夫です。</p>

<p>mixi と楽天の OAuth 2.0 実装は、そもそも Implicit Flow サポートしてません。</p>

<p>OpenID 2.0 実装に関しては&hellip;<a href="http://oauthjp.github.io/blog/2014/05/08/covert-redirect-and-openid-2-dot-0">別記事にまとめました</a>。</p>

<h3>攻撃パターン</h3>

<p>攻撃者は、redirect_uri を Client 上に存在する open redirector の endpoint に書き換えたリンクを被害者に踏ませます。</p>

<p>このリンクを踏ませる方法は何でもいいのですが、Client 側に悪意が無い限り、基本的には「通常のフロー」とは異なる方法でリンクを踏ませることになるでしょう。フィッシングですね。</p>

<p>で、あとは被害者が同意ボタンを押せば、open redirector 経由で攻撃者が指定した URL に、(ユーザーが Modern Browser を利用している場合は) fragment に access token を含んだ状態で、被害者がアクセスしてきます。</p>

<p>あとはその fragment から JS をつかって access token を抜き出して&hellip;ってのはこの記事冒頭でも書きましたね。</p>

<h3>対策</h3>

<h4>Server 側ができること</h4>

<p>redirect_uri の完全一致を必須にする。</p>

<p>いままで動いてた既存アプリが突然動かなくなるケースもあるでしょうし、そうそう気軽に変更できる部分では無いかもしれませんが、ある程度の猶予期間を用意した上で、redirect_uri の完全一致を必須にするのが良いでしょう。</p>

<p>あと、そもそもこの問題が自社の各プロトコル実装で置きうるのかどうか、redirect_uri の検証方法をいま一度 Developer 向けに広報する、とかはやった方がいいかもしれませんね。</p>

<h4>Client 側ができること</h4>

<p>例えば Facebook は、redirect_uri の完全一致を行うようにアプリ設定画面で指定することができます。(Advanced Settings の &ldquo;Valid OAuth redirect URIs&rdquo; ってやつ)</p>

<p>&ldquo;Valid OAuth redirect URIs&rdquo; はデフォルトでは空っぽで、その状態では redirect_uri の部分一致が許容されますが、ここに URL を指定することでFB 側に redirect_uri の完全一致を要求することができます。</p>

<p>そもそも Implicit Flow なんてつかわねーよ、って場合は、<a href="https://developers.facebook.com/docs/graph-api/securing-requests/">appsecret_proof</a> なんていう FB の独自拡張を利用することもできそうですが、まぁこれはそのうち調べようと心に誓いつつ全く調べてないのでよく知らないです。</p>

<p>あと open redirector 作らない、ってのね。</p>

<p>こらそこ、「あっ、はい」とか言わない。</p>

<h4>User 側ができること</h4>

<p>フィッシングに引っかかるな、くらいしか思いつかないですが、まぁそれじゃ引っかかる時は引っかかるでしょうね&hellip;</p>

<p>Client と Server が頑張る、のを応援する、ってのが一番いいかもしれませんね。</p>

<h3>最後に</h3>

<p>改めまして、全シンガポールにお詫び申し上げますm<em> </em>m</p>

<p>あと Twitter で mention いただいた <a href="https://twitter.com/miyagawa">@miyagawa</a> さんと、LINE の某厨部屋で連絡くれた <a href="https://twitter.com/mad_p">@mad_p</a> さん、ありがとうございますm<em> </em>m</p>
]]></content>
  </entry>
  
</feed>
