<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[OAuth.jp]]></title>
  <link href="http://oauthjp.github.io/atom.xml" rel="self"/>
  <link href="http://oauthjp.github.io/"/>
  <updated>2016-02-24T14:51:11+09:00</updated>
  <id>http://oauthjp.github.io/</id>
  <author>
    <name><![CDATA[Nov Matake]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[OpenID Connectはそんなに大変かね？]]></title>
    <link href="http://oauthjp.github.io/blog/2016/02/24/is-openid-connect-far-from-oauth2/"/>
    <updated>2016-02-24T11:14:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/02/24/is-openid-connect-far-from-oauth2</id>
    <content type="html"><![CDATA[<p><a href="http://qiita.com/TakahikoKawasaki/items/f2a0d25a4f05790b3baa">OAuth 2.0 + OpenID Connect のフルスクラッチ実装者が知見を語る &ndash; Qiita</a> ってのになんかフォローアップしろよ的なのが来たので。</p>

<p>ざっと読んだ感想としては、「まぁ OpenAM みたいな感じの、OpenID Connect の OPTIONAL な機能全部実装したら、そら大変ですね」という感じでしょうか。(Authlete に関しては、OpenAM みたいな感じで使われる有料の何かなんだろうな、くらいしか知らないです)</p>

<h2>OAuth は必要なのか？</h2>

<ul>
<li>Basic 認証は死んだ。</li>
<li>ユーザー単位での API のアクセスコントロールがしたいです。</li>
</ul>


<p>っていう前提で話すると、OAuth 以外まともな選択肢が無いんじゃないでしょうか。</p>

<p>あ、Session Cookie で事足りるなら、それでもいいかとは思います。</p>

<p>自社内だからオレオレでやるわ〜、ってのは、インターネットに公開してる時点でもはや自社内に限定された話じゃ無いんじゃないですかね？という気がします。</p>

<p>ただ、自社内でやる場合、OAuth の仕様書にある OPTIONAL な機能は、基本実装しなくて事足りるんじゃ無いかとも思います。</p>

<h2>「OAuth 認証」とは</h2>

<p>OAuth は「End-User (に信頼された OAuth Server) が OAuth Client のアクセス権限をコントロールする」というコンテキストにおいての標準化されたプロトコルであって、「Identity Provider が End-User を認証した結果を受け取って、Relying Party が (Identity Provider への信頼を元に) End-User を認証する」というコンテキストで OAuth を使うユースケースが「OAuth 認証」と呼ばれるやつです。</p>

<p>後者のコンテキストで、OAuth は何も標準的な仕様を定めてはいません。</p>

<p>Identity Provider が End-User を認証した結果のやりとり (ID Token 相当) や、そのコンテキストで求められることが多い認証されたユーザー属性情報のやりとり (UserInfo 相当) については、完全に各 Platform が独自 API を提供してるだけなので、そういう意味では「OAuth 認証」ってのは「オレオレ Connect」みたいなもんですね。</p>

<p>まぁでも「オレオレ OAuth」の上で「オレオレ Connect」やる「JWT 認証」よりはマシなんじゃないかなっていう気はします。</p>

<h2>OpenID Connect ドキュメントの読み方</h2>

<p>うん、OpenID Connect の仕様書は、全部読むと大変ですね。Discovery とか Dynamic Registration は読む必要無かったと思うけど、読む必要あるかどうかを判断するのは確かに大変ですね。</p>

<p>IdP 実装する人は、基本は <a href="http://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect Core 1.0</a> だけ読めば十分ですよ。</p>

<p>RP 実装する人は、その RP が Web サイトなら <a href="http://openid.net/specs/openid-connect-basic-1_0.html">OpenID Connect Basic Client Implementer&rsquo;s Guide 1.0</a> だけで十分。</p>

<p>Native アプリなら&hellip; Google Platform のドキュメントが一番いい気がするけど、Native アプリ (とその Backend Server) を含めた RP に対する標準的なやり方は、まだ固定されていないというのが正直な所ではないでしょうか。ここは今後の課題。</p>

<p>(仕様策定時に想像できた) あらゆる RP のユースケースに答える、様々なポリシーを持つあらゆる IdP を作るためのツールを作る人は、IETF OAuth WG で議論されてる全ての RFC &amp; Internet Draft と OpenID Foundation で議論されてる仕様、一式全部読むんでしょうね。</p>

<p>まぁそういう人は、そら大変ですよね。</p>

<h2>クライアントアプリケーションのメタ情報、多すぎ問題</h2>

<p>えっと、そもそも、Dynamic Client Registration、きっと使わないです。</p>

<p>Dynamic Client Registration を検討してるって人がもしいたら、まずは <a href="https://tools.ietf.org/html/rfc7636">OAuth PKCE</a> ってので代用できないか検討するがいいかと思います。</p>

<p>Dynamic Client Registration をセキュアにやる方法は、OAuth WG と OpenID Connect の関連仕様を全部読んでもまだ足りないと思います。</p>

<p>それでも Dynamic Client Registration したいんだ！って人は&hellip;PKI まわりの技術一通り把握したら、使いこなせる&hellip;のかな&hellip;？</p>

<p>うん、僕、そういう人が出てきてから考えますね。</p>

<p>あ、Trust Framework 作りたいんだ！とかいう人は、Dynamic Registration 読むべきだとは思います。使うかどうかは別として。</p>

<h2>Unsigned JWT 作れない問題</h2>

<p>UserInfo Response を Unsigned JWT にするってのも、きっと使わないです。</p>

<p>署名の無い URL-safe Base64 Encoded な JSON (= Unsigned JWT) とか、素の JSON より decode がちょっとめんどいっていう以外に、どんな意義があるというのでしょうか？</p>

<p>UserInfo Response を Singed and/or Encrypted JWT にするってのも、まず使わないでしょう。</p>

<p>「Aggregated Claims が使いたいんだ！」っていう人は検討してもいいですが、「Aggregated Claims って何？」っていう人は、その Aggregated Claims も使うこと無いでしょうから別にいいです。</p>

<p>（あ、話はちょっと逸れますが、Dynamic Registration で Public Client 登録したいっていう意図は、僕にはさっぱりです。動的に redirect_uri が増えるけど、redirect_uri の検証は exact match を維持したい、とか？）</p>

<h2>redirect_uri は必須か？</h2>

<p><a href="http://openid.net/specs/openid-connect-core-1_0.html#TokenRequestValidation">Token Request Validation</a> では redirect_uri の省略を許しつつも Authentication Request の Section では REQUIRED としか書いてない Connect Core が、読みづらいですね。</p>

<p>Connect でも OAuth との整合性を保つため redirect_uri が1つの場合は省略可能としてもいいですが、OAuth Server のポリシーとして Authorization Request に redirect_uri を必須にしても良いです。</p>

<p>openid scope の有無でそこが切り替わるっていう実装は&hellip;余計わかりづらく無いでしょうか？</p>

<h2>さいごに</h2>

<p>Qiita の記事を読む限り、Authlete では RP が幅広い OPTIONAL な機能を選択できるようなので、その選択で本当に大丈夫なのかの判断はなかなか高度な仕様理解を求めそうです。</p>

<p>どういうユースケースの場合はどういう OPTIONAL が選択された、っていうノウハウが溜まっていくと、特に B2C の分野ではニーズ高そうな気がします。</p>

<p>あと、どこかのタイミングで「実際には一度も選択されたことの無い OPTIONAL 機能」とかリストで公開してもらって、それらがどういうときに使われるのかを議論する #idcon とか、ニッチな ID 厨に受ける気がしますね :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth IdP Mix-up Attack - part II]]></title>
    <link href="http://oauthjp.github.io/blog/2016/01/25/oauth-idp-mix-up-attack-part-ii/"/>
    <updated>2016-01-25T15:59:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/01/25/oauth-idp-mix-up-attack-part-ii</id>
    <content type="html"><![CDATA[<p><a href="http://oauth.jp/blog/2016/01/12/oauth-idp-mix-up-attack/">OAuth IdP Mix-Up Attack とは？</a> のつづき。</p>

<p>OAuth ML上で、以下のどちらを採用すべきかについての議論が収まる気配のない昨今です。</p>

<ul>
<li><a href="http://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation">http://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation</a></li>
<li><a href="http://tools.ietf.org/html/draft-sakimura-oauth-meta">http://tools.ietf.org/html/draft-sakimura-oauth-meta</a></li>
</ul>


<p>そんななか、もうちょっとややこしいというか致命的なケースが出て来ました。</p>

<ul>
<li><a href="http://nat.sakimura.org/2016/01/22/code-phishing-attack-on-oauth-2-0-rfc6749/">Code phishing attack on OAuth 2.0 [RFC6749] | .Nat Zone</a></li>
</ul>


<p>&ldquo;Mix-up Attack&rdquo; っていうやつの話をしてたはずが、いつのまにか &ldquo;Code Phishing Attack&rdquo; って名前になっててもはや2つの違いがよく分かんなくなってきますが、ブログ記事中では「フィッシングメールをRP Developerに送って、Client DeveloperにToken Endpointを書き変えさせる」というパターンが例示されています。</p>

<p>いや、そんなんに騙されるやつおらへんやろ〜、ってのがだいたいの反応かとは思いますし、RP Developerのみなさんがちゃんと注意しれてばそれで十分な話ではあるかと思います。</p>

<p>が、IdP視点でいうと、アホなRPからユーザーさんのTokenとかそのRPのclient_secretとかがだだ漏れになっちゃうとIdPのレピュテーションにひびいたりするので、なかなかつらいところです。</p>

<p>もはやここまで騙されてる状況では、Authorization Response以外何も信用できない訳で、Authorization Endpointにiss含んでも、issに紐付いたIdP Configがstaticにhard-codeされてるなら、そのhard-codeされてるconfig自体信用できないということになります。</p>

<p>「IdPごとに別のredirect_uriを使う」なんてのも、もはや無意味ですね。</p>

<p>response_type=code+id_tokenとして、fragmentについてきたID Tokenをチェックしても、Discovery無しだとダメでしょう。</p>

<p>そのため、IdPが取れる対応策は以下の2つのどちらかになるでしょう。</p>

<ul>
<li>issを返しつつ、OAuth Discoveryをサポートする</li>
<li>OAuth MetaのようにToken Endpoint URLをAuthZ Responseに含める</li>
</ul>


<p>前者は <a href="http://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation">http://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation</a> をより厳しくしたもので、後者は <a href="http://tools.ietf.org/html/draft-sakimura-oauth-meta">http://tools.ietf.org/html/draft-sakimura-oauth-meta</a> そのものです。</p>

<p>個人的にはOAuth Discoveryが必須になるとHTTP Requestが増えるので、IdP的にはあまり嬉しくないなぁと思います。</p>

<p>ps.</p>

<p>Implicit FlowにおいてResource Endpointが書き換えられていることを想定したケースでは、AuthZ ResponseにResource Endpoint(s) を含めることになって、Code Flowよりさらにややこしい話になるわけですが、それはまた別の機会に&hellip;書く&hellip;かも。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth IdP Mix-Up Attack とは？]]></title>
    <link href="http://oauthjp.github.io/blog/2016/01/12/oauth-idp-mix-up-attack/"/>
    <updated>2016-01-12T15:51:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2016/01/12/oauth-idp-mix-up-attack</id>
    <content type="html"><![CDATA[<p>成人式を迎えられたID厨の皆様におかれましては、大変おめでとうございます。成人前からID厨とか、キモカワですね。</p>

<p>さて、今日は、成人式直前にOAuth MLに投下された以下のpostで「OAuth 2.0の脆弱性」として紹介されている &ldquo;IdP Mix-Up Attack&rdquo; について紹介します。</p>

<p><a href="https://mailarchive.ietf.org/arch/msg/oauth/JIVxFBGsJBVtm7ljwJhPUm3Fr-w">[OAUTH-WG] OAuth Security Advisory: Authorization Server Mix-Up</a></p>

<h2>前提条件</h2>

<ul>
<li>End-UserとRPの間の (TLS-protectedでない) HTTP Request/ResponseをAttackerがproxy可能。</li>
<li>RPが2つ以上のOAuth Server (IdP) と接続しており、そのいずれかが攻撃者の管理下にある。(IdPの中の人が実は攻撃者だった etc.)</li>
<li>RPは複数のIdPに対して共通のredirect_uriを利用しており、そこへのcallbackを受け取った時にstate値を元にIdPを特定する。

<ul>
<li>ただしIdP側のredirect_uri検証が「事前登録済の値との完全一致」でない場合は、この通りではない。</li>
</ul>
</li>
</ul>


<h2>攻撃フロー</h2>

<p>以下、Attackerの管理下にあるIdPをAIdP (Attacker IdP)、その他の悪意ないIdPをHIdP (Honest IdP) と呼ぶことにします。</p>

<p><img src="http://oauthjp.github.io/images/posts/oauth-idp-mixup.png" alt="OAuth IdP Mix-Up Attack" /></p>

<ol>
<li>End-UserはRPの任意のページから「HIdPでログイン」ボタンをクリック。</li>
<li>Browser->RPへの (TLS-protectedでない) リクエストをProxyしたAttackerは、RPに「AIdPでログイン」するリクエストを送信し、AIdPのAuthorization EndpointへのRedirect Responseを受け取る。</li>
<li>AttackerはBrowserにHIdPのAuthorization EndpointへのRedirect Responseを返す。ただしstate値は2で受け取った「AIdP向けのAuthorization Requestとひもづいた」値を利用する。(これ以降全リクエストはTLS-protectedであるためAttackerのProxyは介入不可)</li>
<li>End-UserはHIdPでApproveボタンをクリック。</li>
<li>HIdPはstateとcode/tokenをquery/fragmentにつけた状態で、End-UserをRPのredirect_uriに戻す。</li>
<li>code/tokenを受け取ったRPは、state値を元に受け取ったAuthorization ResponseがAIdPからのものだと判断する。</li>
<li>RPはAIdPのToken EndpointやAPI Endpointにcodeやtokenを送りつけてしまい、HIdPのcodeやtokenがAIdP (攻撃者) の手に渡る。</li>
</ol>


<!-- more -->


<h2>対策方法</h2>

<h3>対策方法1</h3>

<p>AIdP向けのredirect_uriとHIdP向けのredirect_uriを分ける。ただしこれが効果を発揮するためには、HIdPがRPからAIdP向けのredirect_uriを受け取った際にエラーになる必要がある。</p>

<h3>対策方法2</h3>

<p>Authorization Responseにcode/token発行者のIdentity情報を含める。</p>

<p>いまOAuth WGで提案されている対応策は、以下の2つです。なんか似たようなのが2つ出てきててカオスですね。</p>

<ul>
<li><a href="http://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation">http://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation</a></li>
<li><a href="http://tools.ietf.org/html/draft-sakimura-oauth-meta">http://tools.ietf.org/html/draft-sakimura-oauth-meta</a></li>
</ul>


<h3>対策方法3</h3>

<p>悪意のある可能性があるIdPを採用しない。(まぁ、普通は採用してないですよね&hellip;)</p>

<h3>どの対応策を採用すべき？</h3>

<p>RPは以上の3つのうちいづれかを採用すれば良いですが、IdPが採用できるのは2しかないですね。</p>

<h2>Malicious Endpoint Attackってのは？</h2>

<p><a href="http://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation">OAuth 2.0 Mix-Up Mitigation &ndash; draft-jones-oauth-mix-up-mitigation-00</a> には、&#8221;IdP Mix-Up Attack&#8221; とは別に &ldquo;Malicious Endpoint Attack&rdquo; ってのが出てきます。</p>

<p>これは、Discovery &amp; Dynamic Client Registrationを前提とした状況で発生する攻撃パターンです。</p>

<p>Dynamic Registrationを前提とすると、「信頼できないIdPを採用しない」という選択肢が取りづらくなるため、より問題が大きくなります。</p>

<p>が、そもそもみなさんそんなDynamic Client Registrationとか使ってないでしょうし、これについての解説はまた機会があればということで&hellip;</p>

<h2>最後に</h2>

<p>ID厨で本当に今年成人式を迎えられたあなた！次回の <a href="http://idcon.org">#idcon</a> の懇親会タダにするんでご容赦くださいm<em> </em>m</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[PR] OpenID Summit Tokyo 2015 やります！]]></title>
    <link href="http://oauthjp.github.io/blog/2015/10/19/openid-summit-tokyo-2015/"/>
    <updated>2015-10-19T11:58:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2015/10/19/openid-summit-tokyo-2015</id>
    <content type="html"><![CDATA[<p>Identity 界隈の皆様は、11/10 に <a href="https://openid.or.jp/summit/2015/index.html">OpenID Summit 2015</a> が開催されることはすでにご存知かと思いますが、OAuth / JWT 愛なみなさまの中にはまだご存知ない方もおられるかもしれないので、こちらでも告知しておきますね。</p>

<p>はい、やります！</p>

<p><a href="https://openid.or.jp/summit/2015/index.html#schedule-timetable">タイムスケジュール</a> みていただいてもおわかりのように、IETF 横浜の翌週というタイミングで、かつ OpenID Foundation (Global の方) の全面協力もあり、OpenID Foundation から主要な外タレ勢揃いな感じでございます。JWT Love なみなさんは、もちろん Mike Jones への愛を忘れたことはないでしょうし、強面やのになぜかプーさんキャラな John Bradley は IETF OAuth WG の各種最新 RFC および draft の解説をしてくれます。</p>

<p>もちろんメインホールでは日本語のセッションもやっとります。日本語セッションは、Identity 技術活用事例とか FINTECH とかマイナンバーとか IDaaS とか&hellip;</p>

<p>あと、毎度おなじみエバ企画、今回は OpenID Connect Certification の体験 Hands-on です。</p>

<ul>
<li>OpenID Connect IdP を実装したけど、本当に自分の実装が OpenID Connect 仕様に準拠してるのか確認したい方</li>
<li>OpenID Connect ライブラリを実装したけど、Connect 準拠の IdP を作るのに事足りるライブラリになってるか確認したい方</li>
<li>なんちゃって Connect 実装とか、なんちゃって OAuth 認証実装したけど、あとどれくらいで Connect 準拠になるのか知りたい方</li>
</ul>


<p>そんな方々に、IdP 実装の Connect 準拠具合をテストするためのツールがあります。</p>

<p>OpenID Connect Certification Hands-on では、テストツールの使い方を紹介後、実際みなさんの実装に対してテストを実行していただき、テストが失敗したものに関する Debug のお手伝い等もさせていただきます。</p>

<p>Global の方の OpenID Foundation からも、Mike Jones が Hands-on 会場に来てくれるようなので、Mike の OpenID Connect Certification のセッションをみた後、そのまま Hands-on に参加すると良いと思います！</p>

<p>ということで、<a href="https://openid.or.jp/summit/2015/index.html">申し込みはこちら</a>！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IETF JOSE WG と OAuth WG から一気に9本の RFC が！]]></title>
    <link href="http://oauthjp.github.io/blog/2015/05/20/jose-and-oauth-assertion-rfcs/"/>
    <updated>2015-05-20T21:05:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2015/05/20/jose-and-oauth-assertion-rfcs</id>
    <content type="html"><![CDATA[<p>一気に出ましたね。すでに過去にもいくつかは紹介したり翻訳したりしていますが、それぞれを簡単に紹介しておきます。</p>

<h3>JOSE WG</h3>

<ul>
<li><a href="http://tools.ietf.org/html/rfc7515">RFC 7515</a> &ndash; JSON Web Signature (JWS)</li>
<li><a href="http://tools.ietf.org/html/rfc7516">RFC 7516</a> &ndash; JSON Web Encryption (JWE)</li>
<li><a href="http://tools.ietf.org/html/rfc7517">RFC 7517</a> &ndash; JSON Web Key (JWK)</li>
<li><a href="http://tools.ietf.org/html/rfc7518">RFC 7518</a> &ndash; JSON Web Algorithms (JWA)</li>
<li><a href="http://tools.ietf.org/html/rfc7520">RFC 7520</a> &ndash; Examples of Protecting Content Using JSON Object Signing and Encryption (JOSE)</li>
</ul>


<p>JWS は署名付きのデータを JSON (の Base64 URL Encode) 形式で表現するための仕様で、多くの場合は JSON Payload に対して署名するケースで利用されます。JSON じゃないデータに対して署名して、署名結果を JSON (の Base64 URL Encode) 形式で表現することもできますが&hellip;まぁ、細かい話は置いときましょう。OpenID Connect の ID Token とかは、JWS 仕様に従って署名されています。</p>

<p>JWE は暗号化されたデータを JSON (の Base64 URL Encode) 形式で表現するための仕様です。現状では JWS よりは利用頻度低いかとは思いますが、SAML Assertion を暗号化してるようなユースケースを Connect に移行する時なんかには使うでしょう。</p>

<p>JWK は JWS や JWE などで利用する鍵を JSON 形式で表現するための仕様です。上記2つとよくセットで利用されます。OpenID Connect でも、OpenID Connect Discovery をサポートしているような IdP では大体公開鍵を JWK Set 形式で公開していますね。</p>

<p>JWA は、JWS や JWE で利用される各アルゴリズムおよびそれらの識別子を定義している仕様です。JWT, JWS, JWE をライブラリを通じて利用しているケースでは、あまり気にすることはないでしょうが、JOSE ライブラリ作者は読むことになるでしょう。</p>

<p>最後のは、サンプルリストですね。これはまぁライブラリ作者が読むくらいでしょう。</p>

<h3>OAuth WG</h3>

<ul>
<li><a href="http://tools.ietf.org/html/rfc7519">RFC 7519</a> &ndash; JSON Web Token (JWT)</li>
<li><a href="http://tools.ietf.org/html/rfc7521">RFC 7521</a> &ndash; Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants</li>
<li><a href="http://tools.ietf.org/html/rfc7522">RFC 7522</a> &ndash; Security Assertion Markup Language (SAML) 2.0 Profile for OAuth 2.0 Client Authentication and Authorization Grants</li>
<li><a href="http://tools.ietf.org/html/rfc7523">RFC 7523</a> &ndash; JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants</li>
</ul>


<p>JWT は JSON (の Base64 URL Encode) 形式で Assertion を生成するための仕様です。OpenID Connect の ID Token などで利用されています。大抵は署名 (= JWS) とセットで利用されるでしょう。</p>

<p>Assertion Framework for OAuth 2.0 (ry) は、任意の Assertion を OAuth 2.0 の Client Authentication で Client Credentials として使ったり、Authorization Grant として利用して Assertion を Access Token と交換するための仕様です。これ単体では利用できず、後の2つのサブ仕様の共通部分を抽象化した仕様になっています。</p>

<p>SAML 2.0 Profile for OAuth 2.0 (ry) は、SAML Assertion を RFC 7521 の Assertion として利用するための仕様です。既存の SAML SP が持っている SAML Assertion を OAuth 2.0 の Access Token と交換して API Access させたいとか、そういう時に使います。「あぁ、それは SAML 単体じゃ無理なんで、ID-WSF 必要ですねぇ〜」って言われたら、多分 ID-WSF 無視してこれ使えば、OAuth 2.0 使えるようになるはずです。</p>

<p>JWT Profile for OAuth 2.0 (ry) は、JWT を RFC 7521 の Assertion として利用するための仕様です。Client Authentication 目的で利用するケースは、ADFS / Azure AD とかであるはずですが、Authorization Grant として利用するケースは&hellip;あったかな？</p>

<h3>Links</h3>

<ul>
<li><a href="http://oauthjp.github.io/blog/2012/10/26/json-web-token-jwt/">JSON Web Token (JWT) &ndash; OAuth.jp</a>

<ul>
<li>もうこの記事書いてから、2年半経ってるんですね〜。感慨深い。</li>
</ul>
</li>
<li><a href="http://oauthjp.github.io/blog/2015/03/16/common-jws-implementation-vulnerability/">JWS 実装時に作りがちな脆弱性パターン &ndash; OAuth.jp</a>

<ul>
<li>すでに JOSE ライブラリは大体出揃ってるので、今後新しく作ることはあまりないかもしれませんが、もし自分で JWS 実装する時は、これ注意してくださいね。</li>
</ul>
</li>
<li><a href="http://openid-foundation-japan.github.io">翻訳ドキュメント一覧 &ndash; OpenID Foundation Japan 翻訳 WG</a>

<ul>
<li>Draft 版の JOSE 仕様群は、こちらに翻訳版あります。</li>
</ul>
</li>
<li><a href="http://www.sakimura.org/2015/05/2997/">JWSとJWTがRFCになりました！ &ndash; @_Nat Zone</a>

<ul>
<li>Nat さんはじめ、みなさんおつかれさまでした！</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[個人情報保護法改正案に見る第三者提供記録義務と越境問題]]></title>
    <link href="http://oauthjp.github.io/blog/2015/03/30/traceability-and-cross-border-data-transportation/"/>
    <updated>2015-03-30T14:19:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2015/03/30/traceability-and-cross-border-data-transportation</id>
    <content type="html"><![CDATA[<p>先日の「<a href="http://oauth.jp/blog/2015/02/28/traceability-on-each-attributes/">属性単位のトレーサビリティについて</a>」という記事でも取り上げましたが、<a href="http://www.cas.go.jp/jp/houan/150310/siryou3.pdf">個人情報保護法改正案</a>では、第二十五条に「第三者提供に係る記録の作成等」という規定が設けられ、第三者提供時に提供者受療者双方に記録義務が発生することとなっています。</p>

<p>また土曜日に行われた情報法制研究会第1回シンポジウムこの提供記録義務と、同じく改正案第二十四条の「外国にある第三者への提供の制限」を組み合わせると、AWSにデータ保存 (委託行為？) するだけで、第三者提供扱いとなり、記録義務が発生してしまうのではという指摘がありました。(まとめからのリンク先、板倉先生の資料参照。パスワードは空気読んで頑張って探してください。)</p>

<p><a href="http://togetter.com/li/801181?page=1">20150328情報法制研究会 第1回シンポジウム「改正個人情報保護法の内容と今後の課題」関連まとめ(私家版)</a></p>

<p>確かに第二十四条では、認定国もしくは認定事業者以外の外国事業者に対するデータ提供の場合は、下記のように第二十三条の例外規定 (委託や共同利用を第三者提供として扱わないという規定含む) を適用しないと明記しているので、委託の場合でも第三者提供扱いとなり、記録義務が発生することになりそうです。</p>

<blockquote>この場合においては、同条の規定は、適用しない。</blockquote>


<p>さらに外国事業者への提供時には、通常の同意とは別に外国事業者への提供であることを明記した上での同意を取得する必要があるため、海外のRPを相手にする国内IdPは、</p>

<ul>
<li>RPが国内事業者であるか否か</li>
<li>RPが海外事業者である場合には認定国の事業者であるか否か</li>
<li>RPが非認定国の事業者である場合には認定事業者であるか否か</li>
</ul>


<p>を判断した上で、いずれにも当てはまらない場合は通常とは別の同意文言を提示する必要が出てきそうです。</p>

<p>いやぁ〜、Dynamic Registrationとかしてる場合じゃないっすね！</p>

<p>どうしましょか、これ？w (ノーアイデァなぅ)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JWS 実装時に作りがちな脆弱性パターン]]></title>
    <link href="http://oauthjp.github.io/blog/2015/03/16/common-jws-implementation-vulnerability/"/>
    <updated>2015-03-16T11:45:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2015/03/16/common-jws-implementation-vulnerability</id>
    <content type="html"><![CDATA[<p>JOSE (Javascript Object Signing and Encryption) 愛で満ち溢れる ID 厨界隈において、燦々と輝く JWS (JSON Web Signature)、美しいですよね！</p>

<p>JWT がジャニーズなら、JWE は EXILE、JWS は石原さとみと言ったところでしょうか？</p>

<p>と、冗談はさておき、JWT をお使いの皆さんは、当然署名付けてますよね？署名検証しますよね？</p>

<p>そんなあなたに一言いいたい！</p>

<p>まだ HMAC で消耗してるの？</p>

<p>いや、決して HMAC オワコンとかは言ってないですよ？スマホアプリでの署名検証のために、アプリに共通鍵埋め込むのはナンセンスってだけで。</p>

<p>ということで、今日は JWS をお使いのみなさんに、実装時に作りがちな脆弱性パターンを2つご紹介します。</p>

<p>今日紹介する脆弱性の2つのうち、1つめは HMAC, RSA, ECDSA のどれを使っても対象になるパターン、2つめは公開鍵暗号 (RSA / ECDSA) を使っている場合にのみ対象になるパターンです。</p>

<p>では、さっそく行ってみましょう。</p>

<!-- more -->


<h2>JWS Header の alg を &ldquo;none&rdquo; に改ざん</h2>

<p>JWS Header には、alg とか typ とか kid とかが入ってるわけですが、この攻撃では alg を &ldquo;none&rdquo; に書き換えます。そして、署名部分をごっそり取り除きます。</p>

<p>例えばこんな JWT を</p>

<pre>
Raw: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQifQ.eyJmb28iOiJiYXIifQ.lmsUbhkgf5KpheRpXwc-pbG_HhYr9Grw1301d0sVzxI
Header: {typ: "JWT", alg: "HS256", kid: "default"}
</pre>


<p>こんな風に</p>

<pre>
Raw: eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIiwia2lkIjoiZGVmYXVsdCJ9.eyJmb28iOiJiYXIifQ.
Header: {typ: "JWT", alg: "none", kid: "default"}
</pre>


<p>これだけで、あとはもう Payload を改ざんし放題。</p>

<p>こういう JWT を受け入れてしまう実装が、意外に多いらしいです。</p>

<p>えぇ、かつて JSON::JWT Gem もそうでした、随分と昔の話ですが。</p>

<p>署名検証する場所では、alg=none な JWT が送られてきたときにちゃんとエラーになるかどうか、確認しましょう。</p>

<h2>JWS Header の alg を &ldquo;HMAC-SHA*&rdquo; に改ざん</h2>

<p>こちらも JWS Header の alg を改ざんするんですが、こちらのケースでは署名はちゃんとついています。</p>

<p>このケースでは、alg を公開鍵暗号方式 (RSA / ECDSA) から共通鍵暗号方式 (HMAC) に差し替え、「公開鍵文字列を共通鍵として利用して」署名を生成します。</p>

<p>前提として、攻撃者が公開鍵を取得できることが必要ですが、まぁ公開鍵は割と誰にでも手に入りそうです。(当社比)</p>

<p>で、今度は Ruby のサンプルコードで説明すると、</p>

<pre>
private_pem = <<-PEM
-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEArUeGng6YrNJT/YbxgWVfJPHtv8tVXNugsuPEt10af+OyCeyk
 :
-----END RSA PRIVATE KEY-----
PEM
private_key = OpenSSL::PKey::RSA.new private_pem

jwt = JSON::JWT.new(foo: :bar)
jws = jwt.sign(private_key, :RS256)
</pre>


<p>だったのを</p>

<pre>
public_pem = <<-PEM
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArUeGng6YrNJT/YbxgWVf
 :
-----END PUBLIC KEY-----
PEM

jwt = JSON::JWT.new(malformed: "something attacker added")
jws = jwt.sign(public_pem, :HS256)
</pre>


<p>にする感じです。</p>

<p>公開鍵をどのようなフォーマットで保存しているかは実装依存でしょうが、その辺は空気読んでいただくとして。</p>

<p>こちらも Payload は改ざんし放題です。</p>

<p>こちらの脆弱性は、JSON::JWT のように公開鍵を鍵オブジェクトとして扱う環境ではエラーになったりしますが、公開鍵を文字列として扱うような環境では以外に署名検証を通過したりしてしまうようです。</p>

<p>例えば PHP とか。</p>

<p>署名検証時に署名アルゴリズムを明示的にチェックするなどの対策が必要でしょう。</p>

<h2>まとめ</h2>

<p>僕らの JOSE 愛は、こんなことじゃめげないですよ！</p>

<p>でも、気をつけましょうね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[PR] 属性単位のトレーサビリティについて]]></title>
    <link href="http://oauthjp.github.io/blog/2015/02/28/traceability-on-each-attributes/"/>
    <updated>2015-02-28T23:10:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2015/02/28/traceability-on-each-attributes</id>
    <content type="html"><![CDATA[<p>来週月曜 (2015/03/02) <a href="http://www.openid.or.jp/news/2015/02/OpenIDBizDay-8.html">OpenID BizDay vol.8</a> が開催され、ひろみちゅせんせ・まさともせんせ・Nat さんの3名を中心に、個人情報改正を控え、「炎上レスでパーソナルデータ活用ビジネスを進めるためにどこまでが許容範囲なのか、個人情報保護法改正に関して現時点で何をどこまで気にしておけば良いか」といった内容についてみんなで考える機会が設けられます。</p>

<p>なんと、いつもは OpenID Foundation Japan 会員限定の BizDay が、今回は 5,000 円さえ払えば非会員でも参加できるんです！！</p>

<p>こらぁ上司の承認とか後回しで、<a href="http://www.openid.or.jp/seminar/entry.html">いますぐ申し込まないとダメですね</a>！！！</p>

<p>と、前置きはこれくらいにして、個人情報保護法改正項目の中でも、今日は「第三者提供時に提供元 &amp; 提供先双方でその記録義務が追加される」という点について、OpenID Connect や Facebook Connect などの「外部 ID 連携」時の影響範囲について、考えてみましょう。</p>

<p>僕の感覚だと、普通に外部 ID 連携した場合、属性も IdP から引っ張ってくるけど、引っ張ってきた属性 (氏名とかメアドとか) はユーザーが後から編集可能な状況になっていると思います。</p>

<p>そんな状況で、任意の時点でユーザーから「この氏名データ、どこから来たの？」って聞かれたら答えられるトレーサビリティを確保する&hellip;</p>

<p>一つのアカウントに複数 IdP が紐づけ可能で、任意の IdP との紐づけを任意のタイミングで解除できる、そんな状況でもトレーサビリティを確保する&hellip;</p>

<p>すでにそれが可能な実装にしているものだけが、SAMLer に石を投げなさい。</p>

<p>これ、実装どうするかって話もあるんですが、そもそもそんなケースでもトレーサビリティ必要なんでしたっけ？って疑問が湧きますよね。</p>

<!-- more -->


<p>こういうケースって、散財情報扱いなんでしょうか？</p>

<p>ユーザーが明示的に書き換えた情報に関してまで、トレーサビリティはいらないですよね？</p>

<p>ユーザーが明示的に紐づけた IdP から、明示的に同意を取った scope に紐づく属性を取得した時に、それをトレースする義務はユーザーに負わせることはできないのでしょうか？</p>

<p>とまぁ、気になってるけど調べきれてないことも、きっと BizDay なら先生方に直に聞ける！</p>

<p>プライバシーフリークカフェでおなじみ、ひろみちゅせんせ・まさともせんせ・切込隊長による <a href="http://www.shoeisha.co.jp/book/detail/9784798139760">ニッポンの個人情報</a> の即席サイン会にだって参加できる！</p>

<p>あぁそうさ、要するに <a href="http://www.openid.or.jp/news/2015/02/OpenIDBizDay-8.html">OpenID BizDay #8</a> 来いよってことさ！</p>

<p>もし BizDay のこと初めて聞いたって方がおられましたら、いまさら遅せーよとか言わないでくださいごめんなさい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google OpenID 2.0 のサポート終了、OpenID Connect への移行はお早めに]]></title>
    <link href="http://oauthjp.github.io/blog/2015/01/07/google-openid2-termination/"/>
    <updated>2015-01-07T13:20:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2015/01/07/google-openid2-termination</id>
    <content type="html"><![CDATA[<p>今朝こちらの Tweet みて気がついたんですが、Google が OpenID 2.0 のサポートを2015年4月20日で終了するようです。</p>

<blockquote class="twitter-tweet" lang="en">
    <p>Developers beware! Google has published its timeline for deprecation of OpenID 2.0:<a href="http://t.co/84cIS0wR1D">http://t.co/84cIS0wR1D</a></p>
    &mdash; Gluu (@GluuFederation)
    <a href="https://twitter.com/GluuFederation/status/552615928014577665">January 7, 2015</a>
</blockquote>


<script async src="http://oauthjp.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>本当にそんな短期間で OpenID 2.0 止めて大丈夫なのかって気がしますが、<a href="https://developers.google.com/accounts/docs/OpenID#shutdown-timetable">Google OpenID 2.0 Shutdown Timetable</a> によると、4/20で全てが止まるようです。</p>

<p>僕が把握しているところでは、以下のサイトは現時点でまだ Google OpenID 2.0 を使っています。他にもいっぱいあるんでしょうが、僕は把握してません。他に知ってるのあれば教えてください。</p>

<ul>
<li><a href="http://iknow.jp">iKnow!</a></li>
<li><a href="http://chatwork.com">ChatWork</a></li>
<li><a href="http://atnd.org">ATND</a></li>
</ul>


<p>OpenID 2.0 停止により、上記のようなサイトでは、いままで Google Account でログインしてきたユーザー達はログインできなくなります。</p>

<p>これらのサイトは、4/20までに OpenID Connect (Google+ Signin) への移行が必要です。</p>

<!--more-->


<p>移行方法は <a href="https://developers.google.com/accounts/docs/OpenID">Google OpenID 2.0 Migration</a> にあります。</p>

<p>なんだかユースケースごとに4通りの移行方法が紹介されてますが、基本は <a href="https://developers.google.com/accounts/docs/OpenID#update-to-plus">Migrating to Google+ Sign-In</a> に従えば良さそうです。</p>

<p>細かいステップは <a href="https://developers.google.com/+/api/auth-migration#oid2">Migrate from OpenID 2.0 or OpenID+OAuth hybrid to Google+ Sign-In</a> を読んでいただくとして、大雑把な Step は以下の通りです。</p>

<ol>
<li>Authorization Request に OpenID 2.0 時代に使っていた realm を含める。</li>
<li>ID Token に OpenID 2.0 時代の Claimed Identifier が &ldquo;openid_id&rdquo; という名前で含まれて帰って来る。</li>
<li>&ldquo;openid_id&rdquo; をキーに既存ユーザーを探して、該当ユーザーの識別子を &ldquo;sub&rdquo; に置換する。</li>
</ol>


<p>あと、Attribute Exchange 使ってプロフィール情報を取得してた場合は、UserInfo API 叩くように変更しましょう。</p>

<p>ま、これだけっちゃこれだけなんですが、4/20までって言われると、焦りますね。</p>

<p>みんな realm が何かとか把握してるんでしょうか？</p>

<p>ってことで、自分が使ってるサービスが Google OpenID 2.0 使い続けてる場合は、サービス運営者に移行予定を問い合わせるなりしたほうが良いですね。</p>

<p>国内サービスの場合は、このブログのコメント欄にサービス名列挙していただけると、こちらでも対応可能かもしれません。(たぶん OpenID Foundation Japan 経由で)</p>

<p>あと、自社サービスが Google OpenID 2.0 使ってて移行ムリゲーとかいう事業者の方は、<a href="http://openid.or.jp/inquiry/">OpenID Foundation Japan に問い合わせ</a> いただいけるといいかもですね。</p>

<p>要望が多ければ、OpenID Foundation Japan のエヴァンジェリスト達で Migration Handson なり Hackathon なり企画してもいいかなと思っています。</p>

<p>いや、何も<a href="http://openid.or.jp/about/index.html#op-about-joining">いますぐ Foundation に加盟</a>しろなんていいませんよ？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth 2.0 の Response Type 全パターン]]></title>
    <link href="http://oauthjp.github.io/blog/2015/01/06/oauth2-multiple-response-type/"/>
    <updated>2015-01-06T20:15:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2015/01/06/oauth2-multiple-response-type</id>
    <content type="html"><![CDATA[<p>特に新しい話題ではないですが、定期的に質問されてる気がするので記事にしときます。</p>

<p>OAuth 2.0 の Core には、&#8221;code&#8221; と &ldquo;token&rdquo; という2つの response_type が定義されています。</p>

<p>それぞれ &ldquo;Code Grant&rdquo; と &ldquo;Implicit Grant&rdquo; と呼ばれることもありますし、歴史的経緯により &ldquo;Code Flow&rdquo; と &ldquo;Implicit Flow&rdquo; と呼ぶこともあります。</p>

<p>ほとんどのケースでは、この2つの response_type のどちらかを使っているかと思いますが、実はこれ以外にも以下の response_type のパターンが存在します。
(<a href="http://openid.net/specs/oauth-v2-multiple-response-types-1_0.html">仕様はこちら</a>)</p>

<ul>
<li>none</li>
<li>code token</li>
<li>id_token</li>
<li>id_token code</li>
<li>id_token token</li>
<li>id_token code token</li>
</ul>


<p>id_token ってのが含まれてるのは、OpenID Connect で利用する response_type なので、OAuth 2.0 だけを実装する場合は無視して OK です。</p>

<p>でもこんなにいっぱいあると、Server 側 (OP 側) もどこまで実装したらいいかわかんないし、Client 側 (RP 側) もどれ使うのが一番いいのかわかんないですよね。特に OpenID Connect 使う場合は。</p>

<p>そんなこんなで、「どれ実装したらいいの？」とか、「どれ使えばいいの？」っていう質問を、Server 側の人にも Client 側の人にも、半年に一回くらいされる気がします。</p>

<p>この機会に、それぞれの response_type で想定される Use-Case をまとめておきましょう。</p>

<!-- more -->


<h3>none</h3>

<p>「Approve はするけど、access_token (と id_token) は今はいらない」って時に使います。</p>

<p>はい、「それいつやねん」って思ったそこのあなた、あなたはきっとこれ使う事ないです。</p>

<p>世の中のごく一部には、これが必要な人もいるようですが、僕もいままで使ったことないです。</p>

<h3>code token</h3>

<p>Native App で access_token 使うんだけど、Native App の Backend Server 側でも access_token (と id_token) が欲しい時に使います。</p>

<p>fragment に code と access_token がついて返って来るので、access_token はそのまま Native App が内部に保持して、code だけを Native App から Backend Server に渡します。</p>

<p>Backend Server はその code を Token Endpoint に送って access_token (と id_token) を取得します。</p>

<p>もしかしたら Native App から access_token を Backend Server に送るような実装してる人もいるかもしれませんが、そうすると以下のようなデメリットがあります。</p>

<ul>
<li>Token Replace Attack に対して脆弱になりがち</li>
<li>Backend Server でも refresh_token を取得できない</li>
<li>Implicit Flow 経由で発行される access_token は lifetime が短くなりがち (Server 側の実装依存)</li>
</ul>


<h3>id_token</h3>

<p>access_token が不要な時に使います。</p>

<p>Web App / Native App どちらでも使われうるかと思います。</p>

<p>ただしこれ使うと fragment に id_token ついて返ってくるので、Web App からは扱いづらいかもしれません。</p>

<p>「response_type=code 使って access_token 捨てればいいやん」って言われたら、「その通りですね」とお返しします。</p>

<p>また、Native App 側で id_token 使ってユーザー認証するケースって、そんなに多くはなさそうです。</p>

<p>この response_type は、あまり使う機会なさそうです。</p>

<h3>id_token code</h3>

<p>Native App で id_token 使うんだけど、Native App の　Backend Server 側でも access_token (と id_token) が欲しい時に使います。</p>

<p>fragment に code と id_token ついて返ってくるので、id_token はそのまま Native App が内部に保持して、code だけを Native App から Backend Server に渡します。</p>

<p>Backend Server はその code を Token Endpoint に送って access_token (と id_token) を取得します。</p>

<p>ただこの response_type も、Native App 側で id_token が必要ってケースなんで、あまり使う機会なさそうです。</p>

<p>※ なぜか YConnect だけはこれを response_type=code 相当の response_type として利用しないといけないのですが、あれは YConnect の Bug です。</p>

<h3>id_token token</h3>

<p>Backend Server に code 渡す必要なくて、Native App 側だけで id_token と access_token 使えればそれで OK ってときに使います。</p>

<p>fragment に access_token と id_token ついて返ってきます。</p>

<p>この response_type も、Native App 側で id_token が必要ってケースなんで、あまり使う機会なさそうです。</p>

<h3>id_token code token</h3>

<p>Native App 側でも Backend Server 側でも id_token と access_token 両方必要な時に使います。</p>

<p>fragment に access_token と code と id_token ついて返ってくるので、access_token と　id_token はそのまま Native App が内部に保持して、code だけを Native App から Backend Server に渡します。</p>

<p>Backend Server はその code を Token Endpoint に送って access_token (と id_token) を取得します。</p>

<p>この response_type も、Native App 側で id_token が必要ってケースなんで、あまり使う機会なさそうです。</p>

<h3>まとめ</h3>

<p>Server 側は、とりあえず以下の3つさえサポートしてれば、大抵の Use Case はサポートできそうです。</p>

<ul>
<li>code</li>
<li>token</li>
<li>code token</li>
</ul>


<p>Client 側も、基本は以下のような基準で response_type 選べば良さそうです。</p>

<ul>
<li>Web App なら code</li>
<li>Backend Server なしの Native App なら token</li>
<li>Backend Server ありの Native App なら code token</li>
</ul>


<h3>補足</h3>

<p>本記事全体として、Native App を JS App に置き換えても同様です。</p>

<p>また、広く公開される IdP を作る場合は、以下のようなケースも考慮しましょう。</p>

<h4>Native App 側で id_token が必要なケース</h4>

<p>Native App 側でマルチアカウント対応してるような場合は、Native App 側で id_token が必要になるケースはあるかもしれません。</p>

<p>そういう Client にも対応したい Server は、(none 以外) 全部サポートしましょう。</p>

<h4>Native App 側で code を使うケース</h4>

<p>Native App から Token Endpoint に code を送るケースもあります。</p>

<p>この場合は、Native App 側で refresh_token を取得したいケースが多いです。</p>

<p>access_token の lifetime が短く、Native App で頻繁に AuthZ Request を送りたくない場合などには、Native App でも refresh_token が必要になるのです。</p>

<p>ただしこの場合、Token Endpoint での Client Authentication を OPTIONAL にする必要があるので注意してください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FIDO Alliance]]></title>
    <link href="http://oauthjp.github.io/blog/2014/10/15/fido-alliance/"/>
    <updated>2014-10-15T11:28:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/10/15/fido-alliance</id>
    <content type="html"><![CDATA[<p>先週末、FIDO Alliance　のメンバーが来日して、<a href="http://www.dds.co.jp/fido_tokyoseminar/">FIDO Alliance Tokyo Seminar</a> というセミナーが開催されていました。僕も今春の <a href="http://idcon.doorkeeper.jp/events/10195">#idcon vol.18</a> で <a href="http://www.slideshare.net/matake/fido-alliance">FIDO Alliance について紹介した</a> 時にまだいろいろ不明点が多かったのもあって、このセミナーに参加してきました。</p>

<p>で、参加してみて分かった事。</p>

<h2>生体認証押し</h2>

<p>まぁ、これは FIDO Alliance のサイト見ても、元々そうっちゃそうなんですが。</p>

<p>FIDO は仕様的には特に生体認証センサーとか必要ないし、FIDO に準拠してない Apple TouchID みたいなセンサーモジュールと連携したソフトウェアモジュールさえ積んでればFIDO 仕様に沿った実装は可能です。</p>

<p>ひとことで言うと、エンドユーザーが「端末のセキュア領域に保存されている秘密鍵にアクセスして assertion に署名できる存在」であることを認証しているに過ぎないので、その秘密鍵のロック解除に指紋使ってもいいし、PIN Code 使ってもいいはずです。</p>

<p>が、やはり Alliance Member には生体認証ハードウェアモジュールのベンダーが多い事もあってか、発表ではヤケに生体認証を押していました。</p>

<p>その影響か、Twitter とか現地での Q&amp;A でも、生体認証のセキュリティについての質問が多かったように思います。</p>

<!-- more -->


<h2>UAF と U2F は完全に別物</h2>

<p>FIDO Alliance では、パスワードレスな認証の実現を目指す Universal Authentication Framework (UAF) と、2要素認証の UX 改善を目指す Universal Second Factor (U2F) という2つの Working Group が、それぞれに仕様策定を進めています。</p>

<p>僕の #idcon vol.18 時点の理解では、U2F は UAF とほぼ同じで、JS API や Android SDK などでの利用を想定した仕様策定がそれにプラスαで進んでいるのだと思っていたのですが、懇親会で Google の Dirk Balfanz さんに聞いたところでは、U2F は「JS API (と Android SDK)」のみの標準化を行っているそうです。</p>

<p>UAF では、センサーモジュールと Client App、Client App と Backend Server などの間でのやりとりが規定されているのですが、U2F ではその辺りのやり取りは「各実装が自由にやれ」という姿勢とのこと。</p>

<p>UAF 側の Rolf Lindemann (Nok Nok Labs) に別途聞いたところでは U2F Working Group に UAF で策定した仕様を取り込むよう働きかけているとのことでしたが、2つの WG の間の連携は、それほど強くないのかもしれません。</p>

<h2>Discovery は貧弱</h2>

<p>FIDO UAF Protocol では、FIDO Alliance が FIDO Ready な製品を作る Vendor に Vendor ID を発行し、FIDO Ready な Product を Metadata Service (?) に登録したりするというようなことが書かれているのですが、現状は Vendor ID の発行にとどまっており、Metadata は必要に応じて RP が「ダウンロード」している状況のようです。</p>

<p>この部分がマニュアルだと、結局デバイスメーカーやアプリベンダーは、OAuth のクライアント登録的なマニュアル作業から抜け出せないように思います。</p>

<p>ま、もろもろまだまだ、って感じでしょうか。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Twitter Login にも CSRF 脆弱性ができやすい罠が!?]]></title>
    <link href="http://oauthjp.github.io/blog/2014/06/23/csrf-on-twitter-login/"/>
    <updated>2014-06-23T10:46:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/06/23/csrf-on-twitter-login</id>
    <content type="html"><![CDATA[<p>OAuth 2.0 では state パラメータってのがあって、それをちゃんと使わないと CSRF 脆弱性ができちゃうよって話は、<a href="http://www.slideshare.net/ritou/idcon17-oauth2-csrfprotectionritou">@ritou 先生のスライド</a>などでみなさん勉強したんではないでしょうか。state パラメータは RFC 6749 では RECOMMENDED 扱いで、REQUIRED ではありませんが、OAuth 2.0 をログインに使う場合は REQUIRED にすべきでしょう。OAuth 2.0 をログインに使うの、Token 置換攻撃とか Covert Redirect + Code 置換攻撃とか、いろんな罠がありますねぇ〜。</p>

<p>OAuth 1.0 ならそんなことないのに&hellip;</p>

<p>そう思ってた時期が、僕にもありました。</p>

<p>でも @ritou 先生よく言ってるじゃないですか。「Twitter の OAuth 実装クソや」って。でね、ほんとにクソやったんすよ、コレが。</p>

<!-- more -->


<p>さて、Developer の皆様におかれましては、もうずいぶん「Twitter ID でログイン」の実装なんて放置してて詳細忘れ去ってるころかと思いますので、まずは OAuth 1.0 の Access Token 取得までのフローを復習しましょう。</p>

<p><img src="http://oauthjp.github.io/images/posts/oauth1_flow.png" alt="OAuth 1.0 Flow" /></p>

<p>思い出しましたか？</p>

<p>思い出せない方には<a href="http://openid-foundation-japan.github.io/rfc5849.ja.html">仕様を読み直していただく</a>として、先に進みましょう。</p>

<p>OAuth 1.0 には Request Token + Request Token Secret というのがありました。RFC 5849 では Temporary Credentials とか言われたりもしますが、Request Token という呼び名の方が一般的でしょう。</p>

<p>で、この Request Token Secret、Access Token 取得時のリクエストに署名するために必要になります。「Consumer Secret と Request Token Secret の2つを連結させたものを HMAC 鍵として利用する」って、習いましたよね？</p>

<p>で、一般的にはこの Request Token Secret を Session と紐づけて保存すると思うんですが、これが認可レスポンスが返される箇所 (Callback URL) への CSRF 対策として作用していたんです。</p>

<p>認可リクエストを送った Browser と認可レスポンスを返してきた Browser が異なれば、当然認可レスポンスを返してきたブラウザでは Session と紐づく Request Token Secret が取得できないので、Access Token が取得できない。よって CSRF 対策ができている。</p>

<p><strong>が、ここで罠があるんです。</strong></p>

<p>実は Twitter は、Access Token 取得時のリクエストの署名に、<strong>Request Token Secret を使わなくてもいい</strong>んです。なので Session に紐づいた Request Token Secret が空の場合にそれをそのまま空文字列として処理してしまう RP は、<strong>正常に Access Token を受け取れてしまいます</strong>。</p>

<p>つまり、攻撃者が被害者にこんな URL を踏ませると、被害者は攻撃者の Twitter アカウントを使ってあなたのサイトにログインできてしまう可能性があるのです。</p>

<pre>
https://client.example.com/callback?
  oauth_token=&lt;request-token-authorized-by-attacker&gt;&
  oauth_verifier=&lt;valid-oauth-verifier&gt;
</pre>


<p>このパターン、すでにいくつかの「Twitter ID でログイン」を実装してるサイトでは確認してます。</p>

<p>この脆弱性によるリスクは <a href="http://www.slideshare.net/ritou/idcon17-oauth2-csrfprotectionritou">@ritou 先生のスライド</a> に書いてあるのでそちらにゆずります。</p>

<p>Twitter が Request Token Secret を必須にしてないことは以下のコードで確認できます。</p>

<script src="https://gist.github.com/nov/5e99d1999bea0e16bb74.js"></script>


<p>ちなみに Twitter 側はこのバグは認識してるらしいのですが、直すと多くのサイトが動かなくなるのも把握しているのか、修正できないでいるようで、みなさんが個別に対策するしかないわけです。</p>

<p>とりあえず <strong>Session に紐づいた Request Token Secret が無かったら、エラーにしちゃえば OK</strong> です。</p>

<p>そもそも Request Token Secret が Session に紐づいてなかったり、Request Token Secret 一切使ってないなんて人は、アウトです。まぁいまから再び Twitter ID でログインとか自分で実装するよりは、人気のライブラリ探した方が良いでしょう。Rails だといまでも omniauth-twitter とかが人気なんでしょうか。</p>

<p>ちなみに omniauth-twitter (というか omniauth-oauth) は Callback URL で Session に Request Token Secret が入ってなければエラーになるので Safe です。Gunosy とか Doorkeeper は omniauth-twitter 使ってるのか、Safe でした。</p>

<p>そういや最近<a href="https://twitter.com/TSJ2010">日本ツイッター学会</a>って何してんすかね？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth 2.0 の code は漏れても大丈夫ってホント!?]]></title>
    <link href="http://oauthjp.github.io/blog/2014/05/09/what-happens-when-oauth2-code-leaked/"/>
    <updated>2014-05-09T09:59:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/05/09/what-happens-when-oauth2-code-leaked</id>
    <content type="html"><![CDATA[<p>昨日の<a href="http://oauthjp.github.io/blog/2014/05/08/covert-redirect-and-non-30x-redirects/">Covert Redirect で Query 漏れるケースもある!?</a>や<a href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect/">OAuth 2.0 の脆弱性 (!?) &ldquo;Covert Redirect&rdquo; とは</a>にあるように、OAuth 2.0 の code が漏れちゃうことも、ありえます。</p>

<p>漏れないためにやるべきことは、上記の記事や<a href="http://oauthjp.github.io/blog/2014/05/08/facebook-login-and-covert-redirect/">Facebook Login で Covert Redirect を防止する</a>なんかでも紹介してるので、そちら読んでください。</p>

<p>で、今回の内容は<strong>「code が漏れたら何がまずいのか」</strong>についてです。</p>

<h3>「code は漏れても大丈夫」説</h3>

<p><a href="http://www.openid.or.jp/blog/2014/05/covert-redirect-and-its-real-impact-on-oauth-and-openid-connect.html">「Covert Redirect」についての John Bradley 氏の解説（追記あり）</a>にも、こうありましたね。</p>

<blockquote>
OAuth と OpenID Connect には複数の response_type があるんだけど、さきのリポートの著者は、最も一般的な response_type が &#8220;code&#8221; であることに触れず、またクライアント・クレデンシャルを使ってもう一度呼び出しを行わないとアクセス・トークンは手に入らないってことも無視してる。つまり、たしかに &#8220;code&#8221; がオープン・リダイレクターを経由して漏洩するかもしれない、という点については彼が正しい。けど、その code を使って攻撃者がなにかできるわけではないよ。これこそまさに、&#8221;code&#8221; response_type を使うことで得られる効果的な緩和策だね。
</blockquote>


<p>あれ？code 漏れても問題なさそうですね？</p>

<p>ほんとでしょうか？</p>

<h4>[仕様策定者視点での答え]</h4>

<blockquote>
本当です。みんながちゃんと OAuth の仕様に沿って実装していれば。仕様に沿って実装してない場合は知らん。ちゃんとやれ。
</blockquote>


<h4>[OAuth Server 実装者視点での答え]</h4>

<blockquote>
本当です。Client がちゃんと client secret を漏洩させずに、OAuth の仕様に沿って実装していれば。client secret 漏らしたり仕様に沿って実装してない場合は、うちのユーザーに迷惑かかるかもしれんし、あなたのアプリ停止しちゃうね。
</blockquote>


<h4>[OAuth Client 実装者視点での答え]</h4>

<blockquote>
え？俺ちゃんと仕様に沿って実装できてんの？

&#8230;まぁ動いてるしできてる、よね！？

それに万が一 code 漏れても、うちに被害及ぶってより OAuth Server に被害及ぶはずやし、OAuth Server がちゃんと対策してれば、まぁなんとかなるよね？
</blockquote>


<p><strong>ゆとりか！(｀ヘ´#)</strong></p>

<p>OAuth Client 実装者がこういう考えだと、一瞬でやられちゃいそうですねぇ。</p>

<p>ってことで、ここでは<strong>「code が漏れたら OAuth Client 側でアカウント乗っ取りが発生する」</strong>ケースについて考えてみましょう。</p>

<!-- more -->


<h3>前提条件</h3>

<p>あなたのサイトは「Facebook ID でログイン」できるようになっています。(ちなみにここでは一番世に広まっている Facebook を挙げますが、問題の本質は Facebook に限定された話ではないので、ID Provider が GitHub や LinkedIn な場合でも同様です)</p>

<p>あなたのサイトからは client secret は漏れていませんし、Implicit Flow も使ってないので、「Token 置換攻撃 ※1」は受けません。</p>

<p>あなたのサイトには open redirector があり、被害者の code が攻撃者に漏洩しています。(or している可能性があります)</p>

<p>client secret は漏れていないので、攻撃者が漏洩した code を access token と交換することは、できません。</p>

<h3>攻撃例</h3>

<p>攻撃者は、あなたのサイトの正規の redirect_uri に、漏洩した code を送りつけます。</p>

<pre>
GET /facebook/callback?code=&lt;leaked-code&gt;
Host: client.example.com
</pre>


<p>ここであなたのサイトはこのリクエストを Facebook から正規のリダイレクトレスポンスとして処理します。通常、だいたいこんな処理を行うのではないでしょうか。</p>

<ol>
<li>Facebook の Token Endpoint に code を POST し、access token を取得する。</li>
<li>access token を使って <code>GET /me</code> にアクセスし、ユーザーの Facebook UserID を取得する。</li>
<li>取得した Facebook UserID と紐づくアカウントを特定し、local の session cookie を発行するなどしてログイン済にする。</li>
</ol>


<p>あれ？攻撃者が漏洩した code を使って、<strong>あなたのサイトに被害者のアカウントで</strong>ログインできてしまいましたね？</p>

<p>なんか Token 置換攻撃と同じような現象が起こっちゃいましたね？</p>

<p>こんなことが起こりえる以上、</p>

<blockquote>
万が一 code 漏れても、うちに被害及ぶってより OAuth Server に被害及ぶはずやし、OAuth Server がちゃんと対策してれば、まぁなんとかなるよね？
</blockquote>


<p>なんて悠長なことは、言ってられませんね。</p>

<h4>[捕捉]</h4>

<p>なお、code &lt;&ndash;> token 交換時には redirect_uri を Token Endpoint に送ることになるので、ここで Server 側がちゃんと code 発行時の redirect_uri とここで送られて来る redirect_uri を exact match で検証していれば、Step.1 でエラーになってこの攻撃は成立しないはずです。</p>

<p>実際 Facebook はこのタイミングでは exact match 必須なんで、正規の redirect_uri が open redirector になってない限りは上記の攻撃は Step.1 で失敗します。</p>

<p>が、残念ながら世の中には 某ithub みたいに (ry</p>

<h3>対策方法</h3>

<p>まず、この攻撃が発生してしまう根本原因は、ここです。</p>

<blockquote>
ここであなたのサイトはこのリクエストを Facebook から正規のリダイレクトレスポンスとして処理します。
</blockquote>


<p>これを防げれば OK です。</p>

<p>これを防ぐための一番簡単な方法は、<strong>被害者と攻撃者が異なる UserAgent を使っていることを検知する</strong>ことです。</p>

<p>いわゆる CSRF 対策ができてればいいんですね。</p>

<p>ここで @ritou 先生の<a href="http://d.hatena.ne.jp/ritou/20121008/1349695124">OAuth 2.0のstateとredirect_uriとOpenID ConnectのnonceとID Tokenについて</a>でも紹介されてる state パラメータってやつが登場するわけです。</p>

<p>この state パラメータについては、Client が任意であらゆる文字列を指定できてしまうので、前提知識の乏しい Developer にとってはいまいち何を指定すればいいか分からないかもしれません。</p>

<p>@ritou 先生の記事に従って、session ID のハッシュ値を指定してもいいですし、先日 John Bradley が出してきた<a href="http://tools.ietf.org/html/draft-bradley-jwt-encoded-oauth-state-00">こちらの OAuth 2.0 拡張仕様</a>を参考にしても良いでしょう。</p>

<h3>結論</h3>

<p>ちゃんと state 使ってない OAuth Client に関しては、<strong>「code なら漏れても大丈夫」なんてウソです</strong>。</p>

<p>OAuth Server には、code 置換攻撃を防ぐ手だてはありません。</p>

<p>OAuth Client がちゃんと実装するしかありません。</p>

<p>open redirector だらけで state パラメータもまともに使っていないような OAuth Client なんて、もう救いようが&hellip;(ry</p>

<p>まぁ、みんなちゃんとしましょう。</p>

<p>※1「Token 置換攻撃」については、これまでもたびたび書いてきたので、これらの記事をどうぞ。</p>

<ul>
<li><a href="http://www.atmarkit.co.jp/ait/articles/1209/10/news105_2.html">@IT &ndash; RFCとなった「OAuth 2.0」――その要点は？ (2/2)</a></li>
<li><a href="http://oauthjp.github.io/blog/2012/02/08/ios-sdk/">&ldquo;なんちゃら iOS SDK&rdquo; でありそうな被害例</a></li>
<li><a href="http://oauthjp.github.io/blog/2012/02/07/oauth-20-implicit-flow/">「OAuth 2.0 (Implicit Flow) でログイン」の被害例</a></li>
<li><a href="http://oauthjp.github.io/blog/2012/06/29/oauth-20-implicit-flow-78852/">OAuth 2.0 Implicit Flow で認証の問題点、再び。</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Covert Redirect で Query 漏れるケースもある!?]]></title>
    <link href="http://oauthjp.github.io/blog/2014/05/08/covert-redirect-and-non-30x-redirects/"/>
    <updated>2014-05-08T15:47:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/05/08/covert-redirect-and-non-30x-redirects</id>
    <content type="html"><![CDATA[<p>Covert Redirect 連載最後は、location.href とか &lt;meta http-equiv=&ldquo;Refresh&rdquo;&gt; とかだと referrer 通じて query に含まれる code とかも漏れるかもね！ってお話です。</p>

<p>古いサイトですが、こことか見れば大体いいんじゃないでしょうか => <a href="http://www.teria.com/~koseki/memo/referrer/">リファラ実験</a></p>

<p>で、こういうリダイレクトをしてる箇所が OAuth 2.0 の redirect_uri なり OpenID 2.0 の return_to なりに指定されていれば、query に付いた code なり email なりがリファラ経由で外部に漏れるよね、という。</p>

<p>はい、漏れますね！ (投げやり</p>

<p>さて、そんなに該当例多くはないと思うのですが、ここまで該当してしまったサービスは、どうしますかねぇ&hellip;</p>

<p>Facebook であれば、<a href="http://oauthjp.github.io/blog/2014/05/08/facebook-login-and-covert-redirect/">Facebook Login で Covert Redirect を防止する</a>にあるような方法で回避できますが、それ以外の OAuth Provider なり OpenID 2.0 Provider と連携してる場合は、困っちゃいますねぇ&hellip;</p>

<!-- more -->


<h3>被害例</h3>

<p><a href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect/">OAuth 2.0 の code が漏れた場合について</a>は既に書きました。</p>

<p>Client が redirect_uri 上で state パラメータのチェックを怠っていれば、code 置換攻撃が可能になるっていうアレです。</p>

<p>OpenID 2.0 のレスポンスパラメータが漏れた場合は、そのパラメータに email や name なんかが含まれてる場合があるので、そういった場合はそれらが外部に漏洩します。</p>

<p>また世の中には OpenID 2.0 の nonce を OAuth 2.0 の access token のように使って API アクセスさせる事業者があったりするんで、そういった場合は acccess token 相当のものが漏洩します。</p>

<p>それら access token 相当の nonce が漏れた場合の実害については、提供される API に依存するのでここでは未知です。</p>

<h3>対策方法</h3>

<p>リダイレクト方法変えろ、って以外の回避策を思いついたら、この下に書きます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Facebook Login で Covert Redirect を防止する]]></title>
    <link href="http://oauthjp.github.io/blog/2014/05/08/facebook-login-and-covert-redirect/"/>
    <updated>2014-05-08T14:16:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/05/08/facebook-login-and-covert-redirect</id>
    <content type="html"><![CDATA[<p><a href="http://oauth.jp/blog/2014/05/07/covert-redirect-in-implicit-flow/">OAuth 2.0 Implicit Flow では Covert Redirect 経由で access token が漏れる件</a>については既に紹介しましたが、ここではみなさん大好き Facebook Login で OAuth Client Developer ができる対策について紹介することにします。</p>

<h3>攻撃方法</h3>

<ol>
<li>攻撃対象となる OAuth Client の FB client_id を取得

<ul>
<li>client_id は FB Login ボタンさえクリックすればアドレスバーに表示される。</li>
</ul>
</li>
<li>Authorization Request URL を構築

<ul>
<li>対象 Client が通常 response_type=code を使ってる場合でも、問答無用で response_type=token にしてください。</li>
<li><a href="https://www.facebook.com/dialog/oauth?client_id=relace-me&amp;redirect_uri=relace-me&amp;response_type=token">https://www.facebook.com/dialog/oauth?client_id=<em>&lt;client_id></em>&amp;redirect_uri=<em>&lt;redirect-url></em>&amp;response_type=token</a></li>
</ul>
</li>
<li>被害者を2で作った URL にアクセスさせます

<ul>
<li>フィッシングがんばってください。</li>
</ul>
</li>
<li>redirect_uri に指定しておいた URL で fragment に付いて来る access token を待ち構えます。</li>
</ol>


<p>以上、巧いフィッシング方法さえ思いつけば簡単ですね。</p>

<h3>防御方法</h3>

<p>防御方法は、大きく分けて3つあります。</p>

<ol>
<li>open redirector を撤廃する</li>
<li>response_type=token を利用禁止にする</li>
<li>redirect_uri を完全一致しか認めさせなくする</li>
</ol>


<!-- more -->


<h4>open redirector を撤廃する</h4>

<p>まぁそらそれがベストですよね。</p>

<p>「あっ、はい」とか言う人いるけども。</p>

<p>まぁ、「それができれば最初っからやってるっちゅうねん」ってのは、ごもっとも。</p>

<h4>response_type=token を利用禁止にする</h4>

<p>FB にはそのためのオプション &ldquo;<a href="https://developers.facebook.com/docs/graph-api/securing-requests/">appsecret_proof</a>&rdquo; があります。</p>

<p>厳密には response_type=token を利用禁止にするのではなく、access token 単体で API Request をさせない、というオプションです。</p>

<p>このオプションを有効化すると、API Request に client_secret が必要になるため、client_secret が漏洩しない限りは、たとえ access token が漏洩してしまっても問題ありません。</p>

<p>え？client_secret が漏洩するかもって？</p>

<p>そんな、OAuth 1.0 じゃあるまいし、まさか Native App に client_secret 埋め込んだりしてないはずですよね？ね？？</p>

<p>なおこのオプションを有効にできるのは、client_secret を秘匿に保てる Client、つまりサーバーサイドで動作する Web App に限られます。</p>

<p>Client が Native App な場合や、Web App と Native App の両方で同じ client_id を使っている場合は、このオプションは選べません。</p>

<p>2014年5月現在では、このオプションは以下の URL から &ldquo;App Secret Proof for Server API calls&rdquo; というのを ON にすれば有効化されます。
<a href="https://developers.facebook.com/apps/:app_id/settings/advanced/">https://developers.facebook.com/apps/:app_id/settings/advanced/</a></p>

<h4>redirect_uri を完全一致しか認めさせなくする</h4>

<p>デフォルトでは redirect_uri の部分一致を許容する Facebook ですが、redirect_uri を完全一致のみ許可させるよう指定することもできます。</p>

<p>2014年5月現在では、このオプションは以下の URL から &ldquo;Valid OAuth redirect URIs&rdquo; というのを field に URL を指定すれば有効化されます。
<a href="https://developers.facebook.com/apps/:app_id/settings/advanced/">https://developers.facebook.com/apps/:app_id/settings/advanced/</a></p>

<p>Native App でも利用する client_id に関しては、このオプションを利用しましょう。</p>

<p>Web App でも、OAuth 2.0 の独自拡張である <a href="https://developers.facebook.com/docs/graph-api/securing-requests/">appsecret_proof</a> を利用するよりも、OAuth 2.0 の仕様に乗っ取った挙動になるこのオプションの方が、ライブラリをそのまま使えるとかいろいろメリット多そうですね。</p>

<p>みなさんのユースケースにあったオプションをお選びください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenID 2.0 における Covert Redirect と RP Discovery]]></title>
    <link href="http://oauthjp.github.io/blog/2014/05/08/covert-redirect-and-openid-2-dot-0/"/>
    <updated>2014-05-08T10:57:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/05/08/covert-redirect-and-openid-2-dot-0</id>
    <content type="html"><![CDATA[<p>さて、<a href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect-in-implicit-flow/">OAuth 2.0 &amp; OpenID Connect における Covert Redirect の問題</a> についてはまとめたので、次は OpenID 2.0 についてです。</p>

<p>いいですか、OpenID Connect ではなく、OpenID 2.0 ですよ。古い方です。懐かしいですね、<a href="http://openid.net/specs/openid-authentication-2_0.html">OpenID Authentication 2.0 &ndash; Final</a>。</p>

<p>そういえば、OpenID Foundation Japan の翻訳 WG を立ち上げて、一番最初に翻訳したのが <a href="http://openid-foundation-japan.github.io/openid-authentication.html">OpenID Authentication 2.0 の 日本語訳</a>でしたね&hellip;(遠い目</p>

<p>と、昔話はそれくらいにして、本題に入りましょう。</p>

<h3>まずは Covert Redirect 発生条件について</h3>

<p>OpenID 2.0 では、レスポンスパラメータは query に引っ付いてきます。fragment は使いません。</p>

<p>なので、open redirector のリダイレクト先には、通常はレスポンスパラメータは渡りません。</p>

<p>全ての query パラメータをリダイレクト先に引き継いでしまうという、奇妙な open redirector を用意してる場合にのみレスポンスパラメータが外部に漏洩します。</p>

<p>まずはこの時点でそんなに心配することはなさそうですね。</p>

<p>まぁでもせっかくなんで、話続けますね。</p>

<!-- more -->


<h3>RP Discovery ってのがあってだな</h3>

<p>さて、OpenID 2.0 には、<a href="http://openid.net/specs/openid-authentication-2_0.html#rp_discovery">RP Discovery というものが定義されていた</a> (<a href="http://openid-foundation-japan.github.io/openid-authentication.html#rp_discovery">翻訳版はこちら</a>) のを、おぼろげに覚えている方もおられるのではないでしょうか？</p>

<p>え、そんなの聞いた事が無い？でしょうね！w</p>

<p>OpenID 2.0 は OAuth とちがって、通常 RP が OP に対して事前登録を行うことはありません。</p>

<ul>
<li>RP: Relying Party, OAuth 2.0 の Client 相当</li>
<li>OP: OpenID Provider, OAuth 2.0 の Server 相当</li>
</ul>


<p>OP と RP の間では、動的に association というものを確立します。association って何？って人には、「最初に Temporary な共有秘密鍵をする」って言っちゃえばいいですかね。</p>

<p>association が確立されると、RP は各種リクエストパラメータと共に return_to (OAuth 2.0 の redirect_uri 相当) ってのを指定して、ユーザーを OP にリダイレクトさせます。</p>

<p>で、OP はユーザー認証とか同意取得とか OAuth と似たようなことしてから、最終的に各種レスポンスパラメータを添えてユーザーを指定された RP の return_to にリダイレクトして戻します。</p>

<p>で、ここまでが全部 dynamic なんで、事前登録された return_to との完全一致、なんてことがそもそもありえないんです。</p>

<h3>RP Discovery ってのがあってだな (part 2)</h3>

<p>まぁ既に RP Discovery についての記述を読んだみなさんには釈迦に説法、ネコに小判ですか？あれですね、日本語難しいですね。</p>

<p>まぁあれです、OpenID 2.0 の仕様だけで RP Discovery 理解しろとかムリゲーな気がします。Yadis ってのがあってだな&hellip;いや、やめよう。</p>

<p>実際に、これまた懐かしの iKnow! を例に、RP Discovery ってのを概観してみましょう。</p>

<p>まず iKnow! に OpenID でログインする際のリクエストパラメータを眺めると、&#8221;openid.realm=<a href="https://*.iknow.jp/open_ids">https://*.iknow.jp/open_ids</a>&#8221; ってのが含まれてるのが分かるかと思います。</p>

<p>iKnow! はちょっとレアケースで、サブドメインを許可する為に &ldquo;*.iknow.jp&rdquo; になってますが、そういう場合は &ldquo;*&rdquo; を &ldquo;www&rdquo; に置き換えて &ldquo;<a href="https://www.iknow.jp/open_ids">https://www.iknow.jp/open_ids</a>&rdquo; にアクセスします。</p>

<script src="https://gist.github.com/nov/c702782baa98c75702dc.js"></script>


<p>あ、リダイレクトしましたね。これは follow します。</p>

<script src="https://gist.github.com/nov/67c491166bed6f9cdb7e.js"></script>


<p>で、このレスポンスヘッダに注目です。</p>

<pre>X-XRDS-Location: https://iknow.jp/discovery.xrds</pre>


<p>XRDS ってのがありますね。これが、RP の metadata が記述されたドキュメントです。</p>

<p>で、今度はこの XRDS endpoint にアクセスします。</p>

<script src="https://gist.github.com/nov/b6173c3195fa49e1c668.js"></script>


<p>はい、return_to が指定されてますね。</p>

<pre>&lt;Service priority="0"&gt;
  &lt;Type>http://specs.openid.net/auth/2.0/return_to&lt;/Type&gt;
  &lt;URI>https://iknow.jp/open_ids?_method=GET&lt;/URI&gt;
&lt;/Service&gt;</pre>


<p>で、RP Discovery をサポートしてる OP は、RP の realm にアクセスしてみて、レスポンスヘッダに &ldquo;X-XRDS-Location&rdquo; ってのがあれば、return_to の検証を行う、ってのが一般的な実装かと思います。</p>

<h3>RP Discovery って必要なの？</h3>

<p>大概の OP では不要です。</p>

<p>てか RP 側の人たちはこれほとんど知らんかったんじゃないかと。</p>

<p>噂によると一部 OP では RP Discovery が必須なやつもいるらしいですが、Gooogle, Yahoo! Japan, mixi はじめ、ほぼ全ての主要 OP では RP Discovery は OPTIONAL です。</p>

<p>また XRDS 中の return_to に指定されている URL とリクエストパラメータに含まれる return_to のマッチングルールも、完全一致だったり部分一致だったりは OP ごとに違うようです。</p>

<p>さらには RP 側が &ldquo;X-XRDS-Location&rdquo; を返さない限り、OP 側では RP Discovery をスキップします。</p>

<p>よって、RP Discovery を実装していない RP に open redirector が存在する場合は、それが悪用されるケースはあり得ます。(まぁこの記事の先頭で紹介した発生条件を満たす open redirector が存在するケースは稀ですが)</p>

<h3>対策</h3>

<p>まず query を全部引き継いでリダイレクトするのやめましょう。いや、そもそもみなさんはそんなことしてないと思いますけど。</p>

<p>RP Discovery は、まぁ頑張ってやってみてもいいかもしれないけど、結構複雑なのであまり気軽に実装できる気はしません。</p>

<p>&hellip;懐かしかったですね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implicit Flow では Covert Redirect で Token 漏れるね]]></title>
    <link href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect-in-implicit-flow/"/>
    <updated>2014-05-07T18:41:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/05/07/covert-redirect-in-implicit-flow</id>
    <content type="html"><![CDATA[<p>この記事は、<a href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect">先ほど書いたこちらの記事</a>の訂正版です。</p>

<p><strong>記事に入る前に、まずは全シンガポールにお詫び申し上げますm<em> </em>m</strong></p>

<p>さて、Covert Redirect についての説明は&hellip;超絶取り消し線はいりまくってる前の記事を読んでください、でいいでしょうか？</p>

<p>で、訂正分だけ以下に。</p>

<h3>Fragment Handling in Redirect</h3>

<p><a href="http://weblog.bulknews.net/post/85008516879/covert-redirect-vulnerability-with-oauth-2">宮川さんが記事にしてますね</a>。</p>

<p>英語だけど。</p>

<p>で、まぁ要するに、(Modern Browser は) 30x リダイレクト時に<strong>リダイレクト元に付いてた URL fragment をリダイレクト先にも引っ付ける</strong>、と。</p>

<p>fragment は server-side には送られないけど、クライアントサイドではリダイレクト先に引き継がれる、と。</p>

<p>試しに <a href="http://www.idcon.org/#foobar">http://www.idcon.org/#foobar</a> にアクセスすると、<a href="http://idcon.org/#foobar">http://idcon.org/#foobar</a> にリダイレクトされるかと思います。</p>

<p>www.idcon.org のサーバーには <strong>#foobar</strong> の部分は送られませんが、<a href="http://idcon.org/">http://idcon.org/</a> に load される client-side の JS からは、<strong>#foobar</strong> にアクセスできます。</p>

<p>なので、Covert Redirect のケースでも、open redirector をつかって最終的に被害者がリダイレクトしてくる endpoint に攻撃者が JS を仕込んでそれを自分のサーバーにでも送るようにしておけば、<strong>access token が漏洩します</strong>。</p>

<p>もちろん<a href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect">先ほどの記事にあるように</a>、Authorization Code が漏洩するケースもありますが、open redirector の実装詳細に依存しない分、Implicit Flow において fragment に含まれる access token が漏洩する方が可能性としては高いでしょう。</p>

<!-- more -->


<h3>仕様のバグではないが&hellip;</h3>

<p><a href="http://weblog.bulknews.net/post/85008516879/covert-redirect-vulnerability-with-oauth-2">宮川さんが記事</a>にもあるように、<a href="http://tools.ietf.org/html/rfc6819">RFC6819 &ndash; OAuth 2.0 Threat Model and Security Considerations</a> の <a href="http://tools.ietf.org/html/rfc6819#section-4.2.4">Section 4.2.4</a>, <a href="http://tools.ietf.org/html/rfc6819#section-5.2.3.5">Section 5.2.3.5</a> あたりにはこの問題が指摘されています。(<a href="http://openid-foundation-japan.github.io/rfc6819.ja.html">RFC6819 翻訳版はこちら</a>)</p>

<p>また <a href="http://tools.ietf.org/html/rfc6749">RFC6749 &ndash; The OAuth 2.0 Authorization Framework</a> の <a href="http://tools.ietf.org/html/rfc6749#section-3.1.2.2">Section 3.2.2.1</a> では redirect_uri の<strong>部分一致は query にしか</strong>認められていません。domain のみのマッチングや path の一部のみの一致で OK にしてしまうのは、実装上のバグと言えるでしょう。(<a href="http://openid-foundation-japan.github.io/rfc6749.ja.html">RFC6749 翻訳版はこちら</a>)</p>

<p>OpenID Connect では、query も含めて <strong>redirect_uri の部分一致を認めていません</strong>。(<a href="http://openid.net/specs/openid-connect-core-1_0.html#ImplicitAuthRequest">OpenID Connect Core Section 3.2.2.1</a> 参照, <a href="http://openid-foundation-japan.github.io/openid-connect-core-1_0.ja.html#ImplicitAuthRequest">日本語版はこちら</a>)</p>

<p>OAuth 1.0 では Refresh Token Secret が漏れない限り Access Token が Covert Redirect 経由で漏洩することは無いですし、OpenID 2.0 でも RP Discovery というのをきちんとやっていれば、redirect_uri の exact match 相当のことができます。</p>

<p>なので、特に Covert Redirect がこれらの仕様のバグであるということではありません。</p>

<p>が、まずい実装は結構ある、というのが、<a href="http://tetraph.com/covert_redirect/oauth2_openid_covert_redirect.html">元記事</a>の Provider List が伝えたかったことなのでしょう。</p>

<p>まぁ確かに redirect_uri の部分一致認めてる OAuth Server なんてそこら中にあるし、OpenID 2.0 に至っては RP Discovery 必須な OP ってどこよ？、みたいな状態ですし、OpenID Connect 実装って言っても完全に OpenID Connect の仕様に準拠してるかどうかあやしいですし&hellip;</p>

<p>いや、Google の Connect 実装は exact match ですよ。でも元記事見る限り、Google のは OpenID 2.0 実装が問題にされてますね。</p>

<p>Y!J の OpenID Connect も redirect_uri の部分一致は認められていないので、大丈夫です。</p>

<p>mixi と楽天の OAuth 2.0 実装は、そもそも Implicit Flow サポートしてません。</p>

<p>OpenID 2.0 実装に関しては&hellip;<a href="http://oauthjp.github.io/blog/2014/05/08/covert-redirect-and-openid-2-dot-0">別記事にまとめました</a>。</p>

<h3>攻撃パターン</h3>

<p>攻撃者は、redirect_uri を Client 上に存在する open redirector の endpoint に書き換えたリンクを被害者に踏ませます。</p>

<p>このリンクを踏ませる方法は何でもいいのですが、Client 側に悪意が無い限り、基本的には「通常のフロー」とは異なる方法でリンクを踏ませることになるでしょう。フィッシングですね。</p>

<p>で、あとは被害者が同意ボタンを押せば、open redirector 経由で攻撃者が指定した URL に、(ユーザーが Modern Browser を利用している場合は) fragment に access token を含んだ状態で、被害者がアクセスしてきます。</p>

<p>あとはその fragment から JS をつかって access token を抜き出して&hellip;ってのはこの記事冒頭でも書きましたね。</p>

<h3>対策</h3>

<h4>Server 側ができること</h4>

<p>redirect_uri の完全一致を必須にする。</p>

<p>いままで動いてた既存アプリが突然動かなくなるケースもあるでしょうし、そうそう気軽に変更できる部分では無いかもしれませんが、ある程度の猶予期間を用意した上で、redirect_uri の完全一致を必須にするのが良いでしょう。</p>

<p>あと、そもそもこの問題が自社の各プロトコル実装で置きうるのかどうか、redirect_uri の検証方法をいま一度 Developer 向けに広報する、とかはやった方がいいかもしれませんね。</p>

<h4>Client 側ができること</h4>

<p>例えば Facebook は、redirect_uri の完全一致を行うようにアプリ設定画面で指定することができます。(Advanced Settings の &ldquo;Valid OAuth redirect URIs&rdquo; ってやつ)</p>

<p>&ldquo;Valid OAuth redirect URIs&rdquo; はデフォルトでは空っぽで、その状態では redirect_uri の部分一致が許容されますが、ここに URL を指定することでFB 側に redirect_uri の完全一致を要求することができます。</p>

<p>そもそも Implicit Flow なんてつかわねーよ、って場合は、<a href="https://developers.facebook.com/docs/graph-api/securing-requests/">appsecret_proof</a> なんていう FB の独自拡張を利用することもできそうですが、まぁこれはそのうち調べようと心に誓いつつ全く調べてないのでよく知らないです。</p>

<p>あと open redirector 作らない、ってのね。</p>

<p>こらそこ、「あっ、はい」とか言わない。</p>

<h4>User 側ができること</h4>

<p>フィッシングに引っかかるな、くらいしか思いつかないですが、まぁそれじゃ引っかかる時は引っかかるでしょうね&hellip;</p>

<p>Client と Server が頑張る、のを応援する、ってのが一番いいかもしれませんね。</p>

<h3>最後に</h3>

<p>改めまして、全シンガポールにお詫び申し上げますm<em> </em>m</p>

<p>あと Twitter で mention いただいた <a href="https://twitter.com/miyagawa">@miyagawa</a> さんと、LINE の某厨部屋で連絡くれた <a href="https://twitter.com/mad_p">@mad_p</a> さん、ありがとうございますm<em> </em>m</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth 2.0 の脆弱性 (!?) "Covert Redirect" とは]]></title>
    <link href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect/"/>
    <updated>2014-05-07T13:53:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/05/07/covert-redirect</id>
    <content type="html"><![CDATA[<h3>訂正</h3>

<p>リダイレクト時の fragment の扱いを勘違いしていたため、本記事全体訂正します。</p>

<p>細かく訂正いれてると分けわかんなくなってきたんで、<a href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect-in-implicit-flow/">新しい記事書きました</a>。</p>

<p>ゴールデンウィークまっただなかに Twitter で海外の ID 厨から袋だたきにあってたので、もうこの問題は片付いただろうとすっかり油断してた「Covert Redirect」の件ですが、日本でもゴールデンウィーク明けてバズりだしたので、一旦問題を整理した方がよさそうですね。</p>

<h3>事の発端</h3>

<p>Wang Jing さんていうシンガポールの大学院生が、<a href="http://tetraph.com/covert_redirect/oauth2_openid_covert_redirect.html">こんなサイト</a>を公開すると共に <a href="http://www.cnet.com/news/serious-security-flaw-in-oauth-and-openid-discovered/">CNet</a> はじめ各種メディアが取り上げたのが、バズりだした発端のようです。</p>

<h3>前提知識</h3>

<p>OAuth 2.0 や OpenID Connect だけでなく、OAuth 1.0 や OpenID 1.0/2.0 や SAML なんかでも、<strong>2つのサービスの間でリダイレクトを経由して</strong>、Access Token や ID Token などのいわゆる <strong>&ldquo;Security Token&rdquo; の授受</strong> が行われます。</p>

<p>Covert Redirect の問題は本質的にはこれら全てに影響しますが、各仕様一個一個見て行くといろいろ疲れるので、ここでは OAuth 2.0 に絞って話をすすめましょう。</p>

<p>OAuth 2.0 では、まず Client が End-User の UserAgent を Server の Authorization Endpoint というところにリダイレクトします。よく Twitter とか Facebook の ID で外部サービスにログインするとき、一度 Twitter や Facebook にリダイレクトして、同意画面表示されますよね？あれです。</p>

<p><img src="https://fbcdn-dragon-a.akamaihd.net/hphotos-ak-prn1/t39.2178-6/851557_535801936465660_169463870_n.png" alt="FB の同意画面" /></p>

<p>で、みなさん何も考えず熟慮の結果、同意ボタンを押すじゃないですか。そして、元のサイト (= Client) に戻って来る、と。</p>

<p>OAuth 愛好家の間で &ldquo;OAuth Dance&rdquo; なんて呼ばれてるアレですね。</p>

<p>で、今回の話は、その <strong>&ldquo;OAuth Dance&rdquo; 中の話</strong> です。</p>

<!-- more -->


<h3>Covert Redirect てなんだ？</h3>

<p>Server 側の同意画面で同意ボタンを押すと、Client にリダイレクトして戻って来る。</p>

<p>そう、同意すると、元の Client に戻って来るんですよ。</p>

<p>で、Client 側に open redirector があって、まさにその open redirector めがけて戻ってきちゃったりしたら、そらもう open に redirect する訳です。</p>

<p>さらに悪いことに、open redirector の実装によっては、リダイレクト時に query に引っ付いてきたデータがそのリダイレクト先にまで渡っちゃうこともあるんです。</p>

<p>渡された query パラメータを全てリダイレクト先にまで forward するような実装、ちょっと正気の沙汰とは思えないかもしれないけど、まぁそういうのは実際あるらしいですし。(ESPN ってサイトがそうらしい)</p>

<p>こうして <strong>Client 側の open redirector が悪用</strong> されて、<strong>query についた Security Token が攻撃者に漏れちゃう</strong> っていうこれ、これが <strong>Covert Redirect</strong> なんです。</p>

<h3>Redirect URI に open redirector !?</h3>

<p>え？なんで redirect_uri に指定するエンドポイントに open redirector が存在すんだよ！って？</p>

<p>えぇ、普通ありえないですよね。</p>

<p>いくら open redirector だらけのザルサイトでも、さすがに redirect_uri に指定するエンドポイントくらいは&hellip;</p>

<p><em>&hellip;いや、P言語ならありえなくもない気がしてきましたけど&hellip;</em></p>

<p>でも Covert Redirect で想定されているケースでは、Client が本来指定する redirect_uri とは別の URL が、攻撃者によって redirect_uri に指定されるというのを想定してます。</p>

<p>で、Server 側では、事前に登録済の redirect_uri と部分一致すれば OK にしちゃうケースが結構あるんです。(domain だけが一致すれば OK とか)</p>

<p>この、<strong>Server 側の甘めの redirect_uri 検証</strong> と、<strong>Client 側が内包する open redirector</strong>、Covert Redirect はこの2つがうまいことくみ合わさって成立するんです。</p>

<p>Server 側では、一度部分一致を許した実装が広く世の中につかわれだしてしまうと、そこの仕様を変更するのはなかなか大変なんで、いざ直そうと思っても数ヶ月から数年の政治的調整作業等が必要になっちゃうかもですね。</p>

<h3>で、どれくらいヤバいの？</h3>

<p><s>実際の影響については、OpenID Connect の仕様策定者の一人でもある <a href="http://www.thread-safe.com/2014/05/covert-redirect-and-its-real-impact-on.html">John Bradley さんが記事書いてる</a>ので、まぁそれを読んでください。</p>

<p>ほんとはちゃんとこれ訳そうと思ったんですが、<a href="http://www.openid.or.jp/blog/2014/05/covert-redirect-and-its-real-impact-on-oauth-and-openid-connect.html">OpenID Foundation Japan から翻訳版</a>まで出たので、もういんじゃね？って空気を感じています。</p>

<p><em>もういんじゃね？って空気を感じながらも、必死に記事を書いてる僕の心境、お察しください&hellip;</em></p>

<p>で、まぁそんな僕の気持ちなんてスルーして翻訳版なり原文なりを要約すると、Covert Redirect によって <strong>access token 漏れるとか、そんな心配は無い</strong>ってことです。</p>

<p>さらに言えば、<strong>それ別に新しい発見でも何でも無いし</strong>って。</p>

<p><em>え？？漏れないの？？発見でもないの？？</em></p>

<p><em>シンガポールウソばっかなの？？</em></s></p>

<h3>ちょっとヤバいかも (?) なケース</h3>

<p>ただ、Authorization Code が漏れることはあり得て、被害者の code を攻撃者が正規 Client に送りつけて来て、攻撃者の Client 上のアカウントと被害者の Server 上の access token が紐づいちゃう、なんてことはあり得なくはないですね。</p>

<p>FB Login つかってるサイトでは、Client 上の既に FB と Connect 済の被害者のアカウントに、攻撃者がログインできちゃうかもしれないですね。</p>

<p>ただこれは、各 Client が state パラメーターってのをつかって CSRF 対策することで防ぐことができます。</p>

<p>state パラメータってのは&hellip;まぁ @ritou 先生のブログを読んでみてください。</p>

<p><a href="http://d.hatena.ne.jp/ritou/20121008/1349695124">http://d.hatena.ne.jp/ritou/20121008/1349695124</a></p>

<h3>結論</h3>

<p><s>Covert Redirect によって <strong>access token 漏れるとか、そんな心配は無い</strong>。</s></p>

<p>ただし悪用される open redirector の実装によっては、<strong>code は漏れることもあり得る</strong>。</p>

<p>code が漏れて CSRF に脆弱な Client と組合わさると、被害者の code が本来紐づくべきでない攻撃者のアカウントと紐づいて、Client 側でアカウントが乗っ取られたりってことはあり得る。</p>

<h3>対策</h3>

<p>これから Server 作るときは、redirect_uri は事前登録必須 + 完全一致にしようね。</p>

<p>(特に外部 ID ログイン目的で) OAuth 2.0 を利用する Client 作ってる人は、state パラメータちゃんとチェックしようね。</p>

<p>以上、仕事に戻ります (>_&lt;)></p>

<p><em>ほんとゴールデンウィーク明け初日から&hellip;</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Y!J API が止まった日 - GlobalSign の Root 証明書切れから学んだこと]]></title>
    <link href="http://oauthjp.github.io/blog/2014/01/30/globalsign-root-cert-expired/"/>
    <updated>2014-01-30T11:28:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/01/30/globalsign-root-cert-expired</id>
    <content type="html"><![CDATA[<p>昨日あたりから、Yahoo! Wallet や YConnect といった、Yahoo! Japan の API にアクセスできなくなったって人、ちらほらいるかもしれませんね。</p>

<p>僕もちょっとそういうケース見かけました。</p>

<p>なんか Yahoo! Japan がポカしちゃったの？とか、まぁ昨日まで健康に動いてたシステムが突然 Yahoo! Japan の API にアクセスできなくなっちゃったんだし、そらそう思うのもムリはない。</p>

<p><strong>が、今回のケース、Yahoo! は全く悪くない！<br>プライバシーフリークはどうかと思うがな！！</strong></p>

<p>では早速、今回起こったことを、振り返ってみましょう。</p>

<h3>Yahoo! API にアクセスできなくなった</h3>

<p>Yahoo! Japan は、<b>yahoo.co.jp</b> 以外にも、CDN 用や API 用など、用途ごとにいくつかのドメインを持ってます。
今回止まったのは、その中の API 用の <b>*.yahooapis.jp</b> というドメイン。</p>

<p>Yahoo! Wallet はよく知らないけど、YConnect だと <b>userinfo.yahooapis.jp</b> っていうドメインがあって、そこにアクセスできなくなった。</p>

<p>ただし、API サーバーが止まったとかそういうのではなく、API にリクエスト投げる側での、SSL エラーによって。</p>

<!-- more -->


<h3>どんな SSL エラーが起こっていたのか？</h3>

<script src="https://gist.github.com/nov/8702799.js"></script>


<p>うん&hellip;なんかエラーでてるね！w</p>

<p><code>SSL certificate problem, verify that the CA cert is OK.</code> ですって！</p>

<p>でもぶっちゃけこれでどこが悪いかとか、何すればいいのかとか、サッパリですよね！</p>

<p>SSL まわりのエラー、たいていいつもそんな感じですよね。</p>

<p>そんなとき、来ました！Yahoo! Japan Tech Blog！</p>

<p><a href="http://techblog.yahoo.co.jp/maintenance/4/">WebAPIやOpenIDでSSLエラーが起きる現象につきまして &ndash; Yahoo! JAPAN Tech Blog</a></p>

<h3>GlobalSign の Root 証明書が、期限切れ！？</h3>

<p>Yahoo! Japan Tech Blog 読んで問題理解できる人どれくらいいるのかはよくわかりませんが、まぁ結論としては、リクエスト元のマシンに bundle されてる GlobalSign の Root 証明書が古かったと。</p>

<p>で、今回某マシン上にあった期限切れ GlobalSign Root 証明書が、これ。</p>

<script src="https://gist.github.com/nov/8703001.js"></script>


<p>僕の手元のマシンにある、最新 (といっても発行されたのはもう数年も前) の GlobalSign Root 証明書はこちら。</p>

<script src="https://gist.github.com/nov/8702954.js"></script>


<p>違いは &ldquo;<b>Not After : &hellip;</b>&rdquo; ってところ。</p>

<p>ちなみにどちらの Root 証明書も、そこに含まれてる公開鍵自体は同じなので、こいつの対になってる秘密鍵も同じ。
公開鍵が同じなのは、こんな感じで確認できる。</p>

<script src="https://gist.github.com/nov/8699469.js"></script>


<p>鍵ペア自体は同じなので、その秘密鍵で署名された証明書達 (GlobalSign の中間証明書達) はどちらの Root 証明書を使っても verify できるし、その中間証明書と紐づく秘密鍵で署名されている Yahoo! 等の事業者が持ってる証明書も、どちらの Root 証明書を使っても verify できる。</p>

<p>というか、できていた。古い方が expire するまでは。</p>

<p>もうちょっと細かい話をすると、例えば <b>userinfo.yahooapis.jp</b> の SSL 証明書を検証する場合だと、大雑把に言うと以下のようなフローになる。</p>

<ol>
<li><b>userinfo.yahooapis.jp</b> の証明書 (<b>*.yahooapis.jp</b> 向けマルチドメイン証明書) を取得</li>
<li>1) の証明書が local にある信頼された証明書リストに含まれるかチェック => 通常は含まれてない</li>
<li>1) の証明書を直接信頼することはできないので、1) の証明書の発行者を検証するため 1) の証明書から発行者情報取得</li>
<li><b>*.yahooapis.jp</b> 証明書発行者の証明書を取得 (GlobalSign の中間証明書)</li>
<li>4) の証明書が local にある信頼された証明書リストに含まれるかチェック => 通常は含まれてない</li>
<li>4) の証明書を直接信頼することはできないので、4) の証明書の発行者を検証するため 4) の証明書から発行者情報取得</li>
<li>GlobalSign 中間証明書発行者の証明書を取得 (GlobalSign Root 証明書)</li>
<li>6) の証明書が local にある信頼された証明書リストに含まれるかチェック => <b>これは含まれてる！！</b></li>
</ol>


<p>で、7) の証明書が valid であれば、1) の証明書も valid になる。</p>

<p>そして、7は valid だった。expire するまでは。</p>

<p>でも、expire しちゃったんですね、このタイミングで。<br>
<b>Not After : Jan 28 12:00:00 2014 GMT</b></p>

<p>日本時間で、28日の夜9時。</p>

<p>この時を境に、古い方の GlobalSign Root 証明書を持ってるマシンでは、*.yahooapis.jp はじめ GlobalSign 発行の SSL 証明書を持ってるいろんなサーバーにアクセスする際に、SSL エラーが発生しだしたんですね。</p>

<p>&hellip;そらまぁ、Root 証明書 Expire してますし、エラーですよね&hellip;</p>

<h3>何が起こっていて、何は起こっていなかったのか。</h3>

<p>起こってたこと</p>

<ul>
<li>*.yahooapis.jp アクセス時の SSL エラー</li>
<li>一部の古い OS 積んでるようなマシンに bundle されてる GlobalSign Root 証明書の期限切れ</li>
</ul>


<p>起こってなかったこと</p>

<ul>
<li>Yahoo! の API サーバーが止まった</li>
<li>*.yahoo.co.jp アクセス時の SSL エラー</li>
<li>Yahoo! Japan 側での SSL 証明書更新、設定変更</li>
<li>その他なんらかの Yahoo! 側での異常</li>
<li>OAuth 関連のエラー</li>
</ul>


<p>ようするに、あれだ。</p>

<p><b>お前らいつまで Debian5 (とか CentOS5 とか) 使ってんだよ</b> と。</p>

<p>まぁちゃんと Root 証明書リストとか必要に応じてアップデートできるんなら別だけど、ムリなんだったらやっぱ新しい OS 使おうぜ、と。</p>

<h3>僕がやったこと</h3>

<p>僕が手を下さないと行けなかったのは、たいしたサーバーじゃなかったし、さくっと <code>/etc/ssl/certs/GlobalSign_Root_CA.pem</code> を vi で書き換えるという荒技を使いましたよ。</p>

<p>まさか Root 証明書を vi で書き換える日が来るなんてね。</p>

<h3>得られた教訓</h3>

<p>ぶっちゃけ、Root 証明書って Expire すんだな、ってしみじみ思いましたよ。</p>

<p>落ち着いて考えると、そらまぁするんでしょうけども。</p>

<p>あと GlobalSign、もちょっと期限切れ直前におっきな声でアラートあげてもいんじゃないかなぁ？</p>

<p>今回の件は、厳密には Y!J も GlobalSign も悪くないし、ある意味天災的なもんかとも思いますが、でもこの件で GlobalSign から証明書買おうとする人は、一時的には減るよね。</p>

<p>だって古い OS からはそのままだと SSL エラーでるようになっちゃったんだもの、GlobalSign 発行の証明書。</p>

<p>他にも証明書発行業者が複数あるなかで、それは結構なビジネスリスクですよね。</p>

<p>まぁどんなキャンペーンやればみんなが Debian5 &ndash;> Debian6 に上げるのか、アイデア無いですけども&hellip;</p>

<br>


<br>


<br>


<p>そして、もう一つ、僕らは重要なことを学んだ気がする。</p>

<p><strong style="font-size: 2.5em">PKI、年取ったな。</strong></p>

<br>


<br>


<br>


<p>ps1.</p>

<p>ちなみに、今後数年はメジャーな Root 証明書が Expire することなさげです。気づいたらその数年あっという間に過ぎてんでしょうけど。</p>

<br>


<br>


<br>


<p>ps2.</p>

<p>タイトルの最初で言っといてなんですが、Yahoo! Japan の API は止まってません。
Tech Blog といい、Yahoo! 側では何の問題も起こしてないのに、いろいろこまめに対応しててすばらしいなと思います！</p>

<p><strong>プライバシーフリークはどうかと思うけどな！</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby & PHP の JOSE 実装で JWE draft v17 に追いつきました]]></title>
    <link href="http://oauthjp.github.io/blog/2013/10/25/jwe-draft-v17/"/>
    <updated>2013-10-25T16:34:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2013/10/25/jwe-draft-v17</id>
    <content type="html"><![CDATA[<p>@nov です。</p>

<p>JWE はまだまだ変わりそうな気がしてしばらく最新仕様への追随を怠っていたのですが、先日<a href="https://github.com/nov/json-jwt/issues/14">こんな pull request</a> をいただいたので、以下の2つのライブラリの JWE 実装を、JWE draft v17 に追随させました。</p>

<ul>
<li><a href="https://github.com/nov/json-jwt">Ruby json-jwt gem</a></li>
<li><a href="https://github.com/nov/jose-php">PHP JOSE</a></li>
</ul>


<p>ところでその pull request 内でのやり取りで知ったのですが、Xbox One ってのが JWE を使ってるらしいですね。</p>

<p>他にも Production で JWE 使ってるとことかあるんでしょうか？</p>
]]></content>
  </entry>
  
</feed>
