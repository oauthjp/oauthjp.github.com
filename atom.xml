<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[OAuth.jp]]></title>
  <link href="http://oauthjp.github.io/atom.xml" rel="self"/>
  <link href="http://oauthjp.github.io/"/>
  <updated>2014-05-07T16:55:58+09:00</updated>
  <id>http://oauthjp.github.io/</id>
  <author>
    <name><![CDATA[Nov Matake]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[OAuth 2.0 の脆弱性 (!?) "Covert Redirect" とは]]></title>
    <link href="http://oauthjp.github.io/blog/2014/05/07/covert-redirect/"/>
    <updated>2014-05-07T13:53:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/05/07/covert-redirect</id>
    <content type="html"><![CDATA[<p>ゴールデンウィークまっただなかに Twitter で海外の ID 厨から袋だたきにあってたので、もうこの問題は片付いただろうとすっかり油断してた「Covert Redirect」の件ですが、日本でもゴールデンウィーク明けてバズりだしたので、一旦問題を整理した方がよさそうですね。</p>

<h3>事の発端</h3>

<p>Wang Jing さんていうシンガポールの大学院生が、<a href="http://tetraph.com/covert_redirect/oauth2_openid_covert_redirect.html">こんなサイト</a>を公開すると共に <a href="http://www.cnet.com/news/serious-security-flaw-in-oauth-and-openid-discovered/">CNet</a> はじめ各種メディアが取り上げたのが、バズりだした発端のようです。</p>

<h3>前提知識</h3>

<p>OAuth 2.0 や OpenID Connect だけでなく、OAuth 1.0 や OpenID 1.0/2.0 や SAML なんかでも、<strong>2つのサービスの間でリダイレクトを経由して</strong>、Access Token や ID Token などのいわゆる <strong>&ldquo;Security Token&rdquo; の授受</strong> が行われます。</p>

<p>Covert Redirect の問題は本質的にはこれら全てに影響しますが、各仕様一個一個見て行くといろいろ疲れるので、ここでは OAuth 2.0 に絞って話をすすめましょう。</p>

<p>OAuth 2.0 では、まず Client が End-User の UserAgent を Server の Authorization Endpoint というところにリダイレクトします。よく Twitter とか Facebook の ID で外部サービスにログインするとき、一度 Twitter や Facebook にリダイレクトして、同意画面表示されますよね？あれです。</p>

<p><img src="https://fbcdn-dragon-a.akamaihd.net/hphotos-ak-prn1/t39.2178-6/851557_535801936465660_169463870_n.png" alt="FB の同意画面" /></p>

<p>で、みなさん <s>何も考えず</s> 熟慮の結果、同意ボタンを押すじゃないですか。そして、元のサイト (= Client) に戻って来る、と。</p>

<p>OAuth 愛好家の間で &ldquo;OAuth Dance&rdquo; なんて呼ばれてるアレですね。</p>

<p>で、今回の話は、その <strong>&ldquo;OAuth Dance&rdquo; 中の話</strong> です。</p>

<!-- more -->


<h3>Covert Redirect てなんだ？</h3>

<p>Server 側の同意画面で同意ボタンを押すと、Client にリダイレクトして戻って来る。</p>

<p>そう、同意すると、元の Client に戻って来るんですよ。</p>

<p>で、Client 側に open redirector があって、まさにその open redirector めがけて戻ってきちゃったりしたら、そらもう open に redirect する訳です。</p>

<p>さらに悪いことに、open redirector の実装によっては、リダイレクト時に query に引っ付いてきたデータがそのリダイレクト先にまで渡っちゃうこともあるんです。</p>

<p>渡された query パラメータを全てリダイレクト先にまで forward するような実装、ちょっと正気の沙汰とは思えないかもしれないけど、まぁそういうのは実際あるらしいですし。(ESPN ってサイトがそうらしい)</p>

<p>こうして <strong>Client 側の open redirector が悪用</strong> されて、<strong>query についた Security Token が攻撃者に漏れちゃう</strong> っていうこれ、これが <strong>Covert Redirect</strong> なんです。</p>

<h3>Redirect URI に open redirector !?</h3>

<p>え？なんで redirect_uri に指定するエンドポイントに open redirector が存在すんだよ！って？</p>

<p>えぇ、普通ありえないですよね。</p>

<p>いくら open redirector だらけのザルサイトでも、さすがに redirect_uri に指定するエンドポイントくらいは&hellip;</p>

<p><em>&hellip;いや、P言語ならありえなくもない気がしてきましたけど&hellip;</em></p>

<p>でも Covert Redirect で想定されているケースでは、Client が本来指定する redirect_uri とは別の URL が、攻撃者によって redirect_uri に指定されるというのを想定してます。</p>

<p>で、Server 側では、事前に登録済の redirect_uri と部分一致すれば OK にしちゃうケースが結構あるんです。(domain だけが一致すれば OK とか)</p>

<p>この、<strong>Server 側の甘めの redirect_uri 検証</strong> と、<strong>Client 側が内包する open redirector</strong>、Covert Redirect はこの2つがうまいことくみ合わさって成立するんです。</p>

<p>Server 側では、一度部分一致を許した実装が広く世の中につかわれだしてしまうと、そこの仕様を変更するのはなかなか大変なんで、いざ直そうと思っても数ヶ月から数年の政治的調整作業等が必要になっちゃうかもですね。</p>

<h3>で、どれくらいヤバいの？</h3>

<p>実際の影響については、OpenID Connect の仕様策定者の一人でもある <a href="http://www.thread-safe.com/2014/05/covert-redirect-and-its-real-impact-on.html">John Bradley さんが記事書いてる</a>ので、まぁそれを読んでください。</p>

<p>ほんとはちゃんとこれ訳そうと思ったんですが、<a href="http://www.openid.or.jp/blog/2014/05/covert-redirect-and-its-real-impact-on-oauth-and-openid-connect.html">OpenID Foundation Japan から翻訳版</a>まで出たので、もういんじゃね？って空気を感じています。</p>

<p><em>もういんじゃね？って空気を感じながらも、必死に記事を書いてる僕の心境、お察しください&hellip;</em></p>

<p>で、まぁそんな僕の気持ちなんてスルーして翻訳版なり原文なりを要約すると、Covert Redirect によって <strong>access token 漏れるとか、そんな心配は無い</strong>ってことです。</p>

<p>さらに言えば、<strong>それ別に新しい発見でも何でも無いし</strong>って。</p>

<p><em>え？？漏れないの？？発見でもないの？？</em></p>

<p><em>シンガポールウソばっかなの？？</em></p>

<h3>ちょっとヤバいかも (?) なケース</h3>

<p>ただ、Authorization Code が漏れることはあり得て、被害者の code を攻撃者が正規 Client に送りつけて来て、攻撃者の Client 上のアカウントと被害者の Server 上の access token が紐づいちゃう、なんてことはあり得なくはないですね。</p>

<p>FB Login つかってるサイトでは、Client 上の既に FB と Connect 済の被害者のアカウントに、攻撃者がログインできちゃうかもしれないですね。</p>

<p>ただこれは、各 Client が state パラメーターってのをつかって CSRF 対策することで防ぐことができます。</p>

<p>state パラメータってのは&hellip;まぁ @ritou 先生のブログを読んでみてください。</p>

<p><a href="http://d.hatena.ne.jp/ritou/20121008/1349695124">http://d.hatena.ne.jp/ritou/20121008/1349695124</a></p>

<h3>結論</h3>

<p>Covert Redirect によって <strong>access token 漏れるとか、そんな心配は無い</strong>。</p>

<p>ただし悪用される open redirector の実装によっては、<strong>code は漏れることもあり得る</strong>。</p>

<p>code が漏れて CSRF に脆弱な Client と組合わさると、被害者の code が本来紐づくべきでない攻撃者のアカウントと紐づいて、Client 側でアカウントが乗っ取られたりってことはあり得る。</p>

<h3>対策</h3>

<p>これから Server 作るときは、redirect_uri は事前登録必須 + 完全一致にしようね。</p>

<p>(特に外部 ID ログイン目的で) OAuth 2.0 を利用する Client 作ってる人は、state パラメータちゃんとチェックしようね。</p>

<p>以上、仕事に戻ります (>_&lt;)></p>

<p><em>ほんとゴールデンウィーク明け初日から&hellip;</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Y!J API が止まった日 - GlobalSign の Root 証明書切れから学んだこと]]></title>
    <link href="http://oauthjp.github.io/blog/2014/01/30/globalsign-root-cert-expired/"/>
    <updated>2014-01-30T11:28:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2014/01/30/globalsign-root-cert-expired</id>
    <content type="html"><![CDATA[<p>昨日あたりから、Yahoo! Wallet や YConnect といった、Yahoo! Japan の API にアクセスできなくなったって人、ちらほらいるかもしれませんね。</p>

<p>僕もちょっとそういうケース見かけました。</p>

<p>なんか Yahoo! Japan がポカしちゃったの？とか、まぁ昨日まで健康に動いてたシステムが突然 Yahoo! Japan の API にアクセスできなくなっちゃったんだし、そらそう思うのもムリはない。</p>

<p><strong>が、今回のケース、Yahoo! は全く悪くない！<br>プライバシーフリークはどうかと思うがな！！</strong></p>

<p>では早速、今回起こったことを、振り返ってみましょう。</p>

<h3>Yahoo! API にアクセスできなくなった</h3>

<p>Yahoo! Japan は、<b>yahoo.co.jp</b> 以外にも、CDN 用や API 用など、用途ごとにいくつかのドメインを持ってます。
今回止まったのは、その中の API 用の <b>*.yahooapis.jp</b> というドメイン。</p>

<p>Yahoo! Wallet はよく知らないけど、YConnect だと <b>userinfo.yahooapis.jp</b> っていうドメインがあって、そこにアクセスできなくなった。</p>

<p>ただし、API サーバーが止まったとかそういうのではなく、API にリクエスト投げる側での、SSL エラーによって。</p>

<!-- more -->


<h3>どんな SSL エラーが起こっていたのか？</h3>

<script src="https://gist.github.com/nov/8702799.js"></script>


<p>うん&hellip;なんかエラーでてるね！w</p>

<p><code>SSL certificate problem, verify that the CA cert is OK.</code> ですって！</p>

<p>でもぶっちゃけこれでどこが悪いかとか、何すればいいのかとか、サッパリですよね！</p>

<p>SSL まわりのエラー、たいていいつもそんな感じですよね。</p>

<p>そんなとき、来ました！Yahoo! Japan Tech Blog！</p>

<p><a href="http://techblog.yahoo.co.jp/maintenance/4/">WebAPIやOpenIDでSSLエラーが起きる現象につきまして &ndash; Yahoo! JAPAN Tech Blog</a></p>

<h3>GlobalSign の Root 証明書が、期限切れ！？</h3>

<p>Yahoo! Japan Tech Blog 読んで問題理解できる人どれくらいいるのかはよくわかりませんが、まぁ結論としては、リクエスト元のマシンに bundle されてる GlobalSign の Root 証明書が古かったと。</p>

<p>で、今回某マシン上にあった期限切れ GlobalSign Root 証明書が、これ。</p>

<script src="https://gist.github.com/nov/8703001.js"></script>


<p>僕の手元のマシンにある、最新 (といっても発行されたのはもう数年も前) の GlobalSign Root 証明書はこちら。</p>

<script src="https://gist.github.com/nov/8702954.js"></script>


<p>違いは &ldquo;<b>Not After : &hellip;</b>&rdquo; ってところ。</p>

<p>ちなみにどちらの Root 証明書も、そこに含まれてる公開鍵自体は同じなので、こいつの対になってる秘密鍵も同じ。
公開鍵が同じなのは、こんな感じで確認できる。</p>

<script src="https://gist.github.com/nov/8699469.js"></script>


<p>鍵ペア自体は同じなので、その秘密鍵で署名された証明書達 (GlobalSign の中間証明書達) はどちらの Root 証明書を使っても verify できるし、その中間証明書と紐づく秘密鍵で署名されている Yahoo! 等の事業者が持ってる証明書も、どちらの Root 証明書を使っても verify できる。</p>

<p>というか、できていた。古い方が expire するまでは。</p>

<p>もうちょっと細かい話をすると、例えば <b>userinfo.yahooapis.jp</b> の SSL 証明書を検証する場合だと、大雑把に言うと以下のようなフローになる。</p>

<ol>
<li><b>userinfo.yahooapis.jp</b> の証明書 (<b>*.yahooapis.jp</b> 向けマルチドメイン証明書) を取得</li>
<li>1) の証明書が local にある信頼された証明書リストに含まれるかチェック => 通常は含まれてない</li>
<li>1) の証明書を直接信頼することはできないので、1) の証明書の発行者を検証するため 1) の証明書から発行者情報取得</li>
<li><b>*.yahooapis.jp</b> 証明書発行者の証明書を取得 (GlobalSign の中間証明書)</li>
<li>4) の証明書が local にある信頼された証明書リストに含まれるかチェック => 通常は含まれてない</li>
<li>4) の証明書を直接信頼することはできないので、4) の証明書の発行者を検証するため 4) の証明書から発行者情報取得</li>
<li>GlobalSign 中間証明書発行者の証明書を取得 (GlobalSign Root 証明書)</li>
<li>6) の証明書が local にある信頼された証明書リストに含まれるかチェック => <b>これは含まれてる！！</b></li>
</ol>


<p>で、7) の証明書が valid であれば、1) の証明書も valid になる。</p>

<p>そして、7は valid だった。expire するまでは。</p>

<p>でも、expire しちゃったんですね、このタイミングで。<br>
<b>Not After : Jan 28 12:00:00 2014 GMT</b></p>

<p>日本時間で、28日の夜9時。</p>

<p>この時を境に、古い方の GlobalSign Root 証明書を持ってるマシンでは、*.yahooapis.jp はじめ GlobalSign 発行の SSL 証明書を持ってるいろんなサーバーにアクセスする際に、SSL エラーが発生しだしたんですね。</p>

<p>&hellip;そらまぁ、Root 証明書 Expire してますし、エラーですよね&hellip;</p>

<h3>何が起こっていて、何は起こっていなかったのか。</h3>

<p>起こってたこと</p>

<ul>
<li>*.yahooapis.jp アクセス時の SSL エラー</li>
<li>一部の古い OS 積んでるようなマシンに bundle されてる GlobalSign Root 証明書の期限切れ</li>
</ul>


<p>起こってなかったこと</p>

<ul>
<li>Yahoo! の API サーバーが止まった</li>
<li>*.yahoo.co.jp アクセス時の SSL エラー</li>
<li>Yahoo! Japan 側での SSL 証明書更新、設定変更</li>
<li>その他なんらかの Yahoo! 側での異常</li>
<li>OAuth 関連のエラー</li>
</ul>


<p>ようするに、あれだ。</p>

<p><b>お前らいつまで Debian5 (とか CentOS5 とか) 使ってんだよ</b> と。</p>

<p>まぁちゃんと Root 証明書リストとか必要に応じてアップデートできるんなら別だけど、ムリなんだったらやっぱ新しい OS 使おうぜ、と。</p>

<h3>僕がやったこと</h3>

<p>僕が手を下さないと行けなかったのは、たいしたサーバーじゃなかったし、さくっと <code>/etc/ssl/certs/GlobalSign_Root_CA.pem</code> を vi で書き換えるという荒技を使いましたよ。</p>

<p>まさか Root 証明書を vi で書き換える日が来るなんてね。</p>

<h3>得られた教訓</h3>

<p>ぶっちゃけ、Root 証明書って Expire すんだな、ってしみじみ思いましたよ。</p>

<p>落ち着いて考えると、そらまぁするんでしょうけども。</p>

<p>あと GlobalSign、もちょっと期限切れ直前におっきな声でアラートあげてもいんじゃないかなぁ？</p>

<p>今回の件は、厳密には Y!J も GlobalSign も悪くないし、ある意味天災的なもんかとも思いますが、でもこの件で GlobalSign から証明書買おうとする人は、一時的には減るよね。</p>

<p>だって古い OS からはそのままだと SSL エラーでるようになっちゃったんだもの、GlobalSign 発行の証明書。</p>

<p>他にも証明書発行業者が複数あるなかで、それは結構なビジネスリスクですよね。</p>

<p>まぁどんなキャンペーンやればみんなが Debian5 &ndash;> Debian6 に上げるのか、アイデア無いですけども&hellip;</p>

<br>


<br>


<br>


<p>そして、もう一つ、僕らは重要なことを学んだ気がする。</p>

<p><strong style="font-size: 2.5em">PKI、年取ったな。</strong></p>

<br>


<br>


<br>


<p>ps1.</p>

<p>ちなみに、今後数年はメジャーな Root 証明書が Expire することなさげです。気づいたらその数年あっという間に過ぎてんでしょうけど。</p>

<br>


<br>


<br>


<p>ps2.</p>

<p>タイトルの最初で言っといてなんですが、Yahoo! Japan の API は止まってません。
Tech Blog といい、Yahoo! 側では何の問題も起こしてないのに、いろいろこまめに対応しててすばらしいなと思います！</p>

<p><strong>プライバシーフリークはどうかと思うけどな！</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby & PHP の JOSE 実装で JWE draft v17 に追いつきました]]></title>
    <link href="http://oauthjp.github.io/blog/2013/10/25/jwe-draft-v17/"/>
    <updated>2013-10-25T16:34:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2013/10/25/jwe-draft-v17</id>
    <content type="html"><![CDATA[<p>@nov です。</p>

<p>JWE はまだまだ変わりそうな気がしてしばらく最新仕様への追随を怠っていたのですが、先日<a href="https://github.com/nov/json-jwt/issues/14">こんな pull request</a> をいただいたので、以下の2つのライブラリの JWE 実装を、JWE draft v17 に追随させました。</p>

<ul>
<li><a href="https://github.com/nov/json-jwt">Ruby json-jwt gem</a></li>
<li><a href="https://github.com/nov/jose-php">PHP JOSE</a></li>
</ul>


<p>ところでその pull request 内でのやり取りで知ったのですが、Xbox One ってのが JWE を使ってるらしいですね。</p>

<p>他にも Production で JWE 使ってるとことかあるんでしょうか？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails SessionにCookieStore使った時の問題点]]></title>
    <link href="http://oauthjp.github.io/blog/2013/09/26/rails-session-cookie/"/>
    <updated>2013-09-26T12:45:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2013/09/26/rails-session-cookie</id>
    <content type="html"><![CDATA[<p>今日 @mad_p さんからRT来てたこのツイートに関して、ちょっと調べたのでまとめときます。</p>

<blockquote class="twitter-tweet"><p>Security Issue in Ruby on Rails Could Expose Cookies <a href="http://t.co/JlsXVEn4rZ">http://t.co/JlsXVEn4rZ</a></p>&mdash; Ruby on Rails News (@RubyonRailsNews) <a href="https://twitter.com/RubyonRailsNews/statuses/383002160654336000">September 25, 2013</a></blockquote>


<script async src="http://oauthjp.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<h3>前提条件</h3>

<p>Railsではデフォルトでsessionをcookieにのみ保存して、DBなりmemcacheなりのserver-side storageには何も保存しません。
これがCookieStoreとか呼ばれてるやつです。</p>

<p>この場合のsession cookieは、Railsのsession object (Hash object) をMarshal.dumpしてそれに署名を付けたtokenです。
rails 4では署名付ける代わりに暗号化してるけど、ここで述べる問題に関してはsignedなのかencryptedなのかは関係ないのでその点は無視していいです。</p>

<p>「current user identifierを含むSigned JSONをcookieに入れてるのと同じなので、OpenID ConnectのID Tokenがcookieに入ってるようなもんだと思えばいい」と言えば、#idcon に来たり定期的にOAuth.jp読んだりしてる人には通じるだろうと期待します。</p>

<h3>問題点</h3>

<p>server-sideではstate管理しないので、当然remoteでセッションの無効化はできません。
つまりログアウトしてもsession cookieのtoken自体は無効化されません。</p>

<p>これを確認するには、サイトにログインしてCookie Headerから_foo_cookieってやつ見つけ出してその値をコピーして、CharlesでRequest Cookie Headerの_foo_sessionの値を常にそのコピーした値に書き換えてやるようなRewriteルールを設定してやって、サイトからログアウトしてみるとよいです。
通常server-sideでsession管理してるサービスだとこれでログアウトされるけど、CookieStoreを使ってる場合はこの条件の元ではログアウトしてもログイン状態のままになります。</p>

<p>でもまぁこれはCookieStoreの仕組み上どうしようもないのです。</p>

<p>問題は、session cookieが無効化できないのに、それが永遠に有効であること。
FBとかY!Jとかでやってる「パスワード変更したら既存のsessionが無効になる」ってのはRailsは一切面倒見てくれないので、パスワード変えても漏洩したsession cookieは有効なままです。
なので、ひとたびsession cookieが漏れたら、完全にアウト。
なにやってもアカウント乗っ取られたまんま。永遠に。</p>

<!-- more -->


<h3>解決策</h3>

<p><a href="http://www.bryanrite.com/ruby-on-rails-cookiestore-security-concerns-lifetime-pass/">こちらのブログ記事</a>は2011年のものなので、この問題自体は古くから知られている問題なのだと思います。僕知らなかったけど :p</p>

<p>この記事では以下のように「SSL使えばいいよ」って解決策示されてるけど、SSL化はsession cookieが漏洩する可能性を低くするだけで、「session cookie tokenが永遠に有効である」という状況を回避するものではないです。</p>

<blockquote>
The best and easiest solution is simply to use SSL.  Not just on your login forms and actions, but your entire site, or at least any pages where you have sessions turned on.  With SSL on, the user will not be able to replay your cookies and the entire attack vector is shut down.  Rails 3.1 has a handy force_ssl switch you can use, and you can use something like:
</blockquote>


<p>「session cookie tokenが永遠に有効である」という状況を回避したい場合は、各デベロッパーが <code>session[:expires_at] = 1.hour.from_now</code> とかして session cookie token 自体に有効期限を含めて、それを毎リクエストごとにチェックする必要があります。</p>

<p>OpenID ConnectのID Tokenでも同じ問題が発生しうるので、ID Tokenは有効期限 (exp) をtoken自体に含んでいます。
で、ID Tokenを受け取ったサービスは、署名検証と同時に有効期限もチェックすることで、ID Tokenが漏洩してもなりすましリスクを一定期間内に狭めることができます。
ID Tokenはnonceを含むこともできる (し多分通常はnonce付いてる) ので、onetime tokenとして利用することもできます。
onetime tokenとして扱うと、なりすましリスクはかなり限定的になるでしょう。(ゼロではない)</p>

<p>&hellip;ってことで、RailsのsessionでもOpenID ConnectのID Tokenが含んでるような情報を含むようにして、ID Tokenのverificationと同じような処理をsession受け取った際にやってやれば、それで良いのです。
あとはConnectの仕様さえ読めばOKェ</p>

<p>もしくはCookieStoreの代わりにMemcacheStore使うようにしてもいいです。
sessionをserver-sideで管理するようにさえすれば、この問題はそもそも発生しないですし。
パフォーマンスに影響しますけど。</p>

<h3>捕捉</h3>

<p>Railsには<code>config/initializers/session_store.rb</code>には<code>expires_after</code>ってオプションもあるけど、こちらはあくまでcookieの有効期限であって、悪意の無い通常のユーザーが普通にブラウザでアクセスしてればその期間すぎたらブラウザがcookieを削除してくれるけど、悪意あるユーザーはわざとcookieの有効期限無視してsession cookie送りつけてきたりするので、そこの設定はこのケースでは意味ない。</p>

<p>ログアウト処理で<code>session.delete</code> (<code>session.clear</code>だっけ？ちょっと記憶曖昧) すると、RailsはSetCookieヘッダーを返してブラウザからそのsession cookieを削除しようとします。
が、そのsession cookieを削除するかどうかの決定権は、server-sideではなくclient-sideに存在します。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JWT & JWS 翻訳第一弾リリース]]></title>
    <link href="http://oauthjp.github.io/blog/2013/09/08/jwt-jws-trans-phase1-released/"/>
    <updated>2013-09-08T15:30:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2013/09/08/jwt-jws-trans-phase1-released</id>
    <content type="html"><![CDATA[<p>先日 <a href="http://oauthjp.github.io/blog/2013/08/17/jwt-jws-trans/">JWT &amp; JWS 翻訳プロジェクトスタート &amp; イベント紹介</a> でお伝えした JWT &amp; JWS 翻訳プロジェクトですが、無事翻訳をリリースできました。</p>

<ul>
<li><a href="http://openid-foundation-japan.github.io/draft-ietf-oauth-json-web-token-11.ja.html">JSON Web Token (JWT)</a></li>
<li><a href="http://openid-foundation-japan.github.io/draft-ietf-jose-json-web-signature-14.ja.html">JSON Web Signature (JWS)</a></li>
<li><a href="http://openid-foundation-japan.github.io/draft-ietf-jose-use-cases-03.ja.html">JOSE UseCases</a></li>
</ul>


<p>OpenID TechNight Vol.10 ではこれらの仕様の概要説明も行いましたので、そこでのスライドもここに挙げておきます。
(なぜかいま現在僕の環境ではこちら404 Not Foundになってしまいますが&hellip;)</p>

<ul>
<li><a href="http://slideshare.net/matake/jwt-trans">JWT &amp; JOSE 翻訳</a></li>
</ul>


<p>引き続き JSON Web Encryption (JWE) および OAuth2 JWT Bearer Token Profile も翻訳予定です。(スケジュール未定)
翻訳にご協力いただける方は、<a href="http://twitter.com/nov">@nov</a> まで :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[エンプラグレード OAuth 2.0]]></title>
    <link href="http://oauthjp.github.io/blog/2013/08/30/enterprise-grade-oauth2/"/>
    <updated>2013-08-30T00:27:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2013/08/30/enterprise-grade-oauth2</id>
    <content type="html"><![CDATA[<p>エンプラ、よく分かりません。</p>

<p>エンプラグレード、逆に不安です。</p>

<p>と、まぁそんな内輪ネタはさておき、最近はエンプラで OAuth 2.0 使う事例も増えてるようです。</p>

<p>Google Apps とか導入してたら、OAuth 2.0 とか G+ Sign-in (= OpenID Connect) も使うでしょうし、そんな時にエンプラだと特定のアプリにだけ特定の API へのアクセスを許可したい、なんてこともあるんでしょう。</p>

<p>で、今日それっぽい事例をちょっと見かけたので、response_type=code ってなってるとこを response_type=token に書き換えてやったんですが&hellip;</p>

<p>しっかり access_token 取れて、自分で書いたスクリプトからも API アクセスできましたよ！</p>

<p>特定アプリに限定したつもりでも、別に自分のアカウントと紐づいた access_token 取るだけなら client_secret いらなかったりするのは、当然っちゃ当然なのですが、これがエンプラの世界では許容されるのかされないのかがよく分かんないです。</p>

<p>もし許容されないのだとしたら、特定のアプリに限定するってなら response_typ=code に限定するとかもしないとダメなんでしょうねぇ。</p>

<p>と、Octopress に移行して断然ブログ書きやすくなったので、つらつら書いてみました。</p>

<!-- more -->


<p>== 以下ステマ ==</p>

<p>ん？「エンプラで OAuth 2.0」ってのに興味湧きました？</p>

<p>そんなあなたに <a href="http://openid.doorkeeper.jp/events/5373">OpenID TechNight vol.10</a>！</p>

<p>今回の TechNight は日本最先端のエンプラ ID 厨たちが集うエンプラ特集。</p>

<p>先日アメリカで開催された世界のエンプラ ID 厨が集う <a href="http://www.cloudidentitysummit.com">Cloud Identity Summit (CIS) 2013</a> に参加した日本のエンプラ ID 厨たちが、CIS で感じた世界のエンプラ ID ビジネス／テクノロジーの動向を熱く語ります。たぶん。</p>

<p>てかなんだここ最近のエンプラ ID 厨の盛り上がりは！</p>

<p>エンプラ ID 厨向けの TechNight に既に申し込み100名超えてるとか (((((( ;ﾟДﾟ)))))ｶﾞｸｶﾞｸﾌﾞﾙﾌﾞﾙ</p>

<p>ps.</p>

<p>関西在住でさすがにそんな気軽に関東に来れないって方には、<a href="http://nosurrender.jp/idit2013/">ID &amp; IT 2013</a> の大阪会場に参加するという手も。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JWT & JWS 翻訳プロジェクトスタート & イベント紹介]]></title>
    <link href="http://oauthjp.github.io/blog/2013/08/17/jwt-jws-trans/"/>
    <updated>2013-08-17T19:15:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2013/08/17/jwt-jws-trans</id>
    <content type="html"><![CDATA[<p>先週から, JWxファミリーの以下の3つの仕様書の翻訳を始めています.</p>

<ul>
<li><a href="http://tools.ietf.org/html/draft-ietf-oauth-json-web-token-11">JSON Web Token (JWT)</a></li>
<li><a href="http://tools.ietf.org/html/draft-ietf-jose-json-web-signature-14">JSON Web Signature (JWS)</a></li>
<li><a href="http://tools.ietf.org/html/draft-ietf-jose-use-cases-03">JOSE UseCases</a></li>
</ul>


<p>翻訳資料の公開は <a href="http://openid.doorkeeper.jp/events/5373">OpenID TechNight Vol.10</a> のある 9/4 に予定してます.
<a href="http://openid.doorkeeper.jp/events/5373">OpenID TechNight Vol.10</a> では僕から簡単にこれら各仕様の概要についてもご紹介しますので, 興味ある方はぜひご参加を.</p>

<p>また <a href="https://github.com/openid-foundation-japan/draft-ietf-jose">JWx 翻訳プロジェクト GitHub レポジトリ</a>にはこの他にも JSON Web Encryption や JWT Bearer といった関連仕様も含まれていて, これらも同様に翻訳予定です.
これらの翻訳公開時期はまだ未定ですが, 9/20 の <a href="http://nosurrender.jp/idit2013/">ID &amp; IT 2013</a> に合わせて公開できればなと考えています.
こちらのカンファレンスもエンタープライズ業界で Identity に携わっている人には必見です!</p>

<p><strong>要するに, 9月がアツイ!</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress x GitHub Pagesに移行]]></title>
    <link href="http://oauthjp.github.io/blog/2013/08/17/migration-to-octopress-x-github-pages/"/>
    <updated>2013-08-17T16:00:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2013/08/17/migration-to-octopress-x-github-pages</id>
    <content type="html"><![CDATA[<p>どうもTumblrをブログとして使うの辛いので、Octopressに移行します。</p>

<p>またURL変わっちゃうのは&hellip;直せそうではあるけどちとメンドイ&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Login with Amazon、もう使っても大丈夫！]]></title>
    <link href="http://oauthjp.github.io/blog/2013/06/04/login-with-amazon/"/>
    <updated>2013-06-04T00:00:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2013/06/04/login-with-amazon</id>
    <content type="html"><![CDATA[<p>先日以下のような記事を書きました。</p>


<p><a href="http://oauthjp.github.io/blog/2013/05/30/login-with-amazon">Login with Amazonを使うと、あなたのサイトのユーザーがアカウントハイジャックされる。</a></p>


<p>Login with Amazon 危険ですよ！という記事だったのですが、その後 Login with Amazon のドキュメントに、Token Info API が追加されました。</p>


<p>こちらの Step4 Obtain Profile Information のサンプルコードで、Profile API を叩く前に Token 発行先の Client ID が自身の Client ID と一致することを確認する処理が追加されています。</p>


<p><a href="http://login.amazon.com/website">Web - Login with Amazon Developer Center</a></p>


<p>こちらのより詳細なドキュメントには、Security Considerations の &#8220;Impersonating a Resource Owner in Implicit Flow&#8221; という節で、Token Info API を使わない場合の攻撃例が述べられています。</p>


<p><a href="https://images-na.ssl-images-amazon.com/images/G/01/lwa/dev/docs/website-developer-guide._TTH_.pdf">Login with Amazon - Developer Guide for Websites (PDF)</a></p>


<p>というわけで、Login with Amazon、ドキュメント通り実装すれば安全です :)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Login with Amazonを使うと、あなたのサイトのユーザーがアカウントハイジャックされる。]]></title>
    <link href="http://oauthjp.github.io/blog/2013/05/30/login-with-amazon/"/>
    <updated>2013-05-30T00:00:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2013/05/30/login-with-amazon</id>
    <content type="html"><![CDATA[<p>Amazon が、<a href="http://login.amazon.com">Login with Amazon</a> というAPIおよびそれに付随する JS / iOS / Android SDKs を出してきました。</p>


<p>以下の記事にあるように、OAuth 2.0 ベースで認証連携を行う仕組みです。</p>


<p><a href="http://itpro.nikkeibp.co.jp/article/NEWS/20130530/480782/">Amazonアカウントでアプリやサイトにログイン、「Login with Amazon」を提供開始：ITpro</a></p>


<p>しかし、この Login with Amazon、まさに僕が以前以下の記事で紹介した「Facebook ID でログイン」の間違った実装方法を、公式ドキュメントで推奨してしまっています。</p>


<p><a href="http://www.atmarkit.co.jp/ait/articles/1209/10/news105_2.html">デジタル・アイデンティティ技術最新動向（2）：RFCとなった「OAuth 2.0」――その要点は？ (2/2) - ＠IT</a></p>


<p>この Amazon のドキュメントを読んで (or 「Facebook ID でログイン」を実装した経験を元に) Login with Amazon を自身の Web Site や iOS / Android アプリに導入すると、まず確実にあなたのサイト / アプリのアカウントがハイジャックされるような脆弱性を生むことになります。</p>


<p>@IT の記事からのリンクは OAuth.jp の Posterous -&gt; Tumblr 移行に伴いリンク切れになってしまっているので、ここにも OAuth 2.0 Implicit Flow を認証連携に使うことの危険性を説明するエントリーをリンクしておきます。</p>


<p><a href="http://oauthjp.github.io/blog/2012/02/08/ios-sdk">&#8220;なんちゃら iOS SDK&#8221; でありそうな被害例</a></p>


<p>Facebook の場合は、上の記事にあるような response_type=code+token を iOS / Android アプリでは使えないので、以下の記事末尾にあるような対処法も用意されています。</p>


<p><a href="http://oauthjp.github.io/blog/2012/02/07/oauth-20-implicit-flow">「OAuth 2.0 (Implicit Flow) でログイン」の被害例</a></p>


<p>が、ざっと Login with Amazon のドキュメントを読んだ限り、そのような対処法が一切用意されていない。</p>


<p>これはもう、Login with Amazon を導入した時点で、Amazon 側の対応無しではあなたのサイト / サービスの脆弱性を止めることができないということです。</p>


<p>既に一部有識者より Amazon 側に連絡が行っているようなので、さすがにこのまま Amazon が何の対応も取らないということは考えにくいですが、Amazon が何らかのアップデートを出してくるまで、Login with Amazon を使ってはいけません。</p>


<p>ご注意を。</p>


<p>[追記 2013.06.04]</p>


<p>Login with Amazon の問題点、解決されました。詳しくは以下の記事を。</p>


<p><a href="http://oauthjp.github.io/blog/2013/06/04/login-with-amazon">Login with Amazon、もう使っても大丈夫！</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth 2.0 Core & Bearer Spec (RFC 6749 & RFC 6750) 翻訳公開！]]></title>
    <link href="http://oauthjp.github.io/blog/2013/01/23/oauth-20-core-bearer-spec-rfc-rfc-6749-rfc-67/"/>
    <updated>2013-01-23T00:00:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2013/01/23/oauth-20-core-bearer-spec-rfc-rfc-6749-rfc-67</id>
    <content type="html"><![CDATA[<p>ずいぶん前に「<a href="http://oauthjp.github.io/blog/2011/11/29/oauth-20-core-bearer-spec-76993">OAuth 2.0 Core &amp; Bearer Spec 翻訳公開！</a>」で紹介したように、OAuth 2.0 Core &amp; Bearerは、OpenID Foundation Japanの翻訳WGで翻訳を公開していましたが、2012年に両specがRFC化されたのを受け、今回RFC版も翻訳しました。</p>


<ul><li><a href="http://openid-foundation-japan.github.com/rfc6749.ja.html">The OAuth 2.0 Authorization Framework (RFC 6749)</a></li>
<li><a href="http://openid-foundation-japan.github.com/rfc6750.ja.html">The OAuth 2.0 Authorization Framework: Bearer Token Usage (RFC 6750)</a></li>
</ul>


<p>前回翻訳したdraft版から仕様自体に大きな変更はありませんが、特に</p>


<ul><li>まだdraft版も読んだことが無い人</li>
<li>自社のAPIドキュメントからdraft版の翻訳にリンクしている人</li>
</ul>


<p>などは、RFC版を参照していただければと思います。</p>


<p>いまこれらとは別に、”<a href="http://openid-foundation-japan.github.com/rfc6819.ja.html">OAuth 2.0 Threat Model and Security Considerations (RFC 6819)</a>” という、OAuth 2.0の利用に際して注意すべきセキュリティ上の特徴・注意点などについてまとめたドキュメントを翻訳中です。こちらも翻訳完了次第公開予定。(追記: 2013.01.25 翻訳公開済)</p>


<p>最後に、2/1に東京ミッドタウンのYahoo! Japanオフィスで <a href="http://idcon.doorkeeper.jp/events/2448">#idcon 15th ~ YConnect &amp; Future of Authentication ~</a> というイベントをやります。OAuth 2.0ベースのOpenID次世代仕様であるOpenID Connectについて、世界で初めてOpenID Connect対応API (YConnect) を一般公開したYahoo! Japanの担当者の方の話も聞けるので、興味あったら参加してください :)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Yahoo! JapanがOAuth 2.0 & OpenID Connectに対応]]></title>
    <link href="http://oauthjp.github.io/blog/2012/11/08/yahoo-japanoauth-20-openid-connect/"/>
    <updated>2012-11-08T00:00:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2012/11/08/yahoo-japanoauth-20-openid-connect</id>
    <content type="html"><![CDATA[<p>2011年12月のOpenID Summit Tokyoで、2012年中のOpenID Connect対応を宣言したYahoo! Japanが、本日ついに宣言通りOpenID Connectをサポート開始しました。</p>


<p>もともとOAuth 2.0も対応していなかった（よね？）ので、OAuth 2.0対応も同時リリースです。</p>


<p>まだバグとかあるっぽいけど、何はともあれ世界の大手IdPの中で一番最初にproduction環境でOpenID Connect対応できたのはすばらしい！</p>


<p><iframe scrolling="no" margin src="http://www.slideshare.net/slideshow/embed_code/10433061" frameborder="0"> </iframe></p>


<div style="margin-bottom: 5px;"><strong> <a href="http://www.slideshare.net/tzmtk/openid-summit-tokyo-2011" title="OpenID Summit Tokyo 2011" target="_blank">OpenID Summit Tokyo 2011</a> </strong> from <strong><a href="http://www.slideshare.net/tzmtk" target="_blank">Taizo Matsuoka</a></strong></div>


<p>まだOpenID ConnectのDiscoveryとDynamic Registrationには対応していないので、<a href="https://connect-rp.heroku.com">Nov RP</a>に &#8220;yahoo.co.jp&#8221; とか入力しても使えない状態ですが、それは今後に期待です。</p>


<p>YConnectをちょこっと触ってみて思った要望とかは以下のgistにまとめていってます。</p>


<script src="https://gist.github.com/4031074.js?file=gistfile1.textile"></script>


<p>scopeにopenidが指定されてるのにtoken responseにid_tokenが含まれてないとか、response_type=code+id_tokenの時にcodeとid_tokenがredirect_uriのfragmentではなくqueryについているなどの問題は、ただのバグとして修正すれば良いでしょう。</p>


<p>それ以外でいま気になってる点としては、以下の2点です。</p>


<ul><li>response_type=code+tokenサポートしてもらわないとserver-side componentを持つmobile appから使おうとしたときにいろいろめんどくさいことになっちゃうのはFBとか見てたら明らですが、現状のYConnectは「サーバーサイド」アプリとして登録した場合response_typeにcodeかcode+id_tokenしか指定できないみたいです。これはちょっとやめた方が良い気がします。</li>
<li>あと、id_tokenのsignature algorithmはdefault RS256ということで進んでいるので、YConnectだけがHS256だとまたYAuthとか言われちゃったりしそうですね。</li>
</ul>


<p>それ以外にも、なぜかyahoo.co.jp以外のドメインのメアドはverfiedじゃなくても返してくれる (試しに <a href="mailto:hoge@hoge.com">hoge@hoge.com</a> というメアドを登録してみたらそれ返してきたw）のにyahoo.co.jpのメアドは返してくれないというのも不思議といえば不思議ですが、まぁ社内調整とかいろいろめんどくさいことありそうですし、それが原因でOpenID Connect対応のスケジュールが遅れるくらいならとりあえずそれでもいいのかなとも思います。</p>


<p>Implicitの方でscopeにopenidが指定された時にnonceが必須になってるかとかもチェックしたかったのですが、なんかいま「クライアントサイド」のアプリを登録しようとするとエラーになっちゃうバグがあるようなので、そちらはまた明日にでも。覚えてれば。</p>


<p>OAuth 2.0 draft 0の時点で対応してきたFacebookのように、これからOpenID Connectのbreaking changesに追随するのは大変だと思いますが、引き続きがんばってください！あと、OpenID Connectにbreaking changeがある時に一番大きな声で文句言える立場にいるので、ぜひOpenID Connect Interopにも積極的に参加していただければ :)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSON Web Token (JWT)]]></title>
    <link href="http://oauthjp.github.io/blog/2012/10/26/json-web-token-jwt/"/>
    <updated>2012-10-26T00:00:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2012/10/26/json-web-token-jwt</id>
    <content type="html"><![CDATA[<p>@novです。</p>


<p>個人的に最近OAuth 2.0よりJWT (というかJWS) を利用するシーンが多く、毎回同じ説明するのもめんどくさいのでブログにまとめるかと思い、どうせならOAuth.jpに書くかということで、こんな記事を書いております。</p>


<p>（そろそろJWTとJWSは、OpenID Foundation Japanの翻訳WGで翻訳するべき？）</p>


<h3>JSON Web Token (JWT) とは、JSONをトークン化する仕組み。</h3>


<p>元々はJSONデータにSignatureをつけたりEncryptionする仕組みとして考えられたものの、Signature部分がJSON Web Signatue (JWS)、Encryption部分がJSON Web Encryption (JWE) という仕様に分割された。</p>


<p>それぞれ2012年10月26日現在の最新仕様はこちら。</p>


<p>（JWTとJWSは既にだいぶ仕様が固まってきているものの、まだIETFのInternet-Draftなので注意）</p>


<ul><li><a href="http://tools.ietf.org/html/draft-ietf-oauth-json-web-token-04">JSON Web Token (JWT, draft 04)</a></li>
<li><a href="http://tools.ietf.org/html/draft-ietf-jose-json-web-signature-06">JSON Web Signature (JWS, draft 06)</a></li>
<li><a href="http://tools.ietf.org/html/draft-ietf-jose-json-web-encryption-06">JSON Web Encryption (JWE, draft 06)</a></li>
</ul>


<p>JWEはまだ実際に使うケースが無いので、ここでは説明しない。</p>


<p><b><i>追記:</i></b><br><i>draft versionが違いますが、<a href="http://openid-foundation-japan.github.io/draft-ietf-oauth-json-web-token-11.ja.html">JWT仕様翻訳版</a>と<a href="http://openid-foundation-japan.github.io/draft-ietf-jose-json-web-signature-14.ja.html">JWS仕様翻訳版</a>もご参考に。</i></p>


<h3>Signed JWT</h3>


<p>JWS使ってSignatureつけられたJWT。</p>


<p>HeaderとPayloadとSignatureという3つのセグメントから構成される。</p>


<p>Headerは署名アルゴリズムなどを含むJSONを、URL-safe Base64 Encodingした文字列。</p>


<p>Payloadは実際に送信したいJSONデータそのものを、URL-safe Base64 Encodingした文字列。</p>


<p>Signatureは、HeaderとPayloadを &#8220;.&#8221; で連結した文字列に対して、Headerに指定されたアルゴリズムで署名をして、その署名をURL-safe Base64 Encodingした文字列。</p>


<p>サンプルは<a href="http://tools.ietf.org/html/draft-ietf-oauth-json-web-token-04#section-3.1">JWT Spec Section 3.1</a> (draft 04の場合) を読むこと。</p>


<p><b><i>追記:</i></b><br><i>draft versionが違いますが、<a href="http://openid-foundation-japan.github.io/draft-ietf-oauth-json-web-token-11.ja.html#ExampleJWT">JWT仕様の翻訳版の該当箇所はこちら</a>。</i></p>


<h3>Signature Algorithms</h3>


<p>サポートされているアルゴリズムは、これまた別仕様のJSON Web Algorithm (JWA) で規定されている。</p>


<ul><li><a href="http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-06">JSON Web Algorithm (JWA, draft 06)</a></li>
</ul>


<p>JWA Section 3 (draft 06 現在) では、JWSの署名アルゴリズムとして以下のアルゴリズムがサポートされている。</p>


<ul><li>HMAC-SHA256</li>
<li>HMAC-SHA384</li>
<li>HMAC-SHA512</li>
<li>RSA-SHA256</li>
<li>RSA-SHA384</li>
<li>RSA-SHA512</li>
<li>ECDSA-SHA256</li>
<li>ECDSA-SHA384</li>
<li>ECDSA-SHA512</li>
</ul>


<p>正直ECDSA (楕円曲線暗号) ってのは僕もよく理解していなし、Ruby以外で使いたい場合にどう書けばいいかとかさっぱりなので、個人的には共通鍵使う場合はHMAC、公開鍵使う場合はRSAを使っている。</p>


<p>例えば、こんな感じ。</p>


<ol><li>認証サーバーからiOSアプリに渡すデータには (認証サーバーの秘密鍵を使って) RSA-SHA256使って署名</li>
<li>iOSアプリからリソースサーバー (認証サーバーとは別) に渡すJSONには、Step 1で認証サーバーに署名されたJWSに入ってる共通鍵を利用してHMAC-SHA256使って署名</li>
<li>リソースサーバーはiOSアプリからStep 1で発行されたJWSとStep 2で発行されたJWSを同時に受け取って、Step 1のJWSを検証した後そこに含まれてる共通鍵でStep 2のJWSを検証</li>
<li>リソースサーバーはレスポンスに (リソースサーバーの秘密鍵を使って) RSA-SHA256使って署名</li>
</ol>


<p>（iOSではSHA256よりSHA1の方が使いやすいらしく、HMAC-SHA1とRSA-SHA1使ってたりすることもあるが..）</p>


<h3>各言語のライブラリ (情報求む！)</h3>


<ul><li><span>Ruby </span><a href="https://github.com/nov/json-jwt">json-jwt</a></li>
<li><span>Python </span><a href="https://github.com/rohe/pyjwkest">pyjwkest</a></li>
<li><span>Java </span><a href="https://bitbucket.org/nimbusds/nimbus-jose-jwt/wiki/Home">Nimbus JOSE+JWT</a></li>
<li><span>PHP </span><a href="https://github.com/ritou/php-Akita_JOSE">PHP Akita JOSE</a><span>,</span><span> </span><a href="https://github.com/nov/jose-php">JOSE</a></li>
<li><span>Perl </span><a href="https://github.com/xaicron/p5-JSON-WebToken">JSON::WebToken</a></li>
</ul>


<p>Rubyのjson-jwtとPHPのJOSE (2番目の方) は僕が作ってるので、README (希望としてはSpecも) とか読んでも使い方分からない場合は僕に直接聞いていただければと思います。</p>


<p>それ以外はあんまり詳しく使い方知らないので、使い方についてはドキュメント (あれば) 読むなりそれぞれの作者に直接聞いてください。それぞれの作者に紹介するくらいならできます。</p>


<p>node.jsとかObjective-CにもJSON Web Tokenのライブラリは見かけるのですが、HMACしかサポートしてなかったりしていまいち使えそうなの見つけられてません。（多分Google Wallet APIでHMACなJWSが使われてるので、それだけサポートしたライブラリがあるんだと予想）</p>


<p>ここにない言語でRSAもサポートしてるライブラリご存知でしたらお教えいただけるとうれしいです。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Facebookが新たなAccess Token Introspection APIを出したようです]]></title>
    <link href="http://oauthjp.github.io/blog/2012/10/16/facebookaccess-token-introspection-api/"/>
    <updated>2012-10-16T00:00:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2012/10/16/facebookaccess-token-introspection-api</id>
    <content type="html"><![CDATA[<p>今朝fb_graphにこんな要望が来てて知ったのですが、Facebookが新たなAccess Token Introspection APIを出したようです。</p>


<p><a href="https://github.com/nov/fb_graph/issues/269">Adding support for /debug_token endpoint · Issue #269 · nov/fb_graph</a></p>


<p>こんなリクエストを送ると</p>


<p><a href="https://gist.github.com/3896829"><a href="https://gist.github.com/3896829">https://gist.github.com/3896829</a></a></p>


<p>こんなレスポンスが帰ってくる、と。</p>


<p><a href="https://gist.github.com/3896826"><a href="https://gist.github.com/3896826">https://gist.github.com/3896826</a></a></p>


<p>&#8220;data&#8221; ってなんやろとかApp Token無いと使えへんのメンドイなとか思ったりはしますが、ちゃんと別のClientに発行されたAccess Tokenを<code>input_token</code>として送るとエラーが帰ってくるし、Success Responseにはscopeとかissued_atとかも付いてくるので、いろいろと使い勝手は良さそうですね。まぁ例のごとく完全に独自仕様ですが。</p>


<p>って実際にGraph API Explorerで試したら、issued_at返ってこないですが（謎</p>


<p>オフィシャルドキュメントはこちら。</p>


<p><a href="https://developers.facebook.com/docs/howtos/login/debugging-access-tokens/">Debugging Access Tokens and Handling Errors</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello OAuth 2.0, Good-bye OAuth 1.0!]]></title>
    <link href="http://oauthjp.github.io/blog/2012/10/13/hello-oauth-20-good-bye-oauth-10/"/>
    <updated>2012-10-13T00:00:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2012/10/13/hello-oauth-20-good-bye-oauth-10</id>
    <content type="html"><![CDATA[<p>おっす、おらOAuthおにーさん！</p>


<h3>ついにOAuth 2.0 CoreとBearerがそれぞれRFCに！！！</h3>


<p><a href="http://tools.ietf.org/html/rfc6749">RFC 6749 - The OAuth 2.0 Authorization Framework</a></p>


<p><a href="http://tools.ietf.org/html/rfc6750">RFC 6750 - The OAuth 2.0 Authorization Framework: Bearer Token Usage</a></p>


<p>このブログができたころには既にOAuth 2.0のdraftが出てたのですが、そういえばOAuth.jpっていつできたんだっけ？と思ってみて見ると…</p>


<p><a href="http://oauthjp.github.io/blog/2010/07/04/oauthjp">OAuth.jpを立ち上げました。 - OAuth.jp</a></p>


<p>2010年7月！</p>


<p>そんな長い間やってたのか。。</p>


<p>FB Graph APIが出たのが2010年4月なので、OAuth 2.0の実装がでてからかれこれ2年半ほどでようやくRFCになった訳ですね。</p>


<h3>さて、RFC化された直後の国内の反応ですが..</h3>


<blockquote class="twitter-tweet">
<p>「Twitterさん、もう、OAuth 1.0古いっすよ。」って誰か言え！オレは言わない！</p>
<div><a href="https://twitter.com/ritou/status/256932933263294464">October 13, 2012</a></div>
</blockquote>


<blockquote class="twitter-tweet">
<p>twitterさん、もう OAuth 1.0 古いですよ。正式に deprecate されました。 RT @<a href="https://twitter.com/ritou">ritou</a>: 「Twitterさん、もう、OAuth 1.0古いっすよ。」って誰か言え！オレは言わない！</p>
<div><a href="https://twitter.com/_nat/status/256945174251442176">October 13, 2012</a></div>
</blockquote>


<blockquote class="twitter-tweet">
<p>OAuth 1.0はもぅ古いので、Twitterの関係者は至急おっおーっす学会長の私に連絡してください。日本語の分からない本国のバカどもは話にならないので、Twitter Japanの関係者に限ります。キリッ！ノブッ！</p>
<div><a href="https://twitter.com/IdentityNobuwo/status/256951736630132736">October 13, 2012</a></div>
</blockquote>


<p>そうなんです。OAuth 2.0 Coreには、こう書いてあるんですね。</p>


<blockquote class="posterous_short_quote">
<div>This specification replaces and obsoletes the OAuth 1.0 protocol described in RFC 5849.</div>
</blockquote>


<p>OAuth 1.0サポートしてるTwitter APIとかOpenSocial採用してるプラットフォーム各社とか、どうなるんでしょうね？</p>


<p>そういえばそれ以外にも @ritou がまたブログ記事書いてましたね。</p>


<p><a href="http://d.hatena.ne.jp/ritou/20121013/1350128492">RFCになったOAuth 2.0を使ってGoogleはどれだけパスワード入力を減らせるのか - r-weblife</a></p>


<p>OAuthおねーさんの次回作が気になるところです。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[@IT連載 - デジタル・アイデンティティ技術最新動向]]></title>
    <link href="http://oauthjp.github.io/blog/2012/10/12/it/"/>
    <updated>2012-10-12T00:00:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2012/10/12/it</id>
    <content type="html"><![CDATA[<p><a href="http://kyomichi.tumblr.com/post/33428806421/it" class="tumblr_blog">kyomichi</a>:</p>




<blockquote><p>第1回 <a href="http://www.atmarkit.co.jp/fsecurity/rensai/digid01/01.html">「OAuth」の基本動作を知る</a></p>

<p>第2回 <a href="http://www.atmarkit.co.jp/ait/articles/1209/10/news105.html">RFCとなった「OAuth 2.0」――その要点は？</a></p>

<p>第3回 <a href="http://www.atmarkit.co.jp/ait/articles/1209/20/news140.html">OpenIDが果たす役割を知る</a></p>

<p>第4回 <a href="http://www.atmarkit.co.jp/ait/articles/1209/27/news138.html">「OpenID Connect」を理解する</a></p></blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuthのoffline_accessについて]]></title>
    <link href="http://oauthjp.github.io/blog/2012/10/01/oauthofflineaccess/"/>
    <updated>2012-10-01T00:00:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2012/10/01/oauthofflineaccess</id>
    <content type="html"><![CDATA[<p>少し前ですが、OpenID Connectのbitbuckeetで<a href="https://bitbucket.org/openid/connect/issue/539/messages-0-add-scope-for-offline-access">offline_accessについての議論</a>がされていたので、まとめておきます。</p>


<h3>Googleの場合</h3>


<h4>offline access の定義</h4>


<ul><li>refresh tokenが発行されるのがoffline。</li>
<li>特にoffline accessを要求しない限り、デフォルトではonline accessを要求したものと見なされる。</li>
<li>online accessの場合はrefresh tokenは発行されない。</li>
<li>refresh tokenはユーザーがrevokeするまで有効。</li>
</ul>


<h4>auto approval</h4>


<ul><li>一度ApproveされたClientに対しては、accessがrevokeされるまでは次回以降のAuthorization Request時の同意画面はスキップされる。</li>
<li>同意画面がスキップされる場合、refresh tokenは発行されない。</li>
</ul>


<h4>promptとaccess_type</h4>


<ul><li>Authorization Request時にprompt=trueというパラメーターを指定すると、auto approvalを無効化し、ユーザーに同意画面を見せることができる。</li>
<li>同様にaccess_type=offlineを指定すると、offline accessを要求できる。</li>
<li>access_type=offlineを指定した場合、初回同意時にのみrefresh tokenが発行される。</li>
<li>それ以降もrefresh tokenが必要な場合は、prompt=trueとaccess_type=offlineを同時に指定すること。</li>
</ul>


<h3>AOLの場合</h3>


<h4>offline accessの定義</h4>


<ul><li>デフォルトではcode flowでは常にrefresh tokenが返される。</li>
<li>refresh tokenはユーザーがログアウトするまで有効。</li>
<li>ユーザーがログアウトしても有効なrefresh tokenが欲しい場合は、scopeにoffline_accessを指定する。</li>
</ul>


<h4>auto approval</h4>


<ul><li>ユーザーが明示的にチェックボックスにチェックを入れた場合のみ、次回以降の同意画面がスキップされる。</li>
<li>同意画面がスキップされるケースでも、offline_accessを要求することができる。</li>
</ul>


<p>ところで<a href="https://bitbucket.org/openid/connect/issue/539/messages-0-add-scope-for-offline-access">このIssue</a>、まだopenですね。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WebSocketでOAuth 2.0を使ってみた]]></title>
    <link href="http://oauthjp.github.io/blog/2012/08/09/websocketoauth-20/"/>
    <updated>2012-08-09T00:00:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2012/08/09/websocketoauth-20</id>
    <content type="html"><![CDATA[<p>WebSocket Serverでユーザー認証とか、WebSocket Serverの裏にRailsなりのAPIがあってNode.jsからそのAPI叩く見たいなのはそれなりにありそうなのに、あんまサンプルコード的なものが見当たらなかったので、自分で書いてみたのをここに公開することにします。</p>


<p>ClientがWebSocket Serverにつなぐ時、<em><a href="http://socket.example.com/?access_token="><a href="http://socket.example.com/?access_token=">http://socket.example.com/?access_token=</a></a>***</em> みたいなURLにアクセスして、ServerはそのToken元にユーザーを認証して、その後socketがつながってる間はNode.jsがそのtoken使って裏のRails APIにアクセスする、という使い方をしてます。</p>


<p>Access Tokenの保存先にMySQL使ってるのはあくまでRails側でそっちのが手っ取り早かったからで、ここはRedisでもMongoDBでもなんでもいいです。この例ではNode.js側ではAccess Tokenに紐づいたClientとかScopeとかを検証してないし。</p>


<p><a href="https://gist.github.com/3300227"><a href="https://gist.github.com/3300227">https://gist.github.com/3300227</a></a></p>


<p>ところで、WebSocketではCookieベースの認証方式が主流なんですかね？</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Re: OAuth 2.0のclient_secretって本当に秘密鍵ですか？]]></title>
    <link href="http://oauthjp.github.io/blog/2012/08/03/re-oauth-20clientsecret/"/>
    <updated>2012-08-03T00:00:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2012/08/03/re-oauth-20clientsecret</id>
    <content type="html"><![CDATA[<p>昨日こんな記事を見かけたので、記事にまとめることにします。</p>


<p><a href="http://koduki.hatenablog.com/entry/2012/07/16/113204">OAuth2.0のclient_secretって本当に秘密鍵ですか？</a></p>


<p>元記事にあるとおり、現状Native AppでのOAuth 2.0の実装は、API提供者・利用者ともにポリシーがバラバラで、混乱の元になっていると思います。</p>


<blockquote class="posterous_medium_quote">
<p>Googleのドキュメントにも「the client_secret is obviously not treated as a secret.」とあるわけだけど、そのくせclient_secretを使ってるし、ネットで調べても少なくない数の人がアプリに埋め込んでるので、client_secretを公開したときの問題を考えてみる。</p>
</blockquote>


<h3>&#8220;offline&#8221; アクセスと &#8220;online&#8221; アクセス</h3>


<p>Googleは、<strong>&#8220;offline access&#8221;</strong> に対して以下のようなポリシーを持っています。</p>


<p><a href="http://googleappsdeveloper.blogspot.jp/2011/10/upcoming-changes-to-oauth-20-endpoint.html">Upcoming changes to OAuth 2.0 endpoint - Google Apps Developer Blog</a></p>


<p><a href="https://bitbucket.org/openid/connect/issue/539/messages-0-add-scope-for-offline-access">openid / connect / issues / #539 - Messages - 0. Add scope for offline access - Bitbucket</a></p>


<p>上の記事では議論が長くてかつ英語なので、簡単に要約すると、</p>


<ul><li>access tokenが無効化されると、clientは新しいaccess tokenを取得しなければならない。</li>
<li>新しいaccess tokenを受け取るには、ユーザーがその場にいる必要がある。<strong>ユーザーが既にclientのアクセスに同意している場合は、同意画面をスキップさせることができる</strong>ので、ユーザーが毎回Googleの同意画面を見る必要は無い。</li>
<li>JS Appなど、ブラウザ内で動作していて常にユーザーとインタラクションしているclientは、同意画面さえスキップできればリダイレクトベースで必要に応じて毎回access tokenを取得すればよい。</li>
<li>スマホ上のNative Appの場合は、UX的に毎回ブラウザ経由してaccess tokenを取得するのはつらいので、<strong>ユーザーから明示的に &#8220;offline&#8221; アクセスへの同意を得て</strong>、次回以降はrefresh tokenを使って新しいaccess tokenを取得すればよい。</li>
</ul>


<p>そして、Googleは、refresh tokenを伴う場合を &#8220;offline&#8221; アクセス、伴わない場合を &#8220;online&#8221; と定義しています。詳細は異なるものの、似たような定義はFacebookやAOLなども行っています。</p>


<h3>Native Appに埋め込まれたclient_secretは簡単に漏洩する</h3>


<p>このご時世 <a href="http://www.charlesproxy.com">Charles</a> などを使えば、自分のデバイス上で行われているSSLリクエストなら簡単に覗き見ることができます。</p>


<p>OAuth 2.0では、authorization codeとaccess tokenを交換する時とrefresh tokenをaccess tokenと交換する時に、client_secretを平文でAuthorization Server (この場合はGoogle) に送信します。</p>


<p>そのため、上記2つのいずれかのリクエストがiPhone上のNative Appから発行されるなら、Jailbreakや逆コンパイルなどせずともエンドユーザーなら誰でも、そのアプリに埋め込まれたclient_secretを知ることができます。</p>


<p>OAuth 2.0のclient_secretをアプリに埋め込んで配布するというのは、client_secretが漏洩する前提でそれを扱っているということです。そしてその場合、当然以下のような疑問がでてきます。</p>




<h3>client_secretが漏洩してはいけないのか？</h3>


<p>これに関しては、例えばFacebook Graph APIの場合であれば、client_secretが漏洩すると以下のようなリスクがあります。(個人的にGoogle APIは使ってないので、Googleに関しては僕はよく把握していません)</p>


<blockquote class="twitter-tweet">
<p><a href="https://twitter.com/gabunomi_">@<strong>gabunomi_</strong></a> FB Graph APIなら、client_secretさえあれば、任意のユーザーをそのアプリからBanしたり、Banを解除できたりするはずです。まぁ4sqユーザーを全員Banすれば、FBがそれを検知してなんらか対応してくるとは思いますが。</p>
— nov matakeさん (@nov) <a href="https://twitter.com/nov/status/230990719257559040">8月 2, 2012</a></blockquote>




<p>client_secretが漏洩した場合のリスクはAPI提供者側のポリシーに依存するため、Generalな解答をするとすれば以下のようになるでしょう。(ちなみに、いまClient Credentials Flowがサポートされていないからといって、将来にわたってその状態が維持される保証があるわけではないです。その場合はclient_secretを発行しなおしたりするんでしょうかね？ &gt; だれとなく)</p>


<blockquote class="twitter-tweet">
<p><a href="https://twitter.com/gabunomi_">@<strong>gabunomi_</strong></a> API提供者側に「なんでここでclient_secret埋め込ませてんの？」って問い合わせて、明確な回答が返ってくるなら、1 clientとしてはそれでOKかと。「いろいろあってしょうがなく」とか言われたら危険です。被害受けるとしたらユーザーじゃないあなた。</p>
— nov matakeさん (@nov) <a href="https://twitter.com/nov/status/230997139705188352">8月 2, 2012</a></blockquote>




<p>全てのAPI提供者がNative Appに埋め込まれたclient_secretが漏洩することを前提としたアクセスコントロールを実施しているわけでも無いようですし、そもそもNative Appにclient_secretを埋め込むことを禁止しているFacebookのようなOAuth Serverも存在する (=&gt; 本来こっちの方が一般的であるべき) ので、Developerにとっては混乱の元でしょうね。</p>


<p>Native Appにclient_secretを埋め込む前提で、その漏洩の可能性という点で見れば、OAuth 1.0を使った方が良い場合もあるでしょう。OAuth 1.0では、Native Appにclient_secretを埋め込んでもそれは署名計算に使われるだけで直接OAuth Serverに送信されることはありません。かといっていまからOAuth 1.0を採用するというのは、時代の流れ的にどうなんだということもありますが。</p>


<blockquote class="twitter-tweet">
<p><a href="https://twitter.com/gabunomi_">@<strong>gabunomi_</strong></a> OAuth 2.0では（JWT assertionなどを使わない限り）token endpointにclient secretを平文で送るので、埋め込まれたsecretは逆コンパイル無しでも容易にsecretは漏洩します。そこはOAuth 1.0のがまし。</p>
— nov matakeさん (@nov) <a href="https://twitter.com/nov/status/231186384424157184">8月 3, 2012</a></blockquote>


<h3>GoogleとFacebookのスタンスの違い</h3>


<p>GoogleがNative App (= Installed Application) 用のフローを用意してNative Appにclient_secretを埋め込むように案内する一方、Native AppにはFB Official Appと連携したフローを用意してclient_secretを不要にしているFacebookの存在は、対照的です。</p>


<p>Googleの場合は、Client登録時にClientがWeb AppなのかNative Appなのかといった分類をさせているはずで、そのclient typeによってclient_secretを使ってできることに差を付けているのかもしれません。(<strong>要確認</strong>: Google APIよく知らないので、この辺詳しい人いたら教えてほしい)</p>


<p>Facebookの場合は、Native AppとWeb App、Facebook iFrame Appといった複数の種類のClientを、提供者が同一であれば同じclient_id (&amp; client_secret) を使い回せるようにして、cross-platformな環境でアプリを提供しやすくしているため、client typeによってclient_secretの価値を変えるということはやりづらいのかも知れません。(じゃあGoogleはcross-platformなClientに対してどう考えてるの？ってのは、Googlerに直接聞いてみたいかも)</p>


<h3>client_secretが漏洩した時に被害を受けるのは誰？</h3>


<p>これもまた各OAuth ServerがどんなAPIを提供していて、OAuth 2.0のClient Credentials Flowを使って得たaccess tokenで何ができるのかに依存するので、一概には言えないのですが、よくあるケースとしてはAPI利用状況のAnalytics情報を取得したりするAPIが考えられるので、被害を受けるのはエンドユーザーというよりはClient Developer自身であることの方が多いでしょう。</p>


<p>client_secretを埋め込む実装をしているOAuth Client Developerは、一度利用しているAPIがClient Credentials Flowをサポートしているのか、Client Credentials Flowで得たaccess tokenでは何ができるのか、一度APIドキュメントを確認したりAPI提供者に問い合わせてみた方が良いかも知れません。</p>


<p>Facebookの用にclient_secretさえあれば任意のユーザーをBanできてしまったりする場合は、client_secretが漏洩することでClient Developerとエンドユーザー両方が被害を受けることもありえます。</p>


<h3>蛇足: オレはこう思う！（だっけ？）</h3>


<p>まぁこの辺りはOAuth 1.0からOAuth 2.0になってServer / Client双方にいろいろ選択肢が増えたので、各社バラバラな仕様になってしまって</p>


<blockquote>
<p>When compared with OAuth 1.0, the 2.0 specification is more complex, less interoperable, less useful, more incomplete, and most importantly, less secure.</p>
<p><a href="http://hueniverse.com/2012/07/oauth-2-0-and-the-road-to-hell/">OAuth 2.0 and the Road to Hell</a></p>
</blockquote>


<p>っていう前OAuth 2.0 Authorの彼の意見も、あながち無視できないところではある。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth 2.0 Implicit Flow で認証の問題点、再び。]]></title>
    <link href="http://oauthjp.github.io/blog/2012/06/29/oauth-20-implicit-flow-78852/"/>
    <updated>2012-06-29T00:00:00+09:00</updated>
    <id>http://oauthjp.github.io/blog/2012/06/29/oauth-20-implicit-flow-78852</id>
    <content type="html"><![CDATA[<p>おひさしぶりです、@novです。</p>


<p>最近は、新しいFacebook iOS SDK使ってるアプリを見つけるとまず<a href="http://oauthjp.github.io/blog/2012/02/08/ios-sdk">Token置換攻撃</a>を試みていますが、結構高い確率でこの攻撃に対して脆弱なアプリがみつかります。困ったものです。。</p>


<p>そんななか、2週間ほど前に、Micosoft Researchの人がIETF OAuth WGのメーリングリストに<a href="http://www.ietf.org/mail-archive/web/oauth/current/msg09270.html">同じ問題を提起していました</a>。該当Threadでは少し話題が脱線している部分もありますが、もともと最初にこの問題を提起したJohn BradleyがOAuth 2.0 CoreにSecurity Considerationsを追加する流れのようです。</p>


<p>これが現状の改善につながれば良いのですが、そう簡単に行かないかもなとも思います。というのも、この問題、<strong>なかなかデベロッパーにとって理解されない</strong>傾向があります。</p>


<p>そこで今日は、これまでいくつかのアプリデベロッパーに対して脆弱性報告をしたときの反応をまとめてみたいと思います。</p>


<h3>反応1: そもそも置換攻撃に使うためのaccess token奪われてる時点でアウトじゃね？</h3>


<p>確かにFacebookのaccess tokenを悪用されると、困ります。勝手にFacebookに変なリンクを投稿されたり、プロフィール情報を抜かれたりすることもあるでしょう。が、そういったFacebookアカウントに対する攻撃と、Facebook以外のサービスでもアカウントが乗っ取られるということは別問題です。</p>


<p>あるFacebook連携を行っているサービスからFacebookのaccess tokenが漏洩した時に、Facebookの自分のタイムラインを荒らされることと、いままで自分がFacebookと連携したさまざまなサービスでアカウントが乗っ取られることは、別でしょう？</p>


<h3>反応2: 攻撃用アプリをインストールしなきゃ被害にあわないでしょ？</h3>


<p>攻撃用アプリはどうせAppleの審査を通らないから、被害者がそれをインストールする可能性はきわめて低い、という主張をする人もいました。</p>


<p>が、攻撃用アプリは、攻撃者自身がXcode経由で自分のiPhoneにインストールすればいいだけなので、AppStoreに並ぶ必要もないですし、Appleの審査を通る必要もなく、Jailbreakすらいりません。</p>


<p>さらに言うと、攻撃用アプリは、Objective-C初心者の僕が数時間で作れる程度のものです。</p>


<h3>反応3: access token受け取った側がそれ検証するのは当然。Facebook側は問題ない。</h3>


<p>確かにFacebook側はtokenの発行先検証のためのAPIも用意しているし、Facebook iOS SDKにバグがあるというわけでも無いです。が、FB iOS SDKを使って同じあやまちを犯しているアプリがあまりに多く、僕が調べた5つのiOSアプリ中、4つが同じ過ちを犯していました。この状況では、さすがにFacebook側もドキュメントにこの脆弱性に対する注意および解決策を明記したり、FB iOS SDKのサンプルコードを修正したりする必要があるのではないかと思います。</p>


<h3>反応4: OAuth 2.0のImplicit Flowを認証に使うのがまず誤り。OpenID Connect使うべき。</h3>


<p>正論ではあると思うのですが、API提供者側がOpenID Connectに対応できていない状況では、API利用者を混乱させるだけなような気もします。現状の仕組みで解決できる方法もあるので、まずはそちらを伝えることが先決ではないでしょうか。</p>


<h3>反応5: パスワード忘れちゃったの？ここに登録したメールアドレス入力したら、パスワードリセットできるよ。</h3>


<p>この反応にはさすがにびっくりしました。</p>


<p>とまぁ、混乱する理由も理解できるものからまったくとんちんかんなものまで、様々な反応がありましたが、</p>


<ul><li>みなさんのアプリは外部APIを使って認証していますか？</li>
<li>そのAPIはOAuthベースですか？</li>
<li>アプリからaccess tokenを受け取った時、Web API側では毎回token発行先が自分のアプリかどうか確認していますか？</li>
</ul>


<p>もし上記の質問に答えられない場合、自分のアプリが安全かどうか分からない場合は、お気軽にこのブログのコメント欄に質問していただければと思います。もちろんOAuth.jpのFacebook PageやTwitterアカウントに質問投げかけてくれても構いません。（Twitterの場合は、@oauthjp より @nov に質問してくれた方が気がつきやすいと思います）</p>


<p>ではでは！</p>

]]></content>
  </entry>
  
</feed>
